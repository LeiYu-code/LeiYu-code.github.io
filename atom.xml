<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>南月晨的博客</title>
  
  <subtitle>南山下，月落时，必有晨</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-12-26T08:30:01.291Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>yu skywalker</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>解决git报错port 22</title>
    <link href="http://example.com/2024/12/26/%E8%A7%A3%E5%86%B3git22port%E9%94%99/"/>
    <id>http://example.com/2024/12/26/%E8%A7%A3%E5%86%B3git22port%E9%94%99/</id>
    <published>2024-12-26T08:30:06.000Z</published>
    <updated>2024-12-26T08:30:01.291Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p><p><a href="http://leiyu-code.github.io">leiyu-code.github.io</a></p><p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p><h1>【git】解决git报错:ssh:connect to host <a href="http://github.com">github.com</a> port 22: Connection timed out 亲测有效</h1><p><strong>简介：</strong> 【git】解决git报错:ssh:connect to host <a href="http://github.com">github.com</a> port 22: Connection timed out 亲测有效</p><p>如题，git使用中突然报错</p><p>ssh:connect to host <a href="http://github.com">github.com</a> port 22: Connection timed out</p><p>通过查阅各种资料，得知原因可能是由于电脑的防火墙或者其他网络原因导致ssh连接方式 端口22被封锁。</p><h3 id="解决方法">解决方法</h3><h3 id="一：抛弃ssh连接方式，使用http连接。">一：抛弃ssh连接方式，使用http连接。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --local -e</span><br><span class="line">将配置文件的url = git@github.com:username/repo.git一行改为：url = https://github.com/username/repo.git</span><br></pre></td></tr></table></figure><h3 id="方法二：如果22号端口不行，那就换一个端口">方法二：如果22号端口不行，那就换一个端口</h3><h3 id="进入-ssh文件夹">进入.ssh文件夹</h3><p><img src="https://ucc.alicdn.com/pic/developer-ecology/z7drxuznvgnea_e581f158a2904c7597a852544116edf9.png?x-oss-process=image%2Fresize%2Cw_1400%2Fformat%2Cwebp" alt="img"></p><p>创建一个config文件</p><p>将下面的内容复制进去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">User git</span><br><span class="line">Hostname ssh.github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line">Port 443</span><br><span class="line"> </span><br><span class="line">Host gitlab.com</span><br><span class="line">Hostname altssh.gitlab.com</span><br><span class="line">User git</span><br><span class="line">Port 443</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><p>保存退出</p><p>检查是否成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com </span><br></pre></td></tr></table></figure><p><img src="https://ucc.alicdn.com/pic/developer-ecology/z7drxuznvgnea_100fca1cccc640c5a97a74b802cf6594.png?x-oss-process=image%2Fresize%2Cw_1400%2Fformat%2Cwebp" alt="img"></p><p>这里要根据它的提示操作，有个地方要输入yes</p><p>此时大功告成啦</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;[南月晨的blog](&lt;a href=&quot;https://leiyu-code.github.io/&quot;&gt;南月晨的博客 (leiyu-code.github.io)&lt;/a&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://leiyu-code.</summary>
      
    
    
    
    <category term="git" scheme="http://example.com/categories/git/"/>
    
    
    <category term="github" scheme="http://example.com/tags/github/"/>
    
    <category term="wrong" scheme="http://example.com/tags/wrong/"/>
    
    <category term="port" scheme="http://example.com/tags/port/"/>
    
  </entry>
  
  <entry>
    <title>VS CODE配置c/c++扩展</title>
    <link href="http://example.com/2024/12/16/VS%20CODE%E9%85%8D%E7%BD%AEc++%E6%89%A9%E5%B1%95/"/>
    <id>http://example.com/2024/12/16/VS%20CODE%E9%85%8D%E7%BD%AEc++%E6%89%A9%E5%B1%95/</id>
    <published>2024-12-16T03:15:06.000Z</published>
    <updated>2024-12-16T03:20:32.448Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p><p><a href="http://leiyu-code.github.io">leiyu-code.github.io</a></p><p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p><h1><strong>VS CODE配置c/c++扩展</strong></h1><ol><li><p>安装扩展</p><ul><li>首先要安装 “C/C++” 扩展。打开 VS Code，点击左侧的 “扩展” 图标（看起来像方块的拼图），在搜索框中输入 “C/C++”，找到由 Microsoft 发布的 “C/C++” 扩展并安装。这个扩展提供了代码导航、语法检查、调试支持等功能，是调试 C 语言程序的基础。</li></ul></li><li><p>配置编译器</p><ul><li><p>Windows 系统</p><ul><li>安装 MinGW - W64。可以从官方网站（<a href="https://mingw">https://mingw</a> - <a href="https://w64.org/doku.php">w64.org/doku.php</a>）下载安装程序。在安装过程中，注意选择合适的架构（如 x86_64 或 i686）和版本（如 SEH 或 DW2 异常处理）。</li><li>将 MinGW - W64 的安装目录下的<code>bin</code>文件夹路径添加到系统环境变量。在 “控制面板” - &gt;“系统和安全” - &gt;“系统” - &gt;“高级系统设置” - &gt;“环境变量” 中，在 “系统变量” 部分找到 “Path” 变量，点击 “编辑”，然后添加 MinGW - W64 的<code>bin</code>路径，例如<code>C:\mingw - w64\mingw64\bin</code>。</li></ul><span id="more"></span></li><li><p>Linux 系统</p><ul><li>大多数 Linux 发行版都自带 GCC 编译器。可以通过在终端中输入<code>gcc - v</code>来检查是否已经安装。如果没有安装，可以使用包管理器进行安装。例如，在 Ubuntu 系统中，使用命令<code>sudo apt - get install gcc</code>进行安装。</li></ul></li><li><p>MacOS 系统</p><ul><li>MacOS 也可以使用 GCC 或者 Clang 编译器。Clang 通常是 Xcode 自带的，可以通过在终端中输入<code>clang - v</code>来检查是否已安装。如果需要安装 GCC，可以使用 Homebrew（<a href="https://brew.sh/%EF%BC%89%E7%AD%89%E5%B7%A5%E5%85%B7%E8%BF%9B%E8%A1%8C%E5%AE%89%E8%A3%85%EF%BC%8C%E5%91%BD%E4%BB%A4%E4%B8%BA">https://brew.sh/）等工具进行安装，命令为</a><code>brew install gcc</code>。</li></ul></li></ul></li><li><p>创建调试配置文件（launch.json）</p><ul><li><p>在 VS Code 中打开你的 C 语言项目文件夹。</p></li><li><p>点击左侧的 “运行和调试” 图标（看起来像一个虫子），然后点击 “创建一个 launch.json 文件”。</p></li><li><p>在弹出的调试器类型选择框中，选择 “C++（GDB/LLDB）”。这会生成一个基本的<code>launch.json</code>文件，它用于配置调试会话。</p></li><li><p>编辑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">launch.json</span><br></pre></td></tr></table></figure><p>文件，以下是一个简单的示例：</p><p>json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: gcc - 构建和调试活动文件&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;你的gdb路径&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;为 gdb 启用整齐打印&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;- enable - pretty - printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   - 对于`miDebuggerPath`字段，在Windows系统下如果安装了MinGW - W64，它可能是`C:\mingw - w64\mingw64\bin\gdb.exe`；在Linux系统下通常是`/usr/bin/gdb`；在MacOS系统下如果使用GCC可能是`/usr/local/bin/gdb`（如果是通过Homebrew安装）或者其他路径（具体要看安装情况）。</span><br><span class="line">4. 编写并调试C语言代码</span><br><span class="line">   - 在VS Code中打开一个C语言文件，编写代码。例如：</span><br><span class="line">     ```c</span><br><span class="line">     #include &lt;stdio.h&gt;</span><br><span class="line">     int main()</span><br><span class="line">     &#123;</span><br><span class="line">       int a = 10;</span><br><span class="line">       int b = 20;</span><br><span class="line">       int sum = a + b;</span><br><span class="line">       printf(&quot;两数之和为：%d\n&quot;, sum);</span><br><span class="line">       return 0;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><ul><li>设置断点。在代码行号的左侧空白处点击，会出现一个红点，这就是断点。例如，在<code>printf(&quot;两数之和为：%d\n&quot;, sum);</code>这一行设置断点。</li><li>点击左侧 “运行和调试” 图标，然后点击绿色的 “启动调试” 按钮（或者使用快捷键<code>F5</code>）。</li><li>此时程序会运行到断点处停止，你可以在调试控制台（可以通过 “视图” - &gt;“调试控制台” 打开）查看变量的值，也可以使用调试工具栏（有继续、单步执行等按钮）来逐步执行程序，观察程序的运行状态。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;[南月晨的blog](&lt;a href=&quot;https://leiyu-code.github.io/&quot;&gt;南月晨的博客 (leiyu-code.github.io)&lt;/a&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://leiyu-code.github.io&quot;&gt;leiyu-code.github.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.linuxcool.com/&quot;&gt;Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;&lt;strong&gt;VS CODE配置c/c++扩展&lt;/strong&gt;&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装扩展&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先要安装 “C/C++” 扩展。打开 VS Code，点击左侧的 “扩展” 图标（看起来像方块的拼图），在搜索框中输入 “C/C++”，找到由 Microsoft 发布的 “C/C++” 扩展并安装。这个扩展提供了代码导航、语法检查、调试支持等功能，是调试 C 语言程序的基础。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置编译器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Windows 系统&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装 MinGW - W64。可以从官方网站（&lt;a href=&quot;https://mingw&quot;&gt;https://mingw&lt;/a&gt; - &lt;a href=&quot;https://w64.org/doku.php&quot;&gt;w64.org/doku.php&lt;/a&gt;）下载安装程序。在安装过程中，注意选择合适的架构（如 x86_64 或 i686）和版本（如 SEH 或 DW2 异常处理）。&lt;/li&gt;
&lt;li&gt;将 MinGW - W64 的安装目录下的&lt;code&gt;bin&lt;/code&gt;文件夹路径添加到系统环境变量。在 “控制面板” - &amp;gt;“系统和安全” - &amp;gt;“系统” - &amp;gt;“高级系统设置” - &amp;gt;“环境变量” 中，在 “系统变量” 部分找到 “Path” 变量，点击 “编辑”，然后添加 MinGW - W64 的&lt;code&gt;bin&lt;/code&gt;路径，例如&lt;code&gt;C:\mingw - w64\mingw64\bin&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="vs code" scheme="http://example.com/categories/vs-code/"/>
    
    
    <category term="software" scheme="http://example.com/tags/software/"/>
    
    <category term="extentions" scheme="http://example.com/tags/extentions/"/>
    
  </entry>
  
  <entry>
    <title>佳软推荐——最快的文件搜索工具Everything</title>
    <link href="http://example.com/2024/12/13/%E4%BD%B3%E8%BD%AF%E6%8E%A8%E8%8D%90%E2%80%94%E2%80%94%E6%9C%80%E5%BF%AB%E7%9A%84%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2%E5%B7%A5%E5%85%B7Everything/"/>
    <id>http://example.com/2024/12/13/%E4%BD%B3%E8%BD%AF%E6%8E%A8%E8%8D%90%E2%80%94%E2%80%94%E6%9C%80%E5%BF%AB%E7%9A%84%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2%E5%B7%A5%E5%85%B7Everything/</id>
    <published>2024-12-13T03:28:06.000Z</published>
    <updated>2024-12-13T03:22:02.667Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p><p><a href="http://leiyu-code.github.io">leiyu-code.github.io</a></p><p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p><p><em><strong>实用场景（超市  网站前台）</strong></em></p><p><em><strong>在一般的超市网站上，动辄就要更新成千上万个图片，一般都是按照商品条码进行搜索，windows自带的搜索半天都不见得能找出来，但是用everything这个软件一瞬间就能把这个商品找出来，而且预览缩略图也能在右边的预览框里显示</strong></em></p><ol><li><p>软件基本信息</p><ul><li>Everything 是一款由 VoidTools 开发的文件搜索工具，它适用于 Windows 操作系统。其特点是搜索速度极快，可以在短时间内索引和搜索本地硬盘、外置硬盘、USB 设备等存储介质中的文件和文件夹。</li></ul></li><li><p>工作原理</p><ul><li>它通过建立文件索引来实现快速搜索。当软件首次运行时，它会扫描指定的磁盘分区或者整个硬盘，记录下每个文件的名称、路径、大小、日期等信息，并将这些信息存储在一个数据库中。之后，当用户进行搜索时，它不是像 Windows 自带的搜索那样逐个文件夹去查找，而是直接在这个已经建立好的数据库中进行快速匹配，所以能够快速地返回搜索结果。</li></ul><span id="more"></span></li><li><p>功能特点</p><ul><li><strong>快速搜索</strong>：例如，在一个拥有大量文件（如数百万个文件）的硬盘上，用户可以在输入文件名的几秒钟内就得到搜索结果。比如，要找一份名为 “项目报告.docx” 的文件，只需在搜索框中输入文件名的一部分，如 “项目”，它就能快速地将包含 “项目” 字样的所有文件列出来。</li><li><strong>支持通配符搜索</strong>：可以使用通配符 “<em>” 和 “?” 来进行模糊搜索。“</em>” 代表任意多个字符，“?” 代表一个任意字符。例如，搜索 “*.jpg” 可以找到所有的 JPEG 图片文件；搜索 “te?t.txt” 可以找到类似 “test.txt”“text.txt” 等文件名符合条件的文件。</li><li><strong>高级搜索功能</strong>：可以根据文件大小、日期、文件属性等条件进行搜索。如果想找一个在特定日期范围内修改过的文件，或者文件大小大于一定值的文件，都可以通过软件的高级搜索选项来实现。</li><li><strong>实时更新索引</strong>：当文件系统发生变化，如新建文件、删除文件、重命名文件时，Everything 会自动更新索引，以确保搜索结果的准确性。不过，在某些情况下，如果索引更新不及时，可以手动刷新索引。</li></ul></li><li><p>软件使用场景</p><ul><li><strong>办公场景</strong>：对于办公人员来说，当电脑中有大量的文档、表格、演示文稿等文件时，能够快速找到所需文件可以大大提高工作效率。<em><strong>比如，在一个广告公司的设计师电脑上，有多年积累的各种设计素材、客户项目文件等，使用 Everything 可以快速定位到某个特定的设计源文件或者客户要求修改的文档。</strong></em></li><li><strong>技术支持场景</strong>：对于计算机技术人员，在处理客户电脑问题或者进行系统维护时，需要快速查找系统文件、驱动程序文件等，Everything 就成为一个很有用的工具。<em><strong>例如，查找一个特定版本的设备驱动程序文件，通过快速搜索就可以定位其位置，方便进行更新或者故障排除。</strong></em></li></ul></li></ol><hr><p><strong>总结：用Everything替代windows内置的搜索工具是最好的选择，可以更有效、更快速地定位想要找的项目或文件</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;[南月晨的blog](&lt;a href=&quot;https://leiyu-code.github.io/&quot;&gt;南月晨的博客 (leiyu-code.github.io)&lt;/a&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://leiyu-code.github.io&quot;&gt;leiyu-code.github.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.linuxcool.com/&quot;&gt;Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;实用场景（超市  网站前台）&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;在一般的超市网站上，动辄就要更新成千上万个图片，一般都是按照商品条码进行搜索，windows自带的搜索半天都不见得能找出来，但是用everything这个软件一瞬间就能把这个商品找出来，而且预览缩略图也能在右边的预览框里显示&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;软件基本信息&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Everything 是一款由 VoidTools 开发的文件搜索工具，它适用于 Windows 操作系统。其特点是搜索速度极快，可以在短时间内索引和搜索本地硬盘、外置硬盘、USB 设备等存储介质中的文件和文件夹。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;工作原理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它通过建立文件索引来实现快速搜索。当软件首次运行时，它会扫描指定的磁盘分区或者整个硬盘，记录下每个文件的名称、路径、大小、日期等信息，并将这些信息存储在一个数据库中。之后，当用户进行搜索时，它不是像 Windows 自带的搜索那样逐个文件夹去查找，而是直接在这个已经建立好的数据库中进行快速匹配，所以能够快速地返回搜索结果。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="software" scheme="http://example.com/categories/software/"/>
    
    
    <category term="everything" scheme="http://example.com/tags/everything/"/>
    
    <category term="searth" scheme="http://example.com/tags/searth/"/>
    
  </entry>
  
  <entry>
    <title>一个小数点的故事</title>
    <link href="http://example.com/2024/11/12/%E4%B8%80%E4%B8%AA%E5%B0%8F%E6%95%B0%E7%82%B9%E7%9A%84%E6%95%85%E4%BA%8B/"/>
    <id>http://example.com/2024/11/12/%E4%B8%80%E4%B8%AA%E5%B0%8F%E6%95%B0%E7%82%B9%E7%9A%84%E6%95%85%E4%BA%8B/</id>
    <published>2024-11-12T07:40:06.000Z</published>
    <updated>2024-11-12T07:44:15.270Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p><p>leiyu-code.github.io</p><p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p><p>前几天发了一个牢骚：</p><p><img src="https://why-image-1300252878.cos.ap-chengdu.myqcloud.com/img/20220716/20241111201609.png" alt="img"></p><p>本来只是单纯的吐槽一下，但是好多人对其中的细节比较感兴趣。</p><p>大家都是搞技术的嘛，对于“踩 BUG”这种喜闻乐见的事情，有兴趣是很正常的。</p><p>其实我这个 BUG，其实严格意义上不能叫做 BUG，因为和程序无关，甚至和技术的关系都不算大。从标题上你也能猜出来，是和一个业务参数相关。</p><p>但是在这个过程中，因为我是整个事件全程的亲历者，所以现在回看这个事情，我还是有一些思考在里面的。</p><p>我觉得这是一个程序员会遇到的“典型事件”。</p><span id="more"></span><p>那就用这篇文章一起复盘一下吧。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h2><p>要说明这个问题的背景，甚至不需要一个具体的业务场景，只需要围绕着以下这个非常常见的利息计算公式，就可以说明问题的起因：</p><blockquote><p>利息&#x3D;计息金额*日利率。<br>日利率&#x3D;年利率&#x2F;360</p></blockquote><p>由于日利率的计算，涉及到除法，在对应需求第一次开发时，业务的要求是日利率保存 7 位小数。</p><p>在程序中，年利率和日利率是两个字段分别保存的，日利率在初始化的时候就算好落库了，后续程序直接取这个算好的日利率就行了。</p><p>系统上线，相安无事。</p><p>跑了一段时间后，业务又提来一个需求：当前的精度不够，需要调整到 11 为小数。</p><p>你不用好奇歪师傅这边到底是什么业务场景，反正我去看了业务数据，需求是合理的，那就把需求接过来干就行了。</p><p>保存 7 位小数和 11 位小数，大家都是搞开发的，肯定也知道这个就是一个小改动，很快就能搞定。</p><p>事实也是如此，虽然之前的需求对应的代码不是我写的，但是我看过代码，清楚的知道改动点在哪，所以很快就开发完成。</p><p>前面说了，这个需求之前在线上按照 7 位小数跑了一段时间，所以存在一些存量配置。</p><p>针对这些存量数据，在需求评审会议上的时候，我提了一句：存量配置怎么处理呢？</p><p>业务答复：这次需求上线的时候，你按照 11 位小数重新算好，然后写 SQL 更新一下就行。</p><p>我心里一盘算：计算公式明确，年利率我也有，算一把，没啥问题。</p><p>就答应了。</p><p>然后，不出意外的出意外了。</p><p>假设年利率是 2.5%，除以 360 之后，保留 11 位小数，应该是 0.00006944444。</p><p>而我不知道当时为什么手抖了，在 SQL 里面写成了 0.00069444444。</p><p>我给你对比一下：</p><blockquote><p>0.00006944444<br>0.00069444444</p></blockquote><p>相当于我写出来的日利率被扩大了十倍。</p><p>然后再回头看看这个公式：</p><blockquote><p>利息&#x3D;计息金额*日利率</p></blockquote><p>日利率被扩大十倍，那么对应的计提金额也会被扩大十倍。</p><p>这就是问题的背景。</p><p>一个单纯的人为失误，和程序没有任何关系，所以严格意义上不属于程序 BUG。</p><p>但是这个问题确实是足够低级。</p><h2 id="为什么没被发现？"><a href="#为什么没被发现？" class="headerlink" title="为什么没被发现？"></a><strong>为什么没被发现？</strong></h2><p>那么这个错误的 SQL 是怎么通过代码评审、测试验证这两道关卡被带到生产环节的呢？</p><p>首先，这一次提交的代码，压根就没有评审环节。</p><p>我有代码提交权限，也有代码审核权限。所以我自己提交，自己就审核通过了。</p><p>其实这个需求应该是组里面另外一个小伙伴来做，但是当时他被调到其他组了。</p><p>他还在我们组的时候，我们的合作模式是他提交代码，我进行审核。</p><p>如果有这个环节，我觉得我有 50% 的几率发现问题。</p><p>为什么是 50% 呢？</p><p>因为这取决于我审核代码时是否有正在处理其他的事情，如果有其他事情处理，我可能会形式主义的看上几眼。如果没有其他事情，而这次提交的代码量又不大的话，我基本上都会认真的过一下提交的内容。</p><p>通过代码评审之后，接下来就应该是测试环节。</p><p>测试主要关注的是精度从 7 位变成 11 位之后，最终计算出来的利息是否符合预期。</p><p>他测试时是走了整个业务的全流程。</p><p>在“全流程”中，这个 11 位精度的日利率，是在页面配置年利率的时候通过程序自动计算出来的，不会错的。</p><p>而他在验证 SQL 语句的时候，测试环境又没有生产环境的配置，所以他拿着我提供的 SQL，只能保证写的语法没问题，能正常执行，并不能确保里面数据的正确性。</p><p>而我也记得很清楚，我当时给他说过：你执行一下 SQL 不报错就行，值的正确性，我来保证。</p><p>而且戏剧性的是，测试同事很仔细的去看了值，他去数了确实是 11 位小数。但是可惜，站在他的视角，他发现不了值被扩大了十倍。</p><p>所以，测试环节也没有发现这个问题：</p><blockquote><p>0.00006944444<br>0.00069444444</p></blockquote><p>就带着上生产了。</p><p>一个问题正常来说不应该被带上生产，但是我们确实不能保证测试环节一定能把所有问题都测出来，所以新项目、新迭代的生产验证也是非常有必要的。</p><p>这个我们也做了。</p><p>按理来说，生产上的数据已经是错误的了，而且是一个“利息金额扩大十倍”的明显的错误，如果主动去做了数据验证，应该能被发现才对。</p><p>那为什么做了生产验证，却没有发现问题呢？</p><p>因为当时存量配置有三条，我提供了 3 个 SQL，其中有一个是算对了的。</p><p>每一条存量配置都对应着大量的利息数据，而算对了的这个对应的数据更多，在比例上超过 60%。</p><p>我进行生产验证的时候，在大量的利息计提数据中随机抽选了两条，选中的这两条，恰好都是正确的 SQL 对应的数据。</p><p>所以我发现符合预期，得出了生产验证通过的结论。</p><p>站在这个节点，回顾整个事件，这个时候应该是最有可能发现问题的时候。</p><p>但是没发现。</p><p>根本原因是验证方案不严谨，玄学原因是运气不站在我这边。</p><h2 id="怎么暴露的？"><a href="#怎么暴露的？" class="headerlink" title="怎么暴露的？"></a><strong>怎么暴露的？</strong></h2><p>你想想，这种业务参数配置错误的问题你能通过什么监控规则监控到吗？</p><p>其实很难的。</p><p>我们一般来说做技术层面的监控，都是监控程序是否按照预期正常运行。比如在计算的过程中出现异常，那我们是可以监控到的。</p><p>但是在这种只是参与计算的值不对，但是能正常计算出一个值的情况，并不会报错。</p><p>这种问题通过技术手段很难监控到。如果硬要去做监控，肯定是能做的，比如从异常浮动的维度、横向数据对比的维度，但是配套的开发成本又上去了。</p><p>我是怎么发现这个问题的呢？</p><p>也是纯粹的运气。</p><p>是一个周五的晚上，我做另外的一个和本问题毫无关系的场景下的数据验证的时候，偶然间看到了一笔数据的金额和前几天比，明显大了很多。</p><p>这是不符合业务规律的。</p><p>然后进一步跟踪，最终定位到了前面的问题 SQL。这个时候距离这个 SQL 上线，已经过去了三天，已经产生了一批错误数据了。</p><p>如果我没有偶然间看到这个问题数据，那么这个问题会在什么环节暴露呢？</p><p>就是在业务使用这个数据做核对的时候。</p><p>那个时候整个问题的性质就变了。不仅是处理时间来不来得及的问题了，而是这个问题是由“开发自主发现”还是由“外部反馈发现”这两个完全不同的性质了。</p><p>一般来说，不管是什么问题，先抛开严重程度，只要是开发自主发现的，都能一定程度上让事情变得不那么难堪。</p><p>所以我们才一度强调“可监控”的重要性。</p><p>随后，我联系了业务，反馈了这个情况。他表示在他下次使用这批数据之前，把数据修复好就行。大概一个月后，他会用到这批数据。</p><p>这样，我有接近一个月的时间来处理这个问题，防止问题扩大化。</p><p>时间非常充足，站在这个角度，我运气还不错的。</p><p>问题已经暴露出来了，随后就是制定针对这批错误数据的修复方案了。</p><p>修复方案就和业务场景相关了，属于多个业务场景叠加在一起，所以修复方案其实是比较复杂的，涉及到“修数”和“补数”，没有展开描述的必要了。</p><p>只是想简单提一句，这个修复方案是我利用周末的时间想出来的，很多细节问题我都需要考虑到，甚至在心里写了一遍伪代码。</p><p>确实是浪费了周末的时间，但是这是为自己的错误买单，半点不怨别人，就是活该。</p><p>而对于参与后续方案讨论的同事来说，在这件事情上付出的时间，才是属于无妄之灾。</p><p>这就是整个事情的过程，一个小数点引发的血案。</p><h2 id="再回首"><a href="#再回首" class="headerlink" title="再回首"></a><strong>再回首</strong></h2><p>现在整个事情的全貌都在你眼前了，你得到了什么经验教训？</p><p>因为手抖了，写错了一位小数，这确实是直接原因，所以是想着下次再处理这种数据的时候，更加小心一点吗？</p><p>我觉得不是这样的。</p><p>我得到的经验教训就是我的标题：开发人员，千万不要去碰那该死的业务参数！</p><p>如果在最开始需求评审会，我们讨论到存量数据的时候。</p><p>业务说：这次需求上线的时候，你按照 11 位小数重新算好，然后写 SQL 更新一下就行。</p><p>我说：不行，这个属于是业务参数，我不能去动。上线完成后，就具备这个功能了，你可以通过页面配置去修改。</p><p>我知道他们修改业务参数的流程，很长很复杂。</p><p>首先业务需要发起一个参数变更的 OA 流程，然后走到他的部门负责人审批。</p><p>业务部门负责人审批完成后，会到具体负责业务参数配置的人员手里，还需要该人员对应的部门负责人审核。</p><p>审核完成后有权限的人员才会去修改这个业务参数，而这个参数的修改，在对应的系统功能上还有两级甚至三级审核。</p><p>整个完成之后发起 OA 的人员还需要进行变更确认，看看页面上是否是自己想要的配置。</p><p>这一套流程走下来，你觉得还会出错吗？</p><p>很难出错了。</p><p>你可以批判这个流程过于臃肿，但是你最终总是会认识到，这个流程其实是在保护打工人。</p><p>我知道他流程比较复杂，而我写个 SQL 几乎是没有成本的，但是这是在 SQL 正确的前提下。</p><p>如果当时不答应通过 SQL 的方式帮他处理存量数据，他其实有更加正规的流程去处理这些数据，而且不会出错。</p><p>事后我们复盘的时候，也有同事私下向我提出了这个的问题：为什么不走 OA 流程去调整这个参数？</p><p>另外，关于流程，我给你举一个程序员方面的例子。</p><p>一个核心开发人员拥有线上数据库的操作权限，我们先假设这个人绝对忠诚、绝对可以信赖、绝对恪尽职守、绝对不会删库跑路。</p><p>某一天，他收到一个预警信息，经过排查发现需要去修改数据库里面某个数据的状态，他直接就去修改了。</p><p>这个操作非常常见，特别是在小公司或者在一些在快速发展阶段的公司。</p><p>后来这个公司成长起来了，开始更加注重操作风险了，回收了所有人员的数据库权限，以前的事儿既往不咎，以后想要修改数据库数据，必须要发起一个审批流程，经过层层审批之后才能执行。</p><p>这个流程和“直接去修改”这个动作比起来，就重了无数倍了。</p><p>站在程序员的角度，前几年都是可以直接操作生产数据，突然这个制度出来了，极大的影响了之前的开发惯性。所以刚刚开始执行的时候，你可能会骂一句：xxx。</p><p>但是长远来看，这个流程其实是在保护你。</p><p>当你有数据库权限的时候，操作对了，没有人会夸你。操作错了，你就是罪魁祸首。</p><p>有了一个审批流程，在加重了操作成本的同时，也降低了错误成本。</p><p>处理问题的时长可能增加了，对于问题处理的敏捷度可能降低了，但是站在公司的角度，随着公司的发展“稳定”才是永恒的主旋律，在稳定面前，敏捷度反而是可以牺牲的。</p><p>歪师傅在第一家公司业务野蛮发展的时代，曾经就有这样的权限，那个时候刚刚参加工作两年多的时间，觉得事情就应该是这样的，这样才是正确的，可以足够敏捷，足够迅速的处理问题。</p><p>后来权限回收了，当时我也在私底下骂骂咧咧了几句。</p><p>再回来，随着经验和在职场上见过得事儿越来越多，才渐渐认识到：蛮荒时代确实出英雄，但是我没有把握好机会成为英雄。蛮荒时代之后的流程规范，规章制度其实是在保护那批没有成为英雄的人，其中就有我。</p><p>最后，给你，也给我自己一个忠告：开发人员，你最好要知道你数据库里面每一个业务参数背后的业务含义，但是千万不要去碰那该死的业务参数。也轮不到你碰，该碰的人会在正确的流程下去碰。</p><p>无论什么时候，心中都要绷着这根弦。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;[南月晨的blog](&lt;a href=&quot;https://leiyu-code.github.io/&quot;&gt;南月晨的博客 (leiyu-code.github.io)&lt;/a&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;leiyu-code.github.io&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.linuxcool.com/&quot;&gt;Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前几天发了一个牢骚：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://why-image-1300252878.cos.ap-chengdu.myqcloud.com/img/20220716/20241111201609.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;本来只是单纯的吐槽一下，但是好多人对其中的细节比较感兴趣。&lt;/p&gt;
&lt;p&gt;大家都是搞技术的嘛，对于“踩 BUG”这种喜闻乐见的事情，有兴趣是很正常的。&lt;/p&gt;
&lt;p&gt;其实我这个 BUG，其实严格意义上不能叫做 BUG，因为和程序无关，甚至和技术的关系都不算大。从标题上你也能猜出来，是和一个业务参数相关。&lt;/p&gt;
&lt;p&gt;但是在这个过程中，因为我是整个事件全程的亲历者，所以现在回看这个事情，我还是有一些思考在里面的。&lt;/p&gt;
&lt;p&gt;我觉得这是一个程序员会遇到的“典型事件”。&lt;/p&gt;</summary>
    
    
    
    <category term="workNote" scheme="http://example.com/categories/workNote/"/>
    
    
    <category term="database" scheme="http://example.com/tags/database/"/>
    
    <category term="sqlserver" scheme="http://example.com/tags/sqlserver/"/>
    
  </entry>
  
  <entry>
    <title>优化SQL server</title>
    <link href="http://example.com/2024/11/12/%E4%BC%98%E5%8C%96SQLserver/"/>
    <id>http://example.com/2024/11/12/%E4%BC%98%E5%8C%96SQLserver/</id>
    <published>2024-11-12T06:56:06.000Z</published>
    <updated>2024-11-12T06:57:50.170Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p><p>leiyu-code.github.io</p><p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p>在 SQL Server 中，当数据量增大时，数据库的性能可能会受到影响，导致查询速度变慢、响应时间变长等问题。为了应对大量数据，以下是一些常用的优化策略和案例详解。</p><h2 id="1-索引优化"><a href="#1-索引优化" class="headerlink" title="1. 索引优化"></a>1. 索引优化</h2><ul><li><strong>创建索引</strong>：索引可以显著提高查询速度，特别是在使用 <code>WHERE</code>、<code>JOIN</code> 和 <code>ORDER BY</code> 子句时。为常用的查询字段（尤其是筛选条件字段）创建合适的索引。</li><li><strong>选择合适的索引类型</strong>：使用聚集索引（Clustered Index）和非聚集索引（Non-clustered Index）来优化查询性能。聚集索引适用于排序、范围查询等，而非聚集索引适用于单一列或组合列的查询。</li><li><strong>避免过多索引</strong>：虽然索引能提高查询性能，但过多的索引会增加更新、插入和删除操作的成本，因此要平衡索引的数量和性能。</li></ul><p>在 SQL Server 中，索引优化是提高查询性能的重要手段。以下是一个具体的业务场景，假设我们有一个销售订单系统，订单表 <code>Orders</code> 需要根据不同的查询需求来进行索引优化。</p><h3 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h3><ul><li>查询需求1：按 <code>CustomerID</code> 和 <code>OrderDate</code> 查询订单信息。</li><li>查询需求2：按 <code>ProductID</code> 查询所有相关的订单。</li><li>查询需求3：查询某一订单的详细信息（通过 <code>OrderID</code>）。</li></ul><p>基于这些需求，我们将为 <code>Orders</code> 表创建索引，并展示如何选择合适的索引类型。</p><h3 id="1-创建表-Orders"><a href="#1-创建表-Orders" class="headerlink" title="1. 创建表 Orders"></a>1. 创建表 <code>Orders</code></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Orders (</span><br><span class="line">    OrderID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,         <span class="comment">-- 主键索引，自动创建聚集索引</span></span><br><span class="line">    CustomerID <span class="type">INT</span>,                  <span class="comment">-- 客户ID</span></span><br><span class="line">    OrderDate DATETIME,              <span class="comment">-- 订单日期</span></span><br><span class="line">    ProductID <span class="type">INT</span>,                   <span class="comment">-- 产品ID</span></span><br><span class="line">    TotalAmount <span class="type">DECIMAL</span>(<span class="number">18</span>, <span class="number">2</span>),      <span class="comment">-- 订单总金额</span></span><br><span class="line">    Status <span class="type">VARCHAR</span>(<span class="number">20</span>)               <span class="comment">-- 订单状态</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="2-创建索引"><a href="#2-创建索引" class="headerlink" title="2. 创建索引"></a>2. 创建索引</h3><h4 id="2-1-创建聚集索引（Clustered-Index）"><a href="#2-1-创建聚集索引（Clustered-Index）" class="headerlink" title="2.1. 创建聚集索引（Clustered Index）"></a>2.1. 创建聚集索引（Clustered Index）</h4><p>聚集索引通常是基于主键或唯一约束创建的。它将数据按照索引顺序存储，因此在 <code>OrderID</code> 上创建聚集索引能够加速按 <code>OrderID</code> 查找的查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- OrderID 是主键，默认会创建聚集索引</span></span><br><span class="line"><span class="comment">-- 所以在这种情况下不需要额外创建聚集索引</span></span><br></pre></td></tr></table></figure><h4 id="2-2-创建非聚集索引（Non-clustered-Index）"><a href="#2-2-创建非聚集索引（Non-clustered-Index）" class="headerlink" title="2.2. 创建非聚集索引（Non-clustered Index）"></a>2.2. 创建非聚集索引（Non-clustered Index）</h4><p>对于 <code>CustomerID</code> 和 <code>OrderDate</code> 组合字段的查询需求，我们可以为其创建一个复合非聚集索引。这样可以加速基于 <code>CustomerID</code> 和 <code>OrderDate</code> 的查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> NONCLUSTERED INDEX idx_Customer_OrderDate</span><br><span class="line"><span class="keyword">ON</span> Orders (CustomerID, OrderDate);</span><br></pre></td></tr></table></figure><ul><li><strong>使用场景</strong>：该索引有助于加速按 <code>CustomerID</code> 和 <code>OrderDate</code> 查询的性能，特别是当订单数据量较大时。</li></ul><h4 id="2-3-创建单列非聚集索引"><a href="#2-3-创建单列非聚集索引" class="headerlink" title="2.3. 创建单列非聚集索引"></a>2.3. 创建单列非聚集索引</h4><p>对于查询需求2，如果我们需要按 <code>ProductID</code> 查找所有相关订单，我们可以为 <code>ProductID</code> 创建单列非聚集索引。这样可以提高查询效率。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> NONCLUSTERED INDEX idx_ProductID</span><br><span class="line"><span class="keyword">ON</span> Orders (ProductID);</span><br></pre></td></tr></table></figure><ul><li><strong>使用场景</strong>：查询某个产品相关的所有订单时，通过该索引可以显著提高查询性能。</li></ul><h3 id="3-删除冗余索引"><a href="#3-删除冗余索引" class="headerlink" title="3. 删除冗余索引"></a>3. 删除冗余索引</h3><p>如果发现某个查询经常访问多个列，而我们在这些列上创建了多个单列索引，可能会导致性能下降。比如，创建多个针对单列的非聚集索引，可能会降低插入和更新操作的效率。为了避免这种情况，可以定期检查并删除冗余的索引。</p><p>假设我们发现 <code>ProductID</code> 和 <code>CustomerID</code> 常常一起出现在查询条件中，我们可以考虑删除 <code>idx_ProductID</code> 索引，改为创建一个组合索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除冗余的单列索引</span></span><br><span class="line"><span class="keyword">DROP</span> INDEX idx_ProductID <span class="keyword">ON</span> Orders;</span><br></pre></td></tr></table></figure><h3 id="4-查询优化"><a href="#4-查询优化" class="headerlink" title="4. 查询优化"></a>4. 查询优化</h3><p>现在，假设我们有以下几个查询，我们将展示如何利用创建的索引来优化查询性能。</p><h4 id="4-1-按-CustomerID-和-OrderDate-查询"><a href="#4-1-按-CustomerID-和-OrderDate-查询" class="headerlink" title="4.1. 按 CustomerID 和 OrderDate 查询"></a>4.1. 按 <code>CustomerID</code> 和 <code>OrderDate</code> 查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用 idx_Customer_OrderDate 索引</span></span><br><span class="line"><span class="keyword">SELECT</span> OrderID, ProductID, TotalAmount</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> CustomerID <span class="operator">=</span> <span class="number">1001</span> <span class="keyword">AND</span> OrderDate <span class="keyword">BETWEEN</span> <span class="string">&#x27;2024-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2024-12-31&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="4-2-按-ProductID-查询"><a href="#4-2-按-ProductID-查询" class="headerlink" title="4.2. 按 ProductID 查询"></a>4.2. 按 <code>ProductID</code> 查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用 idx_ProductID 索引</span></span><br><span class="line"><span class="keyword">SELECT</span> OrderID, CustomerID, TotalAmount</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> ProductID <span class="operator">=</span> <span class="number">500</span>;</span><br></pre></td></tr></table></figure><h4 id="4-3-查询特定订单详细信息"><a href="#4-3-查询特定订单详细信息" class="headerlink" title="4.3. 查询特定订单详细信息"></a>4.3. 查询特定订单详细信息</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 按 OrderID 查询，使用默认的聚集索引</span></span><br><span class="line"><span class="keyword">SELECT</span> CustomerID, ProductID, TotalAmount, Status</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> OrderID <span class="operator">=</span> <span class="number">123456</span>;</span><br></pre></td></tr></table></figure><h3 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5. 注意事项"></a>5. 注意事项</h3><ul><li><strong>索引的维护成本</strong>：虽然索引能显著提高查询性能，但每当进行 <code>INSERT</code>、<code>UPDATE</code> 或 <code>DELETE</code> 操作时，索引也需要维护。这会增加操作的成本。因此，索引不宜过多，需要根据查询需求进行优化。</li><li><strong>索引覆盖</strong>：尽量创建覆盖索引，即索引包含查询所需的所有列，这样可以避免查询时回表操作，提高查询效率。</li></ul><h3 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h3><p>通过为 <code>Orders</code> 表创建合适的索引，我们可以显著优化查询性能。在索引优化中，需要综合考虑查询需求、索引类型（聚集索引、非聚集索引）、索引的数量及其维护成本。</p><h2 id="2-查询优化"><a href="#2-查询优化" class="headerlink" title="2. 查询优化"></a>2. 查询优化</h2><ul><li><strong>优化 SQL 查询</strong>：确保 SQL 查询尽量高效。避免在查询中使用 <code>SELECT *</code>，而是只选择需要的列；避免重复的计算，尽量减少子查询。</li><li><strong>使用执行计划</strong>：利用 SQL Server Management Studio (SSMS) 的执行计划工具查看查询的执行计划，分析和优化查询中的瓶颈部分。</li><li><strong>避免复杂的嵌套查询</strong>：复杂的子查询可能会导致性能问题，考虑使用连接（<code>JOIN</code>）来代替。</li></ul><p>查询优化是通过精心设计 SQL 查询语句和优化索引来提高查询性能的过程。根据你提供的业务场景，我们将基于一个订单系统的 <code>Orders</code> 表，展示几种常见的查询优化方法。</p><h3 id="业务场景-1"><a href="#业务场景-1" class="headerlink" title="业务场景"></a>业务场景</h3><p>假设我们有一个销售订单系统，<code>Orders</code> 表包括以下字段：</p><ul><li><code>OrderID</code>：订单ID，主键。</li><li><code>CustomerID</code>：客户ID。</li><li><code>OrderDate</code>：订单日期。</li><li><code>ProductID</code>：产品ID。</li><li><code>TotalAmount</code>：订单总金额。</li><li><code>Status</code>：订单状态（如已支付、未支付等）。</li></ul><p>我们有以下几种查询需求：</p><ol><li>查询某个客户在某段时间内的所有订单。</li><li>查询某个产品在所有订单中的销售情况。</li><li>查询某个订单的详细信息。</li><li>查询多个客户的订单信息。</li></ol><h3 id="1-查询优化：按-CustomerID-和-OrderDate-查询订单"><a href="#1-查询优化：按-CustomerID-和-OrderDate-查询订单" class="headerlink" title="1. 查询优化：按 CustomerID 和 OrderDate 查询订单"></a>1. <strong>查询优化：按 <code>CustomerID</code> 和 <code>OrderDate</code> 查询订单</strong></h3><h4 id="查询需求："><a href="#查询需求：" class="headerlink" title="查询需求："></a>查询需求：</h4><p>查询某个客户在某段时间内的所有订单。</p><h4 id="查询语句："><a href="#查询语句：" class="headerlink" title="查询语句："></a>查询语句：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> OrderID, ProductID, TotalAmount, Status</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> CustomerID <span class="operator">=</span> <span class="number">1001</span></span><br><span class="line">  <span class="keyword">AND</span> OrderDate <span class="keyword">BETWEEN</span> <span class="string">&#x27;2024-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2024-12-31&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="优化建议："><a href="#优化建议：" class="headerlink" title="优化建议："></a>优化建议：</h4><ul><li><strong>索引优化</strong>：为 <code>CustomerID</code> 和 <code>OrderDate</code> 创建复合索引，因为这是常见的查询模式。复合索引可以加速基于这两个字段的查询。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> NONCLUSTERED INDEX idx_Customer_OrderDate</span><br><span class="line"><span class="keyword">ON</span> Orders (CustomerID, OrderDate);</span><br></pre></td></tr></table></figure><h4 id="执行计划优化："><a href="#执行计划优化：" class="headerlink" title="执行计划优化："></a>执行计划优化：</h4><ul><li>使用 <code>EXPLAIN</code> 或 <code>SET STATISTICS IO ON</code> 来查看执行计划，确认查询是否使用了索引。</li></ul><h3 id="2-查询优化：按-ProductID-查询所有相关订单"><a href="#2-查询优化：按-ProductID-查询所有相关订单" class="headerlink" title="2. 查询优化：按 ProductID 查询所有相关订单"></a>2. <strong>查询优化：按 <code>ProductID</code> 查询所有相关订单</strong></h3><h4 id="查询需求：-1"><a href="#查询需求：-1" class="headerlink" title="查询需求："></a>查询需求：</h4><p>查询某个产品的所有订单。</p><h4 id="查询语句：-1"><a href="#查询语句：-1" class="headerlink" title="查询语句："></a>查询语句：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> OrderID, CustomerID, TotalAmount, Status</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> ProductID <span class="operator">=</span> <span class="number">500</span>;</span><br></pre></td></tr></table></figure><h4 id="优化建议：-1"><a href="#优化建议：-1" class="headerlink" title="优化建议："></a>优化建议：</h4><ul><li><strong>索引优化</strong>：为 <code>ProductID</code> 创建索引，因为这个字段经常作为查询条件。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> NONCLUSTERED INDEX idx_ProductID</span><br><span class="line"><span class="keyword">ON</span> Orders (ProductID);</span><br></pre></td></tr></table></figure><h4 id="执行计划优化：-1"><a href="#执行计划优化：-1" class="headerlink" title="执行计划优化："></a>执行计划优化：</h4><ul><li>确保查询能够利用 <code>idx_ProductID</code> 索引，避免全表扫描。</li></ul><h3 id="3-查询优化：查询某个订单的详细信息"><a href="#3-查询优化：查询某个订单的详细信息" class="headerlink" title="3. 查询优化：查询某个订单的详细信息"></a>3. <strong>查询优化：查询某个订单的详细信息</strong></h3><h4 id="查询需求：-2"><a href="#查询需求：-2" class="headerlink" title="查询需求："></a>查询需求：</h4><p>查询某个订单的详细信息。</p><h4 id="查询语句：-2"><a href="#查询语句：-2" class="headerlink" title="查询语句："></a>查询语句：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CustomerID, ProductID, TotalAmount, Status</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> OrderID <span class="operator">=</span> <span class="number">123456</span>;</span><br></pre></td></tr></table></figure><h4 id="优化建议：-2"><a href="#优化建议：-2" class="headerlink" title="优化建议："></a>优化建议：</h4><ul><li><strong>索引优化</strong>：因为 <code>OrderID</code> 是主键字段，SQL Server 会自动创建聚集索引。查询 <code>OrderID</code> 字段时，查询会直接利用聚集索引。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 聚集索引已自动创建，无需额外创建</span></span><br></pre></td></tr></table></figure><h4 id="执行计划优化：-2"><a href="#执行计划优化：-2" class="headerlink" title="执行计划优化："></a>执行计划优化：</h4><ul><li>确保查询只扫描一行数据，利用 <code>OrderID</code> 主键索引。</li></ul><h3 id="4-查询优化：查询多个客户的订单信息"><a href="#4-查询优化：查询多个客户的订单信息" class="headerlink" title="4. 查询优化：查询多个客户的订单信息"></a>4. <strong>查询优化：查询多个客户的订单信息</strong></h3><h4 id="查询需求：-3"><a href="#查询需求：-3" class="headerlink" title="查询需求："></a>查询需求：</h4><p>查询多个客户的订单信息。</p><h4 id="查询语句：-3"><a href="#查询语句：-3" class="headerlink" title="查询语句："></a>查询语句：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> OrderID, CustomerID, ProductID, TotalAmount, Status</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> CustomerID <span class="keyword">IN</span> (<span class="number">1001</span>, <span class="number">1002</span>, <span class="number">1003</span>);</span><br></pre></td></tr></table></figure><h4 id="优化建议：-3"><a href="#优化建议：-3" class="headerlink" title="优化建议："></a>优化建议：</h4><ul><li><strong>索引优化</strong>：为 <code>CustomerID</code> 创建索引，以便快速过滤出目标客户的订单。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> NONCLUSTERED INDEX idx_CustomerID</span><br><span class="line"><span class="keyword">ON</span> Orders (CustomerID);</span><br></pre></td></tr></table></figure><h4 id="执行计划优化：-3"><a href="#执行计划优化：-3" class="headerlink" title="执行计划优化："></a>执行计划优化：</h4><ul><li>确保 <code>IN</code> 子句使用了 <code>idx_CustomerID</code> 索引来优化查询。</li></ul><h3 id="5-查询优化：避免使用-SELECT"><a href="#5-查询优化：避免使用-SELECT" class="headerlink" title="5. 查询优化：避免使用 SELECT \*"></a>5. <strong>查询优化：避免使用 <code>SELECT \*</code></strong></h3><h4 id="查询需求：-4"><a href="#查询需求：-4" class="headerlink" title="查询需求："></a>查询需求：</h4><p>查询所有字段（不推荐，通常用来调试或检查表结构）。</p><h4 id="查询语句：-4"><a href="#查询语句：-4" class="headerlink" title="查询语句："></a>查询语句：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Orders;</span><br></pre></td></tr></table></figure><h4 id="优化建议：-4"><a href="#优化建议：-4" class="headerlink" title="优化建议："></a>优化建议：</h4><ul><li><strong>明确选择需要的列</strong>：避免使用 <code>SELECT *</code>，明确列出查询需要的字段，避免读取不必要的列。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> OrderID, CustomerID, TotalAmount <span class="keyword">FROM</span> Orders;</span><br></pre></td></tr></table></figure><h3 id="6-查询优化：使用-JOIN-进行多表查询"><a href="#6-查询优化：使用-JOIN-进行多表查询" class="headerlink" title="6. 查询优化：使用 JOIN 进行多表查询"></a>6. <strong>查询优化：使用 <code>JOIN</code> 进行多表查询</strong></h3><h4 id="查询需求：-5"><a href="#查询需求：-5" class="headerlink" title="查询需求："></a>查询需求：</h4><p>查询某个客户的订单信息以及相关的产品信息。假设有一个 <code>Products</code> 表，包含 <code>ProductID</code> 和 <code>ProductName</code>。</p><h4 id="查询语句：-5"><a href="#查询语句：-5" class="headerlink" title="查询语句："></a>查询语句：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> o.OrderID, o.TotalAmount, p.ProductName</span><br><span class="line"><span class="keyword">FROM</span> Orders o</span><br><span class="line"><span class="keyword">JOIN</span> Products p <span class="keyword">ON</span> o.ProductID <span class="operator">=</span> p.ProductID</span><br><span class="line"><span class="keyword">WHERE</span> o.CustomerID <span class="operator">=</span> <span class="number">1001</span></span><br><span class="line">  <span class="keyword">AND</span> o.OrderDate <span class="keyword">BETWEEN</span> <span class="string">&#x27;2024-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2024-12-31&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="优化建议：-5"><a href="#优化建议：-5" class="headerlink" title="优化建议："></a>优化建议：</h4><ul><li><strong>索引优化</strong>：为 <code>Orders</code> 表的 <code>CustomerID</code>、<code>OrderDate</code> 和 <code>ProductID</code> 创建复合索引，为 <code>Products</code> 表的 <code>ProductID</code> 创建索引，以加速 <code>JOIN</code> 查询。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> NONCLUSTERED INDEX idx_Orders_Customer_OrderDate_Product</span><br><span class="line"><span class="keyword">ON</span> Orders (CustomerID, OrderDate, ProductID);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> NONCLUSTERED INDEX idx_Products_ProductID</span><br><span class="line"><span class="keyword">ON</span> Products (ProductID);</span><br></pre></td></tr></table></figure><h4 id="执行计划优化：-4"><a href="#执行计划优化：-4" class="headerlink" title="执行计划优化："></a>执行计划优化：</h4><ul><li>确保执行计划中使用了 <code>JOIN</code> 的相关索引，避免全表扫描。</li></ul><h3 id="7-查询优化：分页查询"><a href="#7-查询优化：分页查询" class="headerlink" title="7. 查询优化：分页查询"></a>7. <strong>查询优化：分页查询</strong></h3><h4 id="查询需求：-6"><a href="#查询需求：-6" class="headerlink" title="查询需求："></a>查询需求：</h4><p>查询某个时间段内的客户订单，并实现分页功能。</p><h4 id="查询语句：-6"><a href="#查询语句：-6" class="headerlink" title="查询语句："></a>查询语句：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> OrderID, CustomerID, TotalAmount, Status</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> OrderDate <span class="keyword">BETWEEN</span> <span class="string">&#x27;2024-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2024-12-31&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> OrderDate</span><br><span class="line"><span class="keyword">OFFSET</span> <span class="number">0</span> <span class="keyword">ROWS</span> <span class="keyword">FETCH</span> NEXT <span class="number">20</span> <span class="keyword">ROWS</span> <span class="keyword">ONLY</span>;</span><br></pre></td></tr></table></figure><h4 id="优化建议：-6"><a href="#优化建议：-6" class="headerlink" title="优化建议："></a>优化建议：</h4><ul><li><strong>索引优化</strong>：确保在 <code>OrderDate</code> 上有合适的索引，能够加速排序操作。</li><li>使用 <code>OFFSET</code> 和 <code>FETCH</code> 语句实现分页查询，避免一次性加载大量数据。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> NONCLUSTERED INDEX idx_OrderDate</span><br><span class="line"><span class="keyword">ON</span> Orders (OrderDate);</span><br></pre></td></tr></table></figure><h3 id="8-避免过多的子查询"><a href="#8-避免过多的子查询" class="headerlink" title="8. 避免过多的子查询"></a>8. <strong>避免过多的子查询</strong></h3><h4 id="查询需求：-7"><a href="#查询需求：-7" class="headerlink" title="查询需求："></a>查询需求：</h4><p>查询某个客户在某段时间内的订单总金额。</p><h4 id="查询语句：-7"><a href="#查询语句：-7" class="headerlink" title="查询语句："></a>查询语句：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CustomerID, </span><br><span class="line">       (<span class="keyword">SELECT</span> <span class="built_in">SUM</span>(TotalAmount) <span class="keyword">FROM</span> Orders <span class="keyword">WHERE</span> CustomerID <span class="operator">=</span> <span class="number">1001</span> <span class="keyword">AND</span> OrderDate <span class="keyword">BETWEEN</span> <span class="string">&#x27;2024-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2024-12-31&#x27;</span>) <span class="keyword">AS</span> TotalSpent</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> CustomerID <span class="operator">=</span> <span class="number">1001</span>;</span><br></pre></td></tr></table></figure><h4 id="优化建议：-7"><a href="#优化建议：-7" class="headerlink" title="优化建议："></a>优化建议：</h4><ul><li><strong>避免使用子查询</strong>：尽量避免在 <code>SELECT</code> 语句中使用子查询，可以改为 <code>JOIN</code> 或 <code>GROUP BY</code> 来提高效率。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> o.CustomerID, <span class="built_in">SUM</span>(o.TotalAmount) <span class="keyword">AS</span> TotalSpent</span><br><span class="line"><span class="keyword">FROM</span> Orders o</span><br><span class="line"><span class="keyword">WHERE</span> o.CustomerID <span class="operator">=</span> <span class="number">1001</span></span><br><span class="line">  <span class="keyword">AND</span> o.OrderDate <span class="keyword">BETWEEN</span> <span class="string">&#x27;2024-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2024-12-31&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> o.CustomerID;</span><br></pre></td></tr></table></figure><h3 id="小结一下-1"><a href="#小结一下-1" class="headerlink" title="小结一下"></a>小结一下</h3><p>通过优化 SQL 查询语句、合理使用索引以及减少不必要的操作，我们能够显著提高查询性能。具体做法包括：</p><ul><li>创建合适的索引（单列索引和复合索引）。</li><li>优化查询语句，避免使用 <code>SELECT *</code> 和过多的子查询。</li><li>使用合适的分页技术和 <code>JOIN</code> 优化多表查询。</li><li>分析查询执行计划，确保查询高效执行。</li></ul><p>这些优化措施可以帮助 SQL Server 在面对大量数据时保持高效的查询性能。</p><h2 id="3-数据分区和分表"><a href="#3-数据分区和分表" class="headerlink" title="3. 数据分区和分表"></a>3. 数据分区和分表</h2><ul><li><strong>表分区</strong>：对于非常大的表，可以考虑使用表分区。表分区可以根据某些条件（例如时间、ID 范围等）将数据分割到多个物理文件中，这样查询时只访问相关的分区，减少了全表扫描的开销。</li><li><strong>水平拆分（Sharding）</strong>：将数据分散到多个独立的表或数据库中，通常基于某种规则（如区域、日期等）。每个表包含数据的一个子集，可以提高查询效率。</li></ul><p>数据分区（Partitioning）和分表（Sharding）是优化数据库性能的关键手段，尤其在处理大数据量时。通过数据分区或分表，可以有效地减少查询和写入的压力，提高数据访问效率。以下是基于业务场景的具体代码案例，展示如何使用数据分区和分表来优化 SQL Server 的性能。</p><h3 id="业务场景-2"><a href="#业务场景-2" class="headerlink" title="业务场景"></a>业务场景</h3><p>假设我们有一个订单系统，<code>Orders</code> 表记录了所有订单信息。随着订单量的增加，单表的查询和维护变得越来越困难。因此，我们需要使用分区和分表技术来优化数据库的性能。</p><h3 id="1-数据分区（Partitioning）"><a href="#1-数据分区（Partitioning）" class="headerlink" title="1. 数据分区（Partitioning）"></a>1. <strong>数据分区（Partitioning）</strong></h3><p>数据分区是在单一表上进行逻辑分区，它允许将一个大的表按某个规则（如时间范围、数值区间等）分成多个物理段（分区）。每个分区可以独立管理，查询可以在特定的分区内进行，从而提高查询性能。</p><h4 id="业务需求"><a href="#业务需求" class="headerlink" title="业务需求"></a>业务需求</h4><ul><li>按照订单日期（<code>OrderDate</code>）将 <code>Orders</code> 表分区，以便在查询时快速定位到特定时间段内的订单。</li></ul><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><ol><li>创建分区函数（Partition Function）和分区方案（Partition Scheme）。</li><li>在 <code>Orders</code> 表上应用分区。</li></ol><h4 id="创建分区函数（Partition-Function）"><a href="#创建分区函数（Partition-Function）" class="headerlink" title="创建分区函数（Partition Function）"></a>创建分区函数（Partition Function）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建分区函数：按年度分区</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PARTITION</span> <span class="keyword">FUNCTION</span> OrderDatePartitionFunc (<span class="type">DATE</span>)</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">RANGE</span> <span class="keyword">RIGHT</span> <span class="keyword">FOR</span> <span class="keyword">VALUES</span> (<span class="string">&#x27;2023-01-01&#x27;</span>, <span class="string">&#x27;2024-01-01&#x27;</span>, <span class="string">&#x27;2025-01-01&#x27;</span>);</span><br></pre></td></tr></table></figure><p>该分区函数将根据订单日期（<code>OrderDate</code>）把数据分为多个区间，每个区间的范围是按年划分的。</p><h4 id="创建分区方案（Partition-Scheme）"><a href="#创建分区方案（Partition-Scheme）" class="headerlink" title="创建分区方案（Partition Scheme）"></a>创建分区方案（Partition Scheme）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建分区方案：将分区函数应用到物理文件组</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PARTITION</span> SCHEME OrderDatePartitionScheme</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">PARTITION</span> OrderDatePartitionFunc</span><br><span class="line"><span class="keyword">TO</span> ([<span class="keyword">PRIMARY</span>], [FG_2023], [FG_2024], [FG_2025]);</span><br></pre></td></tr></table></figure><p>此方案为每个分区指定一个物理文件组（如 <code>PRIMARY</code>、<code>FG_2023</code> 等）。</p><h4 id="创建分区表"><a href="#创建分区表" class="headerlink" title="创建分区表"></a>创建分区表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建分区表：应用分区方案</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Orders</span><br><span class="line">(</span><br><span class="line">    OrderID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    CustomerID <span class="type">INT</span>,</span><br><span class="line">    OrderDate <span class="type">DATE</span>,</span><br><span class="line">    ProductID <span class="type">INT</span>,</span><br><span class="line">    TotalAmount <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    Status <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">ON</span> OrderDatePartitionScheme (OrderDate);</span><br></pre></td></tr></table></figure><p><code>Orders</code> 表按 <code>OrderDate</code> 字段进行分区，数据会根据日期分布到不同的物理文件组中。</p><h4 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询 2024 年的订单，查询仅会访问相应的分区，提高查询效率</span></span><br><span class="line"><span class="keyword">SELECT</span> OrderID, CustomerID, ProductID, TotalAmount</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> OrderDate <span class="keyword">BETWEEN</span> <span class="string">&#x27;2024-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2024-12-31&#x27;</span>;</span><br></pre></td></tr></table></figure><p>通过分区，查询只会扫描相关分区的数据，从而提高查询速度。</p><h3 id="2-数据分表（Sharding）"><a href="#2-数据分表（Sharding）" class="headerlink" title="2. 数据分表（Sharding）"></a>2. <strong>数据分表（Sharding）</strong></h3><p>分表是将数据水平拆分到多个物理表中，每个表存储一部分数据。常见的分表策略包括按范围分表、按哈希值分表等。分表可以显著提升查询性能，但需要管理多个表及其关系。</p><h4 id="业务需求-1"><a href="#业务需求-1" class="headerlink" title="业务需求"></a>业务需求</h4><ul><li>按 <code>CustomerID</code> 将 <code>Orders</code> 表进行分表，客户ID为基础将数据分配到不同的表中。</li><li>客户ID的范围是均匀的，因此我们可以使用哈希分表策略。</li></ul><h4 id="步骤：-1"><a href="#步骤：-1" class="headerlink" title="步骤："></a>步骤：</h4><ol><li>创建多个分表。</li><li>在应用层处理分表逻辑。</li></ol><h4 id="创建分表"><a href="#创建分表" class="headerlink" title="创建分表"></a>创建分表</h4><p>假设我们决定将 <code>Orders</code> 表按 <code>CustomerID</code> 的哈希值分成 4 个表。可以通过以下方式创建 4 个分表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建 Orders_1 分表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Orders_1</span><br><span class="line">(</span><br><span class="line">    OrderID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    CustomerID <span class="type">INT</span>,</span><br><span class="line">    OrderDate <span class="type">DATE</span>,</span><br><span class="line">    ProductID <span class="type">INT</span>,</span><br><span class="line">    TotalAmount <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    Status <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建 Orders_2 分表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Orders_2</span><br><span class="line">(</span><br><span class="line">    OrderID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    CustomerID <span class="type">INT</span>,</span><br><span class="line">    OrderDate <span class="type">DATE</span>,</span><br><span class="line">    ProductID <span class="type">INT</span>,</span><br><span class="line">    TotalAmount <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    Status <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建 Orders_3 分表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Orders_3</span><br><span class="line">(</span><br><span class="line">    OrderID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    CustomerID <span class="type">INT</span>,</span><br><span class="line">    OrderDate <span class="type">DATE</span>,</span><br><span class="line">    ProductID <span class="type">INT</span>,</span><br><span class="line">    TotalAmount <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    Status <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建 Orders_4 分表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Orders_4</span><br><span class="line">(</span><br><span class="line">    OrderID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    CustomerID <span class="type">INT</span>,</span><br><span class="line">    OrderDate <span class="type">DATE</span>,</span><br><span class="line">    ProductID <span class="type">INT</span>,</span><br><span class="line">    TotalAmount <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    Status <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="分表逻辑"><a href="#分表逻辑" class="headerlink" title="分表逻辑"></a>分表逻辑</h4><p>在应用层，我们需要实现一个分表路由逻辑，通过哈希值来确定应该向哪个表插入数据或查询数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 示例：根据 CustomerID 哈希值选择分表</span></span><br><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@CustomerID</span> <span class="type">INT</span> <span class="operator">=</span> <span class="number">1001</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@TableSuffix</span> <span class="type">INT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用哈希算法来决定表</span></span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@TableSuffix</span> <span class="operator">=</span> <span class="variable">@CustomerID</span> <span class="operator">%</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line">IF <span class="variable">@TableSuffix</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> Orders_1 (OrderID, CustomerID, OrderDate, ProductID, TotalAmount, Status)</span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="number">123456</span>, <span class="number">1001</span>, <span class="string">&#x27;2024-01-01&#x27;</span>, <span class="number">101</span>, <span class="number">150.00</span>, <span class="string">&#x27;Paid&#x27;</span>);</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">ELSE</span> IF <span class="variable">@TableSuffix</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> Orders_2 (OrderID, CustomerID, OrderDate, ProductID, TotalAmount, Status)</span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="number">123457</span>, <span class="number">1002</span>, <span class="string">&#x27;2024-01-02&#x27;</span>, <span class="number">102</span>, <span class="number">250.00</span>, <span class="string">&#x27;Pending&#x27;</span>);</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">ELSE</span> IF <span class="variable">@TableSuffix</span> <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> Orders_3 (OrderID, CustomerID, OrderDate, ProductID, TotalAmount, Status)</span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="number">123458</span>, <span class="number">1003</span>, <span class="string">&#x27;2024-01-03&#x27;</span>, <span class="number">103</span>, <span class="number">350.00</span>, <span class="string">&#x27;Shipped&#x27;</span>);</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> Orders_4 (OrderID, CustomerID, OrderDate, ProductID, TotalAmount, Status)</span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="number">123459</span>, <span class="number">1004</span>, <span class="string">&#x27;2024-01-04&#x27;</span>, <span class="number">104</span>, <span class="number">450.00</span>, <span class="string">&#x27;Delivered&#x27;</span>);</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><h4 id="查询逻辑"><a href="#查询逻辑" class="headerlink" title="查询逻辑"></a>查询逻辑</h4><p>为了查询某个客户的订单，我们也需要在应用层决定查询哪个分表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询某个客户的订单</span></span><br><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@CustomerID</span> <span class="type">INT</span> <span class="operator">=</span> <span class="number">1001</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@TableSuffix</span> <span class="type">INT</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@TableSuffix</span> <span class="operator">=</span> <span class="variable">@CustomerID</span> <span class="operator">%</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询数据</span></span><br><span class="line">IF <span class="variable">@TableSuffix</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Orders_1 <span class="keyword">WHERE</span> CustomerID <span class="operator">=</span> <span class="variable">@CustomerID</span>;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">ELSE</span> IF <span class="variable">@TableSuffix</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Orders_2 <span class="keyword">WHERE</span> CustomerID <span class="operator">=</span> <span class="variable">@CustomerID</span>;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">ELSE</span> IF <span class="variable">@TableSuffix</span> <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Orders_3 <span class="keyword">WHERE</span> CustomerID <span class="operator">=</span> <span class="variable">@CustomerID</span>;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Orders_4 <span class="keyword">WHERE</span> CustomerID <span class="operator">=</span> <span class="variable">@CustomerID</span>;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><h3 id="3-分区和分表的选择"><a href="#3-分区和分表的选择" class="headerlink" title="3. 分区和分表的选择"></a>3. <strong>分区和分表的选择</strong></h3><ul><li><strong>分区</strong>：适用于对一个表进行物理划分，但仍然保持数据的逻辑统一性。例如，按时间（如订单日期）分区可以有效提高时间范围查询的性能。</li><li><strong>分表</strong>：适用于数据量特别大的情况，将数据拆分到多个表中，以减少单个表的查询压力。通常采用哈希分表或者范围分表。</li></ul><h3 id="小结一下-2"><a href="#小结一下-2" class="headerlink" title="小结一下"></a>小结一下</h3><ul><li><strong>分区</strong>可以让你在一个大的表上进行逻辑划分，在查询时只访问相关的分区，提高性能。</li><li><strong>分表</strong>则是将数据水平拆分到多个物理表，通常用于处理极大数据量的场景。</li><li>在 SQL Server 中实现分区和分表需要对表的设计、索引设计和查询策略进行综合考虑，以确保数据访问效率和维护的便利性。</li></ul><h2 id="4-数据归档"><a href="#4-数据归档" class="headerlink" title="4. 数据归档"></a>4. 数据归档</h2><ul><li><strong>归档旧数据</strong>：对于已经不常查询的数据，可以将其归档到独立的历史表或数据库中，从而减轻主数据库的负担。只保留近期数据在主表中，优化查询性能。</li><li><strong>压缩旧数据</strong>：可以通过压缩技术来存储归档数据，节省存储空间。</li></ul><p>数据归档是指将不再频繁访问的历史数据从主数据库中移除，并将其存储在归档系统或表中，从而提高主数据库的性能。数据归档通常用于老旧数据、历史记录等不再活跃但需要保留的数据。</p><h3 id="业务场景-3"><a href="#业务场景-3" class="headerlink" title="业务场景"></a>业务场景</h3><p>假设我们有一个订单系统，<code>Orders</code> 表记录了所有订单信息。随着时间的推移，订单数据量急剧增加，但在实际业务中，超过一定时间的订单数据查询频率下降。为了提高数据库性能，我们决定将超过 1 年的订单数据从主表中移除并存档到归档表中。</p><h3 id="步骤：-2"><a href="#步骤：-2" class="headerlink" title="步骤："></a>步骤：</h3><ol><li>创建主表（<code>Orders</code>）和归档表（<code>ArchivedOrders</code>）。</li><li>定期将超过 1 年的订单数据从 <code>Orders</code> 表移到 <code>ArchivedOrders</code> 表。</li><li>确保归档数据的查询不会影响到主表的性能。</li></ol><h3 id="1-创建主表和归档表"><a href="#1-创建主表和归档表" class="headerlink" title="1. 创建主表和归档表"></a>1. 创建主表和归档表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建主订单表 Orders</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Orders</span><br><span class="line">(</span><br><span class="line">    OrderID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    CustomerID <span class="type">INT</span>,</span><br><span class="line">    OrderDate <span class="type">DATE</span>,</span><br><span class="line">    ProductID <span class="type">INT</span>,</span><br><span class="line">    TotalAmount <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    Status <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建归档表 ArchivedOrders</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ArchivedOrders</span><br><span class="line">(</span><br><span class="line">    OrderID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    CustomerID <span class="type">INT</span>,</span><br><span class="line">    OrderDate <span class="type">DATE</span>,</span><br><span class="line">    ProductID <span class="type">INT</span>,</span><br><span class="line">    TotalAmount <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    Status <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="2-归档操作（将超过-1-年的订单移至归档表）"><a href="#2-归档操作（将超过-1-年的订单移至归档表）" class="headerlink" title="2. 归档操作（将超过 1 年的订单移至归档表）"></a>2. 归档操作（将超过 1 年的订单移至归档表）</h3><p>为了定期将过期的订单移至归档表，可以使用定时任务（如 SQL Server Agent 作业）来执行这个操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 将超过 1 年的订单数据从 Orders 表移到 ArchivedOrders 表</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> ArchivedOrders (OrderID, CustomerID, OrderDate, ProductID, TotalAmount, Status)</span><br><span class="line"><span class="keyword">SELECT</span> OrderID, CustomerID, OrderDate, ProductID, TotalAmount, Status</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> OrderDate <span class="operator">&lt;</span> DATEADD(<span class="keyword">YEAR</span>, <span class="number">-1</span>, GETDATE());</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除 Orders 表中超过 1 年的订单数据</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> OrderDate <span class="operator">&lt;</span> DATEADD(<span class="keyword">YEAR</span>, <span class="number">-1</span>, GETDATE());</span><br></pre></td></tr></table></figure><p>这段代码会将 <code>Orders</code> 表中 <code>OrderDate</code> 小于当前日期 1 年的订单数据插入到 <code>ArchivedOrders</code> 表，并将这些数据从 <code>Orders</code> 表中删除。</p><h3 id="3-定时归档任务（使用-SQL-Server-Agent）"><a href="#3-定时归档任务（使用-SQL-Server-Agent）" class="headerlink" title="3. 定时归档任务（使用 SQL Server Agent）"></a>3. 定时归档任务（使用 SQL Server Agent）</h3><p>我们可以使用 SQL Server Agent 来创建一个定时任务，定期执行数据归档操作。例如，每天运行一次，将 1 年前的订单数据归档：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在 SQL Server Agent 中创建作业来执行归档操作</span></span><br><span class="line">USE msdb;</span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXEC</span> sp_add_job</span><br><span class="line">    <span class="variable">@job</span>_name <span class="operator">=</span> N<span class="string">&#x27;ArchiveOldOrders&#x27;</span>;</span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXEC</span> sp_add_jobstep</span><br><span class="line">    <span class="variable">@job</span>_name <span class="operator">=</span> N<span class="string">&#x27;ArchiveOldOrders&#x27;</span>,</span><br><span class="line">    <span class="variable">@step</span>_name <span class="operator">=</span> N<span class="string">&#x27;ArchiveOrdersStep&#x27;</span>,</span><br><span class="line">    <span class="variable">@subsystem</span> <span class="operator">=</span> N<span class="string">&#x27;TSQL&#x27;</span>,</span><br><span class="line">    <span class="variable">@command</span> <span class="operator">=</span> N<span class="string">&#x27;</span></span><br><span class="line"><span class="string">        INSERT INTO ArchivedOrders (OrderID, CustomerID, OrderDate, ProductID, TotalAmount, Status)</span></span><br><span class="line"><span class="string">        SELECT OrderID, CustomerID, OrderDate, ProductID, TotalAmount, Status</span></span><br><span class="line"><span class="string">        FROM Orders</span></span><br><span class="line"><span class="string">        WHERE OrderDate &lt; DATEADD(YEAR, -1, GETDATE());</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        DELETE FROM Orders</span></span><br><span class="line"><span class="string">        WHERE OrderDate &lt; DATEADD(YEAR, -1, GETDATE());</span></span><br><span class="line"><span class="string">    &#x27;</span>,</span><br><span class="line">    <span class="variable">@database</span>_name <span class="operator">=</span> N<span class="string">&#x27;VGDB&#x27;</span>;</span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置作业的调度，例如每天运行一次</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_add_schedule</span><br><span class="line">    <span class="variable">@schedule</span>_name <span class="operator">=</span> N<span class="string">&#x27;ArchiveOrdersDaily&#x27;</span>,</span><br><span class="line">    <span class="variable">@enabled</span> <span class="operator">=</span> <span class="number">1</span>,</span><br><span class="line">    <span class="variable">@freq</span>_type <span class="operator">=</span> <span class="number">4</span>, <span class="comment">-- 每天</span></span><br><span class="line">    <span class="variable">@freq</span>_interval <span class="operator">=</span> <span class="number">1</span>, <span class="comment">-- 每天执行一次</span></span><br><span class="line">    <span class="variable">@active</span>_start_time <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXEC</span> sp_attach_schedule</span><br><span class="line">    <span class="variable">@job</span>_name <span class="operator">=</span> N<span class="string">&#x27;ArchiveOldOrders&#x27;</span>,</span><br><span class="line">    <span class="variable">@schedule</span>_name <span class="operator">=</span> N<span class="string">&#x27;ArchiveOrdersDaily&#x27;</span>;</span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 启动作业</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_start_job <span class="variable">@job</span>_name <span class="operator">=</span> N<span class="string">&#x27;ArchiveOldOrders&#x27;</span>;</span><br><span class="line">GO</span><br></pre></td></tr></table></figure><h3 id="4-查询归档数据"><a href="#4-查询归档数据" class="headerlink" title="4. 查询归档数据"></a>4. 查询归档数据</h3><p>归档后的数据依然可以查询，但不会影响主表的查询性能。为了查找某个客户的历史订单，可以查询归档表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询某个客户的历史订单</span></span><br><span class="line"><span class="keyword">SELECT</span> OrderID, CustomerID, OrderDate, ProductID, TotalAmount, Status</span><br><span class="line"><span class="keyword">FROM</span> ArchivedOrders</span><br><span class="line"><span class="keyword">WHERE</span> CustomerID <span class="operator">=</span> <span class="number">1001</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> OrderDate <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><h3 id="5-优化与注意事项"><a href="#5-优化与注意事项" class="headerlink" title="5. 优化与注意事项"></a>5. 优化与注意事项</h3><ul><li><strong>归档策略</strong>：可以根据实际业务需求选择合适的时间范围（例如，3 个月、6 个月或 1 年）。可以通过调整 <code>WHERE</code> 条件来修改归档规则。</li><li><strong>性能优化</strong>：定期归档操作可以减轻主表的负担，提高查询性能。定期删除旧数据也能减少主表的存储空间。</li><li><strong>归档数据的备份和恢复</strong>：归档数据同样需要定期备份，并能够在需要时恢复。确保归档表也包括足够的备份策略。</li></ul><h3 id="6-归档与清理数据的另一个选项：软删除"><a href="#6-归档与清理数据的另一个选项：软删除" class="headerlink" title="6. 归档与清理数据的另一个选项：软删除"></a>6. 归档与清理数据的另一个选项：软删除</h3><p>在某些情况下，数据归档后并没有从数据库中完全删除，而是标记为“已归档”或“已删除”。这种方法的优点是可以随时恢复数据，而不会丢失。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在 Orders 表中添加 Archived 标志</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Orders</span><br><span class="line"><span class="keyword">ADD</span> Archived BIT <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将数据标记为已归档</span></span><br><span class="line"><span class="keyword">UPDATE</span> Orders</span><br><span class="line"><span class="keyword">SET</span> Archived <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">WHERE</span> OrderDate <span class="operator">&lt;</span> DATEADD(<span class="keyword">YEAR</span>, <span class="number">-1</span>, GETDATE());</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询未归档的数据</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Orders <span class="keyword">WHERE</span> Archived <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询归档数据</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Orders <span class="keyword">WHERE</span> Archived <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>通过这种方法，归档的订单仍然保留在主表中，但通过 <code>Archived</code> 字段可以区分已归档和未归档的订单。</p><h3 id="小结一下-3"><a href="#小结一下-3" class="headerlink" title="小结一下"></a>小结一下</h3><p>数据归档操作是管理大数据量数据库的一种有效策略。通过定期将历史数据从主数据库表中迁移到归档表，可以显著提高数据库的查询性能，同时确保历史数据得以保留，便于以后查询和审计。</p><h2 id="5-存储和硬件优化"><a href="#5-存储和硬件优化" class="headerlink" title="5. 存储和硬件优化"></a>5. 存储和硬件优化</h2><ul><li><strong>磁盘 I&#x2F;O 优化</strong>：数据库的性能受到磁盘 I&#x2F;O 的限制，尤其是在处理大量数据时。使用 SSD 存储比传统的硬盘（HDD）提供更快的 I&#x2F;O 性能。</li><li><strong>增加内存</strong>：增加 SQL Server 的内存，可以使数据库缓冲池更大，从而减少磁盘 I&#x2F;O，提升查询性能。</li><li><strong>使用 RAID 配置</strong>：使用 RAID 10 或其他 RAID 配置，确保数据读写的高效性和可靠性。</li></ul><p>存储和硬件优化是提升数据库性能的关键部分，尤其是在大规模数据处理的环境中。通过合理的硬件资源分配、存储结构优化以及数据库配置，可以显著提高性能。下面我们将针对一个电商平台的订单系统来讲解如何在存储和硬件层面优化 SQL Server。</p><h3 id="业务场景："><a href="#业务场景：" class="headerlink" title="业务场景："></a>业务场景：</h3><p>假设你有一个电商平台，订单数据存储在 SQL Server 中，订单数量日益增加，导致查询性能下降。在此场景中，我们可以通过以下方法进行存储和硬件优化。</p><h3 id="优化策略："><a href="#优化策略：" class="headerlink" title="优化策略："></a>优化策略：</h3><ol><li><strong>磁盘 I&#x2F;O 优化</strong>：<ul><li>使用 SSD 替代传统硬盘（HDD）以提高读写速度。</li><li>将数据文件、日志文件和临时文件存储在不同的物理磁盘上。</li></ul></li><li><strong>表和索引存储</strong>：<ul><li>使用适当的存储格式和文件组织方式，如分区表和表压缩。</li><li>将频繁访问的表和索引放置在高性能的磁盘上。</li></ul></li><li><strong>硬件资源配置</strong>：<ul><li>增加内存以支持更多的数据缓存，减少磁盘访问。</li><li>使用多核 CPU 以提高并发查询的处理能力。</li></ul></li><li><strong>数据压缩</strong>：<ul><li>在 SQL Server 中启用数据压缩，以减少磁盘空间的使用并提高 I&#x2F;O 性能。</li></ul></li></ol><h3 id="1-创建表并优化存储"><a href="#1-创建表并优化存储" class="headerlink" title="1. 创建表并优化存储"></a>1. 创建表并优化存储</h3><p>首先，我们创建订单表，并为订单表的 <code>OrderID</code> 列创建聚集索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建 Orders 表并优化存储</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Orders</span><br><span class="line">(</span><br><span class="line">    OrderID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY CLUSTERED,  <span class="comment">-- 聚集索引</span></span><br><span class="line">    CustomerID <span class="type">INT</span>,</span><br><span class="line">    OrderDate DATETIME,</span><br><span class="line">    ProductID <span class="type">INT</span>,</span><br><span class="line">    TotalAmount <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    Status <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">) </span><br><span class="line"><span class="keyword">ON</span> [<span class="keyword">PRIMARY</span>]</span><br><span class="line"><span class="keyword">WITH</span> (DATA_COMPRESSION <span class="operator">=</span> PAGE);  <span class="comment">-- 启用数据页压缩以节省空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 启用非聚集索引，用于优化查询</span></span><br><span class="line"><span class="keyword">CREATE</span> NONCLUSTERED INDEX idx_OrderDate</span><br><span class="line"><span class="keyword">ON</span> Orders(OrderDate)</span><br><span class="line"><span class="keyword">WITH</span> (DATA_COMPRESSION <span class="operator">=</span> PAGE);  <span class="comment">-- 同样启用数据压缩</span></span><br></pre></td></tr></table></figure><p>通过使用 <code>DATA_COMPRESSION = PAGE</code>，我们启用了 SQL Server 的数据压缩功能，以节省存储空间并提高磁盘 I&#x2F;O 性能。<code>PAGE</code> 压缩比 <code>ROW</code> 压缩更高效，适合大型数据表。</p><h3 id="2-分区表优化"><a href="#2-分区表优化" class="headerlink" title="2. 分区表优化"></a>2. 分区表优化</h3><p>在订单数据量不断增加的情况下，我们可以将订单表进行分区。根据 <code>OrderDate</code> 列将数据划分为不同的分区，以减少查询时的扫描范围，提高查询效率。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建分区函数</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PARTITION</span> <span class="keyword">FUNCTION</span> pf_OrderDate (DATETIME)</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">RANGE</span> <span class="keyword">RIGHT</span> <span class="keyword">FOR</span> <span class="keyword">VALUES</span> (<span class="string">&#x27;2022-01-01&#x27;</span>, <span class="string">&#x27;2023-01-01&#x27;</span>, <span class="string">&#x27;2024-01-01&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建分区方案</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PARTITION</span> SCHEME ps_OrderDate</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">PARTITION</span> pf_OrderDate</span><br><span class="line"><span class="keyword">TO</span> ([<span class="keyword">PRIMARY</span>], [<span class="keyword">PRIMARY</span>], [<span class="keyword">PRIMARY</span>], [<span class="keyword">PRIMARY</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建分区表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Orders</span><br><span class="line">(</span><br><span class="line">    OrderID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY CLUSTERED, </span><br><span class="line">    CustomerID <span class="type">INT</span>,</span><br><span class="line">    OrderDate DATETIME,</span><br><span class="line">    ProductID <span class="type">INT</span>,</span><br><span class="line">    TotalAmount <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    Status <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">) </span><br><span class="line"><span class="keyword">ON</span> ps_OrderDate(OrderDate);  <span class="comment">-- 按 OrderDate 列进行分区</span></span><br></pre></td></tr></table></figure><p>在此代码中，我们根据 <code>OrderDate</code> 列的年份划分了不同的分区（如 2022 年、2023 年和 2024 年的订单数据）。这样可以使查询在某一特定时间范围内的性能更高，因为 SQL Server 只需要扫描相关分区的数据，而不是整个表。</p><h3 id="3-硬件优化配置"><a href="#3-硬件优化配置" class="headerlink" title="3. 硬件优化配置"></a>3. 硬件优化配置</h3><h4 id="3-1-确保使用-SSD-磁盘"><a href="#3-1-确保使用-SSD-磁盘" class="headerlink" title="3.1. 确保使用 SSD 磁盘"></a>3.1. 确保使用 SSD 磁盘</h4><p>SSD 磁盘比传统硬盘的读写速度快，因此将数据库的主要数据文件、日志文件和临时文件分别存储在不同的磁盘上（最好是 SSD）可以提高性能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 将 SQL Server 数据文件 (.mdf) 存储在 SSD 磁盘</span><br><span class="line">-- 将日志文件 (.ldf) 存储在 SSD 磁盘</span><br><span class="line">-- 将临时数据库文件 (.ndf) 存储在 SSD 磁盘</span><br></pre></td></tr></table></figure><h4 id="3-2-配置-SQL-Server-内存"><a href="#3-2-配置-SQL-Server-内存" class="headerlink" title="3.2. 配置 SQL Server 内存"></a>3.2. 配置 SQL Server 内存</h4><p>将 SQL Server 的内存设置为最大化，以便更多数据可以缓存在内存中，从而减少磁盘 I&#x2F;O。以下为如何设置 SQL Server 的最大内存配置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看当前内存设置</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;show advanced options&#x27;</span>, <span class="number">1</span>;</span><br><span class="line">RECONFIGURE;</span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;max server memory (MB)&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置最大内存为 16 GB</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;max server memory (MB)&#x27;</span>, <span class="number">16384</span>;</span><br><span class="line">RECONFIGURE;</span><br></pre></td></tr></table></figure><p>通过适当的内存配置，SQL Server 可以将更多数据缓存在内存中，从而减少对磁盘的访问，提高查询响应速度。</p><h4 id="3-3-配置-SQL-Server-并行处理"><a href="#3-3-配置-SQL-Server-并行处理" class="headerlink" title="3.3. 配置 SQL Server 并行处理"></a>3.3. 配置 SQL Server 并行处理</h4><p>如果服务器具有多核 CPU，可以通过设置 SQL Server 允许更多的并行查询操作，从而提高多线程查询的处理能力。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看当前并行度配置</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;max degree of parallelism&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置为 4，允许最多 4 个 CPU 并行处理查询</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;max degree of parallelism&#x27;</span>, <span class="number">4</span>;</span><br><span class="line">RECONFIGURE;</span><br></pre></td></tr></table></figure><h3 id="4-磁盘-I-x2F-O-优化：分开存储数据文件、日志文件和临时文件"><a href="#4-磁盘-I-x2F-O-优化：分开存储数据文件、日志文件和临时文件" class="headerlink" title="4. 磁盘 I&#x2F;O 优化：分开存储数据文件、日志文件和临时文件"></a>4. 磁盘 I&#x2F;O 优化：分开存储数据文件、日志文件和临时文件</h3><p>磁盘 I&#x2F;O 是数据库性能的瓶颈之一。为了提高数据库的性能，最好将数据文件、日志文件和临时文件存储在不同的物理磁盘上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 数据文件 (.mdf) 存储在磁盘 A</span><br><span class="line">-- 日志文件 (.ldf) 存储在磁盘 B</span><br><span class="line">-- 临时数据库文件 (.ndf) 存储在磁盘 C</span><br></pre></td></tr></table></figure><h3 id="5-数据备份和恢复优化"><a href="#5-数据备份和恢复优化" class="headerlink" title="5. 数据备份和恢复优化"></a>5. 数据备份和恢复优化</h3><p>确保定期备份数据，并使用增量备份、差异备份等方式以减少备份时的磁盘负担。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 进行完整备份</span></span><br><span class="line">BACKUP DATABASE VGDB <span class="keyword">TO</span> DISK <span class="operator">=</span> <span class="string">&#x27;D:\Backups\VGDB_full.bak&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 进行差异备份</span></span><br><span class="line">BACKUP DATABASE WGDB <span class="keyword">TO</span> DISK <span class="operator">=</span> <span class="string">&#x27;D:\Backups\VGDB_diff.bak&#x27;</span> <span class="keyword">WITH</span> DIFFERENTIAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 进行事务日志备份</span></span><br><span class="line">BACKUP LOG VGDB <span class="keyword">TO</span> DISK <span class="operator">=</span> <span class="string">&#x27;D:\Backups\VGDB_log.trn&#x27;</span>;</span><br></pre></td></tr></table></figure><p>通过这种方法，可以在系统崩溃时快速恢复数据，同时减少备份过程中对硬盘 I&#x2F;O 性能的影响。</p><h3 id="6-监控和维护"><a href="#6-监控和维护" class="headerlink" title="6. 监控和维护"></a>6. 监控和维护</h3><p>定期监控 SQL Server 的性能，并根据硬件和存储需求做出相应的调整。通过 SQL Server 的动态管理视图（DMV）来监控 I&#x2F;O 性能、查询执行计划、索引使用情况等。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看磁盘 I/O 状况</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sys.dm_io_virtual_file_stats(<span class="keyword">NULL</span>, <span class="keyword">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看查询执行计划的缓存</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sys.dm_exec_query_stats;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看当前的索引使用情况</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sys.dm_db_index_usage_stats;</span><br></pre></td></tr></table></figure><h3 id="小结一下-4"><a href="#小结一下-4" class="headerlink" title="小结一下"></a>小结一下</h3><p>通过存储和硬件优化，可以显著提升 SQL Server 数据库的性能。关键的优化措施包括使用 SSD 磁盘、将数据文件、日志文件和临时文件分开存储、启用数据压缩、使用分区表来提高查询效率以及调整内存和并行处理配置等。定期的维护和监控也能帮助你发现性能瓶颈并作出相应调整。</p><h2 id="6-数据库参数和配置优化"><a href="#6-数据库参数和配置优化" class="headerlink" title="6. 数据库参数和配置优化"></a>6. 数据库参数和配置优化</h2><ul><li><strong>调整最大并发连接数</strong>：确保 SQL Server 配置了足够的最大并发连接数，避免过多连接时导致性能下降。</li><li><strong>设置合适的内存限制</strong>：为 SQL Server 配置足够的内存（<code>max server memory</code>），避免内存溢出或过度使用磁盘交换。</li><li><strong>自动更新统计信息</strong>：确保 SQL Server 自动更新查询的统计信息（<code>AUTO_UPDATE_STATISTICS</code>），以便查询优化器选择最优执行计划。</li></ul><p>数据库参数和配置优化是确保数据库系统性能达到最佳状态的重要步骤。在高并发、高负载的场景下，合理的配置可以显著提高数据库性能，减少响应时间和延迟。以下是基于一个电商平台订单系统的业务场景，如何通过优化数据库的参数和配置来提升性能的完整代码案例。</p><h3 id="业务场景：-1"><a href="#业务场景：-1" class="headerlink" title="业务场景："></a>业务场景：</h3><p>假设电商平台的订单量非常大，系统每天处理数百万个订单，数据库的性能和响应速度是系统正常运行的关键。为确保数据库性能，在 SQL Server 中进行参数和配置优化至关重要。</p><h3 id="优化策略：-1"><a href="#优化策略：-1" class="headerlink" title="优化策略："></a>优化策略：</h3><ol><li><strong>调整内存配置</strong>：通过配置 SQL Server 使用更多的内存来缓存数据，减少磁盘 I&#x2F;O。</li><li><strong>设置最大并行度</strong>：根据 CPU 核心数，调整 SQL Server 的并行查询处理能力。</li><li><strong>优化磁盘和存储配置</strong>：确保日志文件、数据文件和临时文件分开存储。</li><li><strong>启用自动数据库优化</strong>：确保数据库能够自动进行碎片整理、更新统计信息等任务。</li><li><strong>调整事务日志和恢复模式</strong>：确保数据库在发生故障时能够快速恢复。</li></ol><h3 id="1-调整内存配置"><a href="#1-调整内存配置" class="headerlink" title="1. 调整内存配置"></a>1. 调整内存配置</h3><p>内存配置优化是提高 SQL Server 性能的关键部分。通过增加 SQL Server 的最大内存，可以保证查询操作不会因为磁盘 I&#x2F;O 的瓶颈而导致性能问题。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看当前最大内存配置</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;show advanced options&#x27;</span>, <span class="number">1</span>;</span><br><span class="line">RECONFIGURE;</span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;max server memory (MB)&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置最大内存为 16 GB</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;max server memory (MB)&#x27;</span>, <span class="number">16384</span>;  <span class="comment">-- 16 GB</span></span><br><span class="line">RECONFIGURE;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们将 SQL Server 的最大内存设置为 16 GB。适当配置内存可以提高查询性能，减少磁盘的访问。</p><h3 id="2-设置最大并行度"><a href="#2-设置最大并行度" class="headerlink" title="2. 设置最大并行度"></a>2. 设置最大并行度</h3><p>SQL Server 可以利用多个 CPU 核心进行并行查询处理。通过合理设置并行度，可以提高大查询的处理能力。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看当前的最大并行度设置</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;max degree of parallelism&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置最大并行度为 4（适用于 4 核 CPU 的机器）</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;max degree of parallelism&#x27;</span>, <span class="number">4</span>;</span><br><span class="line">RECONFIGURE;</span><br></pre></td></tr></table></figure><p>通过此设置，SQL Server 可以在查询时利用最多 4 个 CPU 核心进行并行处理。如果你的服务器有更多核心，可以根据实际情况调整这个参数。</p><h3 id="3-调整事务日志和恢复模式"><a href="#3-调整事务日志和恢复模式" class="headerlink" title="3. 调整事务日志和恢复模式"></a>3. 调整事务日志和恢复模式</h3><p>对于电商平台而言，事务日志的优化至关重要。确保在进行大规模事务操作时，日志文件能够高效地处理，并且确保恢复模式符合业务需求。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看数据库的恢复模式</span></span><br><span class="line"><span class="keyword">SELECT</span> name, recovery_model_desc</span><br><span class="line"><span class="keyword">FROM</span> sys.databases</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;VGDB&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置恢复模式为简单恢复模式</span></span><br><span class="line"><span class="keyword">ALTER</span> DATABASE VGDB</span><br><span class="line"><span class="keyword">SET</span> RECOVERY SIMPLE;</span><br></pre></td></tr></table></figure><p>对于不需要完整备份的数据库，使用简单恢复模式可以减少日志文件的增长，减轻磁盘 I&#x2F;O 压力。</p><h3 id="4-配置自动数据库优化"><a href="#4-配置自动数据库优化" class="headerlink" title="4. 配置自动数据库优化"></a>4. 配置自动数据库优化</h3><p>确保数据库能够定期执行自动优化任务，如重建索引、更新统计信息等。定期优化可以提高数据库的查询性能，避免碎片化问题。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 启用自动更新统计信息</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;auto update statistics&#x27;</span>, <span class="number">1</span>;</span><br><span class="line">RECONFIGURE;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 启用自动创建统计信息</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;auto create statistics&#x27;</span>, <span class="number">1</span>;</span><br><span class="line">RECONFIGURE;</span><br></pre></td></tr></table></figure><p>通过启用自动更新统计信息和自动创建统计信息，可以确保 SQL Server 在执行查询时能够使用最新的执行计划，减少查询优化器的负担。</p><h3 id="5-配置磁盘和存储"><a href="#5-配置磁盘和存储" class="headerlink" title="5. 配置磁盘和存储"></a>5. 配置磁盘和存储</h3><p>确保 SQL Server 的数据文件、日志文件和临时文件存储在不同的磁盘上，特别是将日志文件和数据文件存储在高速磁盘（如 SSD）上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 将数据文件 (.mdf) 存储在磁盘 A（SSD）</span><br><span class="line">-- 将日志文件 (.ldf) 存储在磁盘 B（SSD）</span><br><span class="line">-- 将临时数据库文件 (.ndf) 存储在磁盘 C（SSD）</span><br></pre></td></tr></table></figure><p>通过将数据文件、日志文件和临时文件分别存储在不同的磁盘上，可以避免磁盘 I&#x2F;O 争用，提升数据库的整体性能。</p><h3 id="6-启用数据库压缩"><a href="#6-启用数据库压缩" class="headerlink" title="6. 启用数据库压缩"></a>6. 启用数据库压缩</h3><p>对于需要存储大量数据的电商平台，启用数据压缩可以减少存储空间并提高查询性能，尤其是在磁盘 I&#x2F;O 上。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 启用表压缩</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Orders REBUILD <span class="keyword">PARTITION</span> <span class="operator">=</span> <span class="keyword">ALL</span> <span class="keyword">WITH</span> (DATA_COMPRESSION <span class="operator">=</span> PAGE);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 启用索引压缩</span></span><br><span class="line"><span class="keyword">ALTER</span> INDEX <span class="keyword">ALL</span> <span class="keyword">ON</span> Orders REBUILD <span class="keyword">PARTITION</span> <span class="operator">=</span> <span class="keyword">ALL</span> <span class="keyword">WITH</span> (DATA_COMPRESSION <span class="operator">=</span> PAGE);</span><br></pre></td></tr></table></figure><p>通过启用数据压缩，我们可以有效节省存储空间，减少磁盘 I&#x2F;O 操作，并提高查询速度。</p><h3 id="7-配置自动维护任务"><a href="#7-配置自动维护任务" class="headerlink" title="7. 配置自动维护任务"></a>7. 配置自动维护任务</h3><p>SQL Server 提供了自动维护任务，如索引重建、数据库碎片整理等，可以通过 SQL Server Agent 定时任务来自动执行这些任务，保持数据库的高效运行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建一个定期执行的作业，执行索引重建任务</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_add_job <span class="variable">@job</span>_name <span class="operator">=</span> <span class="string">&#x27;RebuildIndexes&#x27;</span>, <span class="variable">@enabled</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">EXEC</span> sp_add_jobstep <span class="variable">@job</span>_name <span class="operator">=</span> <span class="string">&#x27;RebuildIndexes&#x27;</span>, </span><br><span class="line">    <span class="variable">@step</span>_name <span class="operator">=</span> <span class="string">&#x27;RebuildIndexStep&#x27;</span>, </span><br><span class="line">    <span class="variable">@subsystem</span> <span class="operator">=</span> <span class="string">&#x27;TSQL&#x27;</span>, </span><br><span class="line">    <span class="variable">@command</span> <span class="operator">=</span> <span class="string">&#x27;ALTER INDEX ALL ON Orders REBUILD&#x27;</span>,</span><br><span class="line">    <span class="variable">@retry</span>_attempts <span class="operator">=</span> <span class="number">3</span>, </span><br><span class="line">    <span class="variable">@retry</span>_interval <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置作业运行频率：每天凌晨 2 点执行</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_add_schedule <span class="variable">@schedule</span>_name <span class="operator">=</span> <span class="string">&#x27;RebuildIndexSchedule&#x27;</span>,</span><br><span class="line">    <span class="variable">@enabled</span> <span class="operator">=</span> <span class="number">1</span>,</span><br><span class="line">    <span class="variable">@freq</span>_type <span class="operator">=</span> <span class="number">4</span>, </span><br><span class="line">    <span class="variable">@freq</span>_interval <span class="operator">=</span> <span class="number">1</span>, </span><br><span class="line">    <span class="variable">@active</span>_start_time <span class="operator">=</span> <span class="number">20000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXEC</span> sp_attach_schedule <span class="variable">@job</span>_name <span class="operator">=</span> <span class="string">&#x27;RebuildIndexes&#x27;</span>, <span class="variable">@schedule</span>_name <span class="operator">=</span> <span class="string">&#x27;RebuildIndexSchedule&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这个作业将在每天凌晨 2 点执行，重建 <code>Orders</code> 表上的所有索引，从而避免因索引碎片而降低查询性能。</p><h3 id="8-启用即时日志备份"><a href="#8-启用即时日志备份" class="headerlink" title="8. 启用即时日志备份"></a>8. 启用即时日志备份</h3><p>对于生产环境，尤其是电商平台，确保日志备份及时执行至关重要。启用日志备份可以保证在数据库发生故障时进行快速恢复。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置事务日志备份</span></span><br><span class="line">BACKUP LOG VGDB <span class="keyword">TO</span> DISK <span class="operator">=</span> <span class="string">&#x27;D:\Backups\YourDatabase_log.trn&#x27;</span>;</span><br></pre></td></tr></table></figure><p>通过定期执行事务日志备份，可以确保在发生故障时，数据库能够恢复到最新的状态。</p><h3 id="9-启用数据库缓存"><a href="#9-启用数据库缓存" class="headerlink" title="9. 启用数据库缓存"></a>9. 启用数据库缓存</h3><p>SQL Server 会缓存查询结果和数据页，通过调整缓存策略来优化性能。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看缓存的页面数量</span></span><br><span class="line">DBCC SHOW_STATISTICS(<span class="string">&#x27;Orders&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 强制清除缓存（有时可以用于测试）</span></span><br><span class="line">DBCC FREEPROCCACHE;</span><br><span class="line">DBCC DROPCLEANBUFFERS;</span><br></pre></td></tr></table></figure><p>在日常操作中，我们不建议经常清除缓存，但可以在需要时清除缓存来测试性能优化效果。</p><h3 id="小结一下-5"><a href="#小结一下-5" class="headerlink" title="小结一下"></a>小结一下</h3><p>通过优化 SQL Server 的配置和参数，可以显著提升电商平台的数据库性能。关键的优化措施包括调整内存和并行度、优化磁盘存储和日志配置、启用数据压缩、定期执行自动数据库优化任务、配置数据库压缩和定期备份等。根据业务需求和硬件资源进行合理配置，以确保数据库在高并发、高负载的环境中能够稳定高效地运行。</p><h2 id="7-批量数据处理"><a href="#7-批量数据处理" class="headerlink" title="7. 批量数据处理"></a>7. 批量数据处理</h2><ul><li><strong>批量插入&#x2F;更新操作</strong>：在处理大量数据时，可以使用批量插入或更新操作，而不是一行一行地进行。这能显著提高数据的加载速度。</li><li><strong>避免大事务</strong>：对于大量的数据修改，避免使用大事务，因为大事务可能会导致锁竞争、日志文件过大等问题。使用小批次事务进行操作。</li></ul><p>批量数据处理在大规模应用中是不可避免的，尤其是像电商平台、金融系统等业务场景，通常需要进行大批量的订单、用户信息处理等。批量操作能够显著提高数据处理效率，但也需要谨慎设计，以确保性能和稳定性。</p><h3 id="业务场景：-2"><a href="#业务场景：-2" class="headerlink" title="业务场景："></a>业务场景：</h3><p>假设在电商平台中，订单信息需要进行批量处理，比如批量更新订单状态、批量删除失效订单、批量插入订单数据等。通过设计合适的批量操作，能够有效减少单次操作的数据库访问次数，提升系统的响应能力。</p><h3 id="优化方案："><a href="#优化方案：" class="headerlink" title="优化方案："></a>优化方案：</h3><ol><li><strong>批量插入数据</strong>：通过 <code>BULK INSERT</code> 或者 <code>INSERT INTO</code> 多行插入方式，减少多次单独插入操作带来的性能瓶颈。</li><li><strong>批量更新数据</strong>：使用 <code>UPDATE</code> 操作一次性更新多条记录。</li><li><strong>批量删除数据</strong>：批量删除过期的订单，或者批量删除无效的用户信息。</li></ol><p>以下是具体的 SQL Server 批量数据处理的代码案例。</p><h3 id="1-批量插入数据"><a href="#1-批量插入数据" class="headerlink" title="1. 批量插入数据"></a>1. 批量插入数据</h3><p>批量插入可以减少大量单独插入操作的时间开销，通过 <code>INSERT INTO</code> 语句一次插入多条数据。</p><h4 id="示例：批量插入订单数据"><a href="#示例：批量插入订单数据" class="headerlink" title="示例：批量插入订单数据"></a>示例：批量插入订单数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 假设 Orders 表结构如下：OrderID INT, CustomerID INT, OrderDate DATETIME, OrderStatus VARCHAR(20)</span></span><br><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@OrderData</span> <span class="keyword">TABLE</span> (OrderID <span class="type">INT</span>, CustomerID <span class="type">INT</span>, OrderDate DATETIME, OrderStatus <span class="type">VARCHAR</span>(<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将订单数据插入临时表</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="variable">@OrderData</span> (OrderID, CustomerID, OrderDate, OrderStatus)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    (<span class="number">1</span>, <span class="number">101</span>, <span class="string">&#x27;2024-11-01&#x27;</span>, <span class="string">&#x27;Pending&#x27;</span>),</span><br><span class="line">    (<span class="number">2</span>, <span class="number">102</span>, <span class="string">&#x27;2024-11-02&#x27;</span>, <span class="string">&#x27;Shipped&#x27;</span>),</span><br><span class="line">    (<span class="number">3</span>, <span class="number">103</span>, <span class="string">&#x27;2024-11-03&#x27;</span>, <span class="string">&#x27;Delivered&#x27;</span>),</span><br><span class="line">    (<span class="number">4</span>, <span class="number">104</span>, <span class="string">&#x27;2024-11-04&#x27;</span>, <span class="string">&#x27;Cancelled&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 批量插入数据到 Orders 表</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Orders (OrderID, CustomerID, OrderDate, OrderStatus)</span><br><span class="line"><span class="keyword">SELECT</span> OrderID, CustomerID, OrderDate, OrderStatus</span><br><span class="line"><span class="keyword">FROM</span> <span class="variable">@OrderData</span>;</span><br></pre></td></tr></table></figure><p>在此例中，我们先将数据插入临时表 <code>@OrderData</code>，然后通过 <code>INSERT INTO SELECT</code> 语句批量插入 <code>Orders</code> 表。这种方式可以大大减少数据库访问的次数。</p><h3 id="2-批量更新数据"><a href="#2-批量更新数据" class="headerlink" title="2. 批量更新数据"></a>2. 批量更新数据</h3><p>批量更新操作通常用于修改多个记录中的某些字段，避免多次单独更新。</p><h4 id="示例：批量更新订单状态"><a href="#示例：批量更新订单状态" class="headerlink" title="示例：批量更新订单状态"></a>示例：批量更新订单状态</h4><p>假设需要批量更新所有未发货的订单状态为 “Shipped”，可以通过如下 SQL 来实现：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 批量更新订单状态</span></span><br><span class="line"><span class="keyword">UPDATE</span> Orders</span><br><span class="line"><span class="keyword">SET</span> OrderStatus <span class="operator">=</span> <span class="string">&#x27;Shipped&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> OrderStatus <span class="operator">=</span> <span class="string">&#x27;Pending&#x27;</span> <span class="keyword">AND</span> OrderDate <span class="operator">&lt;</span> <span class="string">&#x27;2024-11-01&#x27;</span>;</span><br></pre></td></tr></table></figure><p>该操作会一次性更新所有符合条件的记录，避免多次单独更新操作带来的性能问题。</p><h3 id="3-批量删除数据"><a href="#3-批量删除数据" class="headerlink" title="3. 批量删除数据"></a>3. 批量删除数据</h3><p>在某些场景下，我们需要批量删除某些过期或无效的数据。例如，删除 30 天之前的过期订单。</p><h4 id="示例：批量删除过期订单"><a href="#示例：批量删除过期订单" class="headerlink" title="示例：批量删除过期订单"></a>示例：批量删除过期订单</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除过期的订单</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> OrderDate <span class="operator">&lt;</span> DATEADD(<span class="keyword">DAY</span>, <span class="number">-30</span>, GETDATE()) <span class="keyword">AND</span> OrderStatus <span class="operator">=</span> <span class="string">&#x27;Completed&#x27;</span>;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们删除所有已完成且订单日期超过 30 天的订单。这种批量删除操作比逐个删除要高效得多。</p><h3 id="4-批量处理逻辑优化"><a href="#4-批量处理逻辑优化" class="headerlink" title="4. 批量处理逻辑优化"></a>4. 批量处理逻辑优化</h3><p>有时批量操作的数据量非常大，直接处理可能导致性能问题或数据库锁争用。可以考虑分批次执行操作来减轻系统负担。</p><h4 id="示例：按批次处理订单数据"><a href="#示例：按批次处理订单数据" class="headerlink" title="示例：按批次处理订单数据"></a>示例：按批次处理订单数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@BatchSize</span> <span class="type">INT</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@StartRow</span> <span class="type">INT</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@TotalRows</span> <span class="type">INT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 计算总记录数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@TotalRows</span> <span class="operator">=</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> Orders <span class="keyword">WHERE</span> OrderStatus <span class="operator">=</span> <span class="string">&#x27;Pending&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 循环批量处理数据</span></span><br><span class="line">WHILE <span class="variable">@StartRow</span> <span class="operator">&lt;</span> <span class="variable">@TotalRows</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- 批量更新 1000 条数据</span></span><br><span class="line">    <span class="keyword">UPDATE</span> TOP (<span class="variable">@BatchSize</span>) Orders</span><br><span class="line">    <span class="keyword">SET</span> OrderStatus <span class="operator">=</span> <span class="string">&#x27;Shipped&#x27;</span></span><br><span class="line">    <span class="keyword">WHERE</span> OrderStatus <span class="operator">=</span> <span class="string">&#x27;Pending&#x27;</span> <span class="keyword">AND</span> OrderDate <span class="operator">&lt;</span> <span class="string">&#x27;2024-11-01&#x27;</span> <span class="keyword">AND</span> OrderID <span class="operator">&gt;</span> <span class="variable">@StartRow</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 更新已处理的行数</span></span><br><span class="line">    <span class="keyword">SET</span> <span class="variable">@StartRow</span> <span class="operator">=</span> <span class="variable">@StartRow</span> <span class="operator">+</span> <span class="variable">@BatchSize</span>;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><p>通过分批次处理（每次处理 1000 条记录），可以避免一次性处理大量数据时造成的性能瓶颈或数据库锁的问题。适用于需要批量更新大量记录的情况。</p><h3 id="5-使用事务保证数据一致性"><a href="#5-使用事务保证数据一致性" class="headerlink" title="5. 使用事务保证数据一致性"></a>5. 使用事务保证数据一致性</h3><p>对于批量操作来说，通常需要使用事务来保证数据一致性，即要么全部成功，要么全部失败。</p><h4 id="示例：批量插入订单并使用事务"><a href="#示例：批量插入订单并使用事务" class="headerlink" title="示例：批量插入订单并使用事务"></a>示例：批量插入订单并使用事务</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> TRY</span><br><span class="line">    <span class="comment">-- 假设 Orders 表结构：OrderID INT, CustomerID INT, OrderDate DATETIME, OrderStatus VARCHAR(20)</span></span><br><span class="line">    <span class="keyword">DECLARE</span> <span class="variable">@OrderData</span> <span class="keyword">TABLE</span> (OrderID <span class="type">INT</span>, CustomerID <span class="type">INT</span>, OrderDate DATETIME, OrderStatus <span class="type">VARCHAR</span>(<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 批量插入订单数据</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="variable">@OrderData</span> (OrderID, CustomerID, OrderDate, OrderStatus)</span><br><span class="line">    <span class="keyword">VALUES</span></span><br><span class="line">        (<span class="number">5</span>, <span class="number">105</span>, <span class="string">&#x27;2024-11-05&#x27;</span>, <span class="string">&#x27;Pending&#x27;</span>),</span><br><span class="line">        (<span class="number">6</span>, <span class="number">106</span>, <span class="string">&#x27;2024-11-06&#x27;</span>, <span class="string">&#x27;Pending&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> Orders (OrderID, CustomerID, OrderDate, OrderStatus)</span><br><span class="line">    <span class="keyword">SELECT</span> OrderID, CustomerID, OrderDate, OrderStatus</span><br><span class="line">    <span class="keyword">FROM</span> <span class="variable">@OrderData</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 提交事务</span></span><br><span class="line">    <span class="keyword">COMMIT</span> TRANSACTION;</span><br><span class="line"><span class="keyword">END</span> TRY</span><br><span class="line"><span class="keyword">BEGIN</span> CATCH</span><br><span class="line">    <span class="comment">-- 错误处理并回滚事务</span></span><br><span class="line">    <span class="keyword">ROLLBACK</span> TRANSACTION;</span><br><span class="line">    PRINT <span class="string">&#x27;Error occurred: &#x27;</span> <span class="operator">+</span> ERROR_MESSAGE();</span><br><span class="line"><span class="keyword">END</span> CATCH;</span><br></pre></td></tr></table></figure><p>在这个例子中，批量插入操作被包含在一个事务中，确保插入操作的原子性，即要么全部成功，要么全部失败。如果在执行过程中发生错误，会回滚事务，避免数据不一致的情况。</p><h3 id="小结一下-6"><a href="#小结一下-6" class="headerlink" title="小结一下"></a>小结一下</h3><p>批量数据处理是提高 SQL Server 性能的有效手段，尤其是在数据量庞大的电商平台等业务场景中。通过合理使用批量插入、批量更新和批量删除操作，可以大幅度提高数据库的处理效率，减少数据库的 I&#x2F;O 操作次数和锁竞争。在执行批量操作时，记得通过事务保证数据的一致性，分批处理可以进一步优化大规模数据的处理性能。</p><h2 id="8-清理无用数据"><a href="#8-清理无用数据" class="headerlink" title="8. 清理无用数据"></a>8. 清理无用数据</h2><ul><li><strong>删除过期数据</strong>：定期清理过期或不再需要的数据，减少数据库的大小和查询的复杂性。</li><li><strong>清理数据库碎片</strong>：随着数据的增删，表和索引的碎片会增加，影响性能。定期重建索引或重新组织索引，减少碎片。</li></ul><p>清理无用数据是数据库维护中的常见任务，特别是在处理历史数据、过期记录或冗余数据时。定期清理无用数据不仅能够节省存储空间，还能提高数据库性能，避免无用数据对查询、索引等造成不必要的影响。</p><h3 id="业务场景：-3"><a href="#业务场景：-3" class="headerlink" title="业务场景："></a>业务场景：</h3><p>假设我们在一个电商平台中，用户的订单数据每年都会生成大量记录。为了避免订单表过于庞大，且不再使用的订单记录（比如 3 年之前的订单）会占用大量存储空间，我们需要定期清理这些过期订单数据。</p><h3 id="优化方案：-1"><a href="#优化方案：-1" class="headerlink" title="优化方案："></a>优化方案：</h3><ol><li><strong>删除过期数据</strong>：定期删除超过一定时间的订单数据（比如 3 年前的订单）。</li><li><strong>归档过期数据</strong>：将过期的订单数据移到一个历史表或外部存储中，保留必要的历史信息。</li></ol><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="1-定期删除过期数据"><a href="#1-定期删除过期数据" class="headerlink" title="1. 定期删除过期数据"></a>1. 定期删除过期数据</h4><p>假设我们的 <code>Orders</code> 表有字段 <code>OrderDate</code> 来记录订单的创建时间，<code>OrderStatus</code> 来标识订单状态。我们可以每月清理 3 年前的已完成或已取消的订单。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除 3 年前已完成或已取消的订单</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> OrderDate <span class="operator">&lt;</span> DATEADD(<span class="keyword">YEAR</span>, <span class="number">-3</span>, GETDATE()) </span><br><span class="line">    <span class="keyword">AND</span> OrderStatus <span class="keyword">IN</span> (<span class="string">&#x27;Completed&#x27;</span>, <span class="string">&#x27;Cancelled&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>DATEADD(YEAR, -3, GETDATE())</code> 会计算出当前日期 3 年前的日期，所有在此日期之前且状态为 <code>&#39;Completed&#39;</code> 或 <code>&#39;Cancelled&#39;</code> 的订单将被删除。</p><h4 id="2-定期归档过期数据"><a href="#2-定期归档过期数据" class="headerlink" title="2. 定期归档过期数据"></a>2. 定期归档过期数据</h4><p>如果删除数据不符合业务需求，可以选择将数据归档。比如，将 3 年前的订单转移到 <code>ArchivedOrders</code> 表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 将 3 年前的已完成或已取消的订单移动到 ArchivedOrders 表</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> ArchivedOrders (OrderID, CustomerID, OrderDate, OrderStatus)</span><br><span class="line"><span class="keyword">SELECT</span> OrderID, CustomerID, OrderDate, OrderStatus</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> OrderDate <span class="operator">&lt;</span> DATEADD(<span class="keyword">YEAR</span>, <span class="number">-3</span>, GETDATE()) </span><br><span class="line">    <span class="keyword">AND</span> OrderStatus <span class="keyword">IN</span> (<span class="string">&#x27;Completed&#x27;</span>, <span class="string">&#x27;Cancelled&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除已归档的订单</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> OrderDate <span class="operator">&lt;</span> DATEADD(<span class="keyword">YEAR</span>, <span class="number">-3</span>, GETDATE()) </span><br><span class="line">    <span class="keyword">AND</span> OrderStatus <span class="keyword">IN</span> (<span class="string">&#x27;Completed&#x27;</span>, <span class="string">&#x27;Cancelled&#x27;</span>);</span><br></pre></td></tr></table></figure><p>首先将符合条件的订单数据插入到 <code>ArchivedOrders</code> 表，然后再删除原 <code>Orders</code> 表中的这些数据。这样可以保持主表的清洁，减少存储压力，并保留历史数据。</p><h4 id="3-使用触发器自动清理无用数据"><a href="#3-使用触发器自动清理无用数据" class="headerlink" title="3. 使用触发器自动清理无用数据"></a>3. 使用触发器自动清理无用数据</h4><p>为了自动化清理操作，可以使用数据库触发器（Trigger），例如，在每次插入数据时检查数据是否超期，如果超期则触发清理操作。触发器可以周期性地执行清理任务。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建触发器，每天检查并删除 3 年前的订单</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> CleanOldOrders</span><br><span class="line"><span class="keyword">ON</span> Orders</span><br><span class="line">AFTER <span class="keyword">INSERT</span>, <span class="keyword">UPDATE</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- 清理过期订单：删除 3 年前的已完成或已取消订单</span></span><br><span class="line">    <span class="keyword">DELETE</span> <span class="keyword">FROM</span> Orders</span><br><span class="line">    <span class="keyword">WHERE</span> OrderDate <span class="operator">&lt;</span> DATEADD(<span class="keyword">YEAR</span>, <span class="number">-3</span>, GETDATE()) </span><br><span class="line">        <span class="keyword">AND</span> OrderStatus <span class="keyword">IN</span> (<span class="string">&#x27;Completed&#x27;</span>, <span class="string">&#x27;Cancelled&#x27;</span>);</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>此触发器将在 <code>Orders</code> 表每次执行插入或更新操作时触发，自动检查并清理过期的订单。</p><h4 id="4-分批次清理无用数据"><a href="#4-分批次清理无用数据" class="headerlink" title="4. 分批次清理无用数据"></a>4. 分批次清理无用数据</h4><p>如果订单数据量非常大，直接删除可能会导致性能瓶颈或数据库锁定问题。在这种情况下，可以分批次删除数据，以减少单次删除操作的负载。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@BatchSize</span> <span class="type">INT</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@StartRow</span> <span class="type">INT</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@TotalRows</span> <span class="type">INT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 计算需要删除的记录数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@TotalRows</span> <span class="operator">=</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> OrderDate <span class="operator">&lt;</span> DATEADD(<span class="keyword">YEAR</span>, <span class="number">-3</span>, GETDATE()) </span><br><span class="line">    <span class="keyword">AND</span> OrderStatus <span class="keyword">IN</span> (<span class="string">&#x27;Completed&#x27;</span>, <span class="string">&#x27;Cancelled&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分批次删除</span></span><br><span class="line">WHILE <span class="variable">@StartRow</span> <span class="operator">&lt;</span> <span class="variable">@TotalRows</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- 批量删除 1000 条数据</span></span><br><span class="line">    <span class="keyword">DELETE</span> TOP (<span class="variable">@BatchSize</span>) <span class="keyword">FROM</span> Orders</span><br><span class="line">    <span class="keyword">WHERE</span> OrderDate <span class="operator">&lt;</span> DATEADD(<span class="keyword">YEAR</span>, <span class="number">-3</span>, GETDATE()) </span><br><span class="line">        <span class="keyword">AND</span> OrderStatus <span class="keyword">IN</span> (<span class="string">&#x27;Completed&#x27;</span>, <span class="string">&#x27;Cancelled&#x27;</span>)</span><br><span class="line">        <span class="keyword">AND</span> OrderID <span class="operator">&gt;</span> <span class="variable">@StartRow</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 更新已删除的行数</span></span><br><span class="line">    <span class="keyword">SET</span> <span class="variable">@StartRow</span> <span class="operator">=</span> <span class="variable">@StartRow</span> <span class="operator">+</span> <span class="variable">@BatchSize</span>;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><p>通过分批次处理删除操作，每次删除少量记录，减少对数据库性能的影响，并避免长时间锁定表。</p><h4 id="5-使用作业调度器定期清理无用数据"><a href="#5-使用作业调度器定期清理无用数据" class="headerlink" title="5. 使用作业调度器定期清理无用数据"></a>5. 使用作业调度器定期清理无用数据</h4><p>如果您使用的是 SQL Server，可以使用作业调度器（SQL Server Agent）定期执行清理任务。首先，您可以创建一个存储过程来执行数据清理操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> CleanOldOrders</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DELETE</span> <span class="keyword">FROM</span> Orders</span><br><span class="line">    <span class="keyword">WHERE</span> OrderDate <span class="operator">&lt;</span> DATEADD(<span class="keyword">YEAR</span>, <span class="number">-3</span>, GETDATE()) </span><br><span class="line">        <span class="keyword">AND</span> OrderStatus <span class="keyword">IN</span> (<span class="string">&#x27;Completed&#x27;</span>, <span class="string">&#x27;Cancelled&#x27;</span>);</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>然后，在 SQL Server Management Studio 中设置定期作业（例如每天午夜运行该存储过程），这样可以确保无用数据定期清理。</p><h3 id="小结一下-7"><a href="#小结一下-7" class="headerlink" title="小结一下"></a>小结一下</h3><p>清理无用数据不仅有助于节省存储空间，还能提高数据库性能。根据实际业务需求，我们可以选择删除、归档或分批处理的方式来清理数据。特别是对于大数据量的表，分批清理和定期作业调度可以有效减少系统的负担。</p><h2 id="9-使用缓存"><a href="#9-使用缓存" class="headerlink" title="9. 使用缓存"></a>9. 使用缓存</h2><ul><li><strong>缓存常用查询结果</strong>：对于高频次查询，可以将查询结果缓存到内存中，避免每次查询都去数据库中查找。</li><li><strong>应用层缓存</strong>：使用 Redis 或 Memcached 等缓存系统，将一些常用数据缓存在内存中，从而减少数据库访问频率。</li></ul><p>在实际业务中，缓存是提高系统性能的常用手段，特别是对于高频访问的热点数据，通过将其存储在缓存中，可以减少数据库查询的次数和压力，提高响应速度。</p><h3 id="业务场景-4"><a href="#业务场景-4" class="headerlink" title="业务场景"></a>业务场景</h3><p>假设我们有一个电商平台，用户在浏览商品详情时，频繁地查询商品的基本信息（如价格、库存、描述等）。由于商品信息变化较少，而查询请求频繁，因此将商品信息缓存起来能够有效提高系统的性能。</p><p>我们使用 Redis 作为缓存数据库，常见的做法是：当查询某个商品时，首先检查缓存中是否存在该商品的详情，如果存在，则直接返回缓存中的数据；如果缓存中没有，则从数据库中查询，并将查询结果存入缓存中，以备下次使用。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li>使用 Redis 存储商品信息。</li><li>设置适当的过期时间（TTL，Time To Live），避免缓存数据过期。</li><li>使用适当的缓存更新策略（例如：每次更新商品信息时更新缓存）。</li></ol><h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="1-设置-Redis-缓存"><a href="#1-设置-Redis-缓存" class="headerlink" title="1. 设置 Redis 缓存"></a>1. 设置 Redis 缓存</h4><p>首先，使用 Redis 的客户端库（如 <code>redis-py</code>）连接 Redis 服务。假设商品信息表为 <code>Products</code>，有字段 <code>ProductID</code>, <code>ProductName</code>, <code>Price</code>, <code>Stock</code>, <code>Description</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 Redis 客户端</span></span><br><span class="line">pip install redis</span><br></pre></td></tr></table></figure><h4 id="2-商品查询和缓存逻辑"><a href="#2-商品查询和缓存逻辑" class="headerlink" title="2. 商品查询和缓存逻辑"></a>2. 商品查询和缓存逻辑</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接 Redis</span></span><br><span class="line">redis_client = redis.StrictRedis(host=<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">6379</span>, db=<span class="number">0</span>, decode_responses=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接 MySQL 数据库</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_db_connection</span>():</span><br><span class="line">    <span class="keyword">return</span> mysql.connector.connect(</span><br><span class="line">        host=<span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">        user=<span class="string">&quot;root&quot;</span>,</span><br><span class="line">        password=<span class="string">&quot;password&quot;</span>,</span><br><span class="line">        database=<span class="string">&quot;ecommerce&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取商品详情</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_product_details</span>(<span class="params">product_id</span>):</span><br><span class="line">    <span class="comment"># 检查缓存</span></span><br><span class="line">    cached_product = redis_client.get(<span class="string">f&quot;product:<span class="subst">&#123;product_id&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> cached_product:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;从缓存中获取商品信息&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> json.loads(cached_product)  <span class="comment"># 反序列化 JSON 数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果缓存中没有，查询数据库</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;从数据库中获取商品信息&quot;</span>)</span><br><span class="line">    connection = get_db_connection()</span><br><span class="line">    cursor = connection.cursor(dictionary=<span class="literal">True</span>)</span><br><span class="line">    cursor.execute(<span class="string">&quot;SELECT * FROM Products WHERE ProductID = %s&quot;</span>, (product_id,))</span><br><span class="line">    product = cursor.fetchone()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果商品存在，缓存到 Redis 中</span></span><br><span class="line">    <span class="keyword">if</span> product:</span><br><span class="line">        redis_client.setex(<span class="string">f&quot;product:<span class="subst">&#123;product_id&#125;</span>&quot;</span>, <span class="number">3600</span>, json.dumps(product))  <span class="comment"># 缓存 1 小时</span></span><br><span class="line">    cursor.close()</span><br><span class="line">    connection.close()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> product</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新商品信息并更新缓存</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update_product_details</span>(<span class="params">product_id, name, price, stock, description</span>):</span><br><span class="line">    <span class="comment"># 更新数据库</span></span><br><span class="line">    connection = get_db_connection()</span><br><span class="line">    cursor = connection.cursor()</span><br><span class="line">    cursor.execute(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        UPDATE Products</span></span><br><span class="line"><span class="string">        SET ProductName = %s, Price = %s, Stock = %s, Description = %s</span></span><br><span class="line"><span class="string">        WHERE ProductID = %s</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>, (name, price, stock, description, product_id))</span><br><span class="line">    connection.commit()</span><br><span class="line">    cursor.close()</span><br><span class="line">    connection.close()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 更新缓存</span></span><br><span class="line">    updated_product = &#123;</span><br><span class="line">        <span class="string">&quot;ProductID&quot;</span>: product_id,</span><br><span class="line">        <span class="string">&quot;ProductName&quot;</span>: name,</span><br><span class="line">        <span class="string">&quot;Price&quot;</span>: price,</span><br><span class="line">        <span class="string">&quot;Stock&quot;</span>: stock,</span><br><span class="line">        <span class="string">&quot;Description&quot;</span>: description</span><br><span class="line">    &#125;</span><br><span class="line">    redis_client.setex(<span class="string">f&quot;product:<span class="subst">&#123;product_id&#125;</span>&quot;</span>, <span class="number">3600</span>, json.dumps(updated_product))  <span class="comment"># 缓存 1 小时</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：查询商品 101 的信息</span></span><br><span class="line">product_info = get_product_details(<span class="number">101</span>)</span><br><span class="line"><span class="built_in">print</span>(product_info)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：更新商品 101 的信息</span></span><br><span class="line">update_product_details(<span class="number">101</span>, <span class="string">&quot;New Product Name&quot;</span>, <span class="number">199.99</span>, <span class="number">50</span>, <span class="string">&quot;Updated description&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h3><ol><li><strong>连接 Redis 和 MySQL：</strong> 使用 <code>redis-py</code> 连接 Redis，使用 <code>mysql.connector</code> 连接 MySQL 数据库。</li><li><strong>查询商品：</strong> 在 <code>get_product_details</code> 方法中，我们首先查询 Redis 缓存，看是否已经缓存了商品信息。如果缓存中存在，则直接返回缓存中的数据；如果缓存中没有，则从 MySQL 数据库中查询，并将查询结果缓存到 Redis 中。</li><li><strong>更新商品信息：</strong> 当商品信息发生变化时（例如商品名称、价格、库存等更新），我们在数据库中更新商品信息后，同时更新 Redis 缓存，以确保缓存数据的最新性。</li><li><strong>缓存设置过期时间：</strong> 使用 <code>setex</code> 方法将商品信息缓存到 Redis 中，并为缓存数据设置过期时间（TTL）。这样可以避免缓存过期数据的存在。</li></ol><h3 id="进一步优化"><a href="#进一步优化" class="headerlink" title="进一步优化"></a>进一步优化</h3><ol><li><strong>缓存穿透：</strong> 在查询时，除了检查缓存是否存在外，还可以添加一些防止缓存穿透的机制，如查询数据库时检查是否存在该商品。如果商品不存在，可以将其设置为 <code>None</code> 或空值，避免多次查询数据库。</li><li><strong>缓存淘汰策略：</strong> Redis 有多种缓存淘汰策略（如 LRU、LFU），可以根据实际业务需求配置 Redis 实例的缓存策略，确保热点数据可以长时间保持在缓存中。</li><li><strong>异步更新缓存：</strong> 在高并发的场景下，更新缓存的操作可能导致性能问题，可以使用队列和异步处理来优化缓存更新的时机，避免频繁更新缓存。</li></ol><h3 id="小结一下-8"><a href="#小结一下-8" class="headerlink" title="小结一下"></a>小结一下</h3><p>通过使用 Redis 缓存，电商平台能够有效提高查询商品信息的性能，减轻数据库负担。根据业务需求，我们可以进一步优化缓存策略和更新机制。</p><h2 id="10-并行查询与并发"><a href="#10-并行查询与并发" class="headerlink" title="10. 并行查询与并发"></a>10. 并行查询与并发</h2><ul><li><strong>启用并行查询</strong>：SQL Server 允许在查询中使用多个 CPU 核心来并行处理。适当调整并行查询的设置（如 <code>max degree of parallelism</code>）可以提高查询性能，尤其是在处理大量数据时。</li><li><strong>优化锁策略</strong>：确保数据库的锁策略合理，避免长时间的锁竞争。可以使用行级锁而不是表级锁，减少阻塞。</li></ul><p>在高并发场景下，使用并行查询可以显著提升数据查询的速度。并行查询的核心思想是将复杂的查询拆分成多个子任务，利用多个 CPU 核心同时处理这些子任务，从而提高整体查询性能。并发则是指在多个任务之间进行切换，使得 CPU 更高效地利用，在某些场景下，通过并发执行多个查询任务可以实现较高的性能。</p><h3 id="业务场景-5"><a href="#业务场景-5" class="headerlink" title="业务场景"></a>业务场景</h3><p>假设我们有一个电商平台，其中存储了大量的订单数据。用户查询订单数据时，可能涉及到多个表的联接、多个条件的筛选等复杂的查询操作。为了提高查询性能，我们可以通过并行查询和并发的方式，针对不同的查询任务进行优化。</p><p>例如，查询订单数据时，查询条件包括订单状态、订单日期范围和用户 ID 等。我们将该查询拆分为多个并行查询，分别查询不同的条件，再将结果合并返回。</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li><strong>并行查询：</strong> 将查询任务拆分成多个子任务，利用多线程或者多进程并行执行每个子任务。</li><li><strong>并发查询：</strong> 使用异步 IO 或者线程池来并发执行多个查询操作。</li></ol><p>我们将使用 Python 的 <code>concurrent.futures</code> 库来实现并行查询，并利用 MySQL 数据库来执行查询操作。</p><h3 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="1-并行查询"><a href="#1-并行查询" class="headerlink" title="1. 并行查询"></a>1. 并行查询</h4><p>我们将查询条件分为多个部分，并行地执行查询操作。例如：分别查询订单状态为 <code>Completed</code> 和 <code>Pending</code> 的订单数据，并行查询。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 MySQL 客户端库</span></span><br><span class="line">pip install mysql-connector-python</span><br><span class="line">import mysql.connector</span><br><span class="line">from concurrent.futures import ThreadPoolExecutor</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接 MySQL 数据库</span></span><br><span class="line">def get_db_connection():</span><br><span class="line">    <span class="built_in">return</span> mysql.connector.connect(</span><br><span class="line">        host=<span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">        user=<span class="string">&quot;root&quot;</span>,</span><br><span class="line">        password=<span class="string">&quot;123123&quot;</span>,</span><br><span class="line">        database=<span class="string">&quot;VGDB&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行查询：查询订单状态为指定状态的订单</span></span><br><span class="line">def query_orders_by_status(status):</span><br><span class="line">    connection = get_db_connection()</span><br><span class="line">    cursor = connection.cursor(dictionary=True)</span><br><span class="line">    query = <span class="string">&quot;SELECT * FROM Orders WHERE OrderStatus = %s&quot;</span></span><br><span class="line">    cursor.execute(query, (status,))</span><br><span class="line">    result = cursor.fetchall()</span><br><span class="line">    cursor.close()</span><br><span class="line">    connection.close()</span><br><span class="line">    <span class="built_in">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行并行查询</span></span><br><span class="line">def fetch_orders():</span><br><span class="line">    statuses = [<span class="string">&#x27;Completed&#x27;</span>, <span class="string">&#x27;Pending&#x27;</span>]  <span class="comment"># 定义我们需要查询的订单状态</span></span><br><span class="line">    <span class="comment"># 使用 ThreadPoolExecutor 并行查询</span></span><br><span class="line">    with ThreadPoolExecutor(max_workers=2) as executor:</span><br><span class="line">        <span class="comment"># 提交查询任务</span></span><br><span class="line">        futures = [executor.submit(query_orders_by_status, status) <span class="keyword">for</span> status <span class="keyword">in</span> statuses]</span><br><span class="line">        <span class="comment"># 获取查询结果</span></span><br><span class="line">        results = [future.result() <span class="keyword">for</span> future <span class="keyword">in</span> futures]</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">return</span> results</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：执行查询</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    orders = fetch_orders()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;查询结果：&quot;</span>, orders)</span><br><span class="line">    <span class="built_in">print</span>(f<span class="string">&quot;查询用时: &#123;time.time() - start_time&#125;秒&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="代码说明-1"><a href="#代码说明-1" class="headerlink" title="代码说明"></a>代码说明</h3><ol><li>**<code>query_orders_by_status</code>**：该方法执行数据库查询，查询指定状态的订单。</li><li>**<code>fetch_orders</code>**：该方法使用 <code>ThreadPoolExecutor</code> 来并行执行多个查询任务。在这里，我们将订单状态 <code>Completed</code> 和 <code>Pending</code> 分别作为任务提交到线程池中并行查询。</li><li>**<code>ThreadPoolExecutor</code>**：我们创建了一个最大工作线程数为 2 的线程池，并使用 <code>submit</code> 提交查询任务。每个查询会在一个独立的线程中执行。</li><li>**<code>future.result()</code>**：获取并行查询任务的返回结果。</li></ol><h4 id="2-并发查询"><a href="#2-并发查询" class="headerlink" title="2. 并发查询"></a>2. 并发查询</h4><p>我们可以通过异步查询或多线程来执行并发查询，适用于数据库查询不会互相依赖的情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="comment"># 异步查询数据库</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">query_orders_by_status_async</span>(<span class="params">status, loop</span>):</span><br><span class="line">    <span class="comment"># 使用 ThreadPoolExecutor 让数据库查询异步执行</span></span><br><span class="line">    result = <span class="keyword">await</span> loop.run_in_executor(<span class="literal">None</span>, query_orders_by_status, status)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行查询：查询订单状态为指定状态的订单</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">query_orders_by_status</span>(<span class="params">status</span>):</span><br><span class="line">    connection = get_db_connection()</span><br><span class="line">    cursor = connection.cursor(dictionary=<span class="literal">True</span>)</span><br><span class="line">    query = <span class="string">&quot;SELECT * FROM Orders WHERE OrderStatus = %s&quot;</span></span><br><span class="line">    cursor.execute(query, (status,))</span><br><span class="line">    result = cursor.fetchall()</span><br><span class="line">    cursor.close()</span><br><span class="line">    connection.close()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 异步并发查询</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fetch_orders_concurrently</span>():</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    statuses = [<span class="string">&#x27;Completed&#x27;</span>, <span class="string">&#x27;Pending&#x27;</span>, <span class="string">&#x27;Shipped&#x27;</span>]  <span class="comment"># 查询多个状态的订单</span></span><br><span class="line">    tasks = [query_orders_by_status_async(status, loop) <span class="keyword">for</span> status <span class="keyword">in</span> statuses]</span><br><span class="line">    orders = <span class="keyword">await</span> asyncio.gather(*tasks)  <span class="comment"># 等待所有任务完成</span></span><br><span class="line">    <span class="keyword">return</span> orders</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：执行并发查询</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    asyncio.run(fetch_orders_concurrently())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;查询用时: <span class="subst">&#123;time.time() - start_time&#125;</span>秒&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="代码说明-2"><a href="#代码说明-2" class="headerlink" title="代码说明"></a>代码说明</h3><ol><li>**<code>query_orders_by_status_async</code>**：此方法使用 <code>loop.run_in_executor</code> 来将数据库查询操作异步化。通过这种方式，尽管数据库查询是阻塞操作，我们可以并发地执行多个查询。</li><li>**<code>asyncio.gather</code>**：将多个异步任务组合在一起，等待所有任务完成后再返回结果。</li><li>**<code>asyncio.run</code>**：用于启动事件循环并执行异步查询。</li></ol><h3 id="进一步优化-1"><a href="#进一步优化-1" class="headerlink" title="进一步优化"></a>进一步优化</h3><ol><li><strong>线程池大小</strong>：根据业务需求，调整 <code>ThreadPoolExecutor</code> 中的 <code>max_workers</code> 参数。如果任务非常多，可以适当增加线程池大小，但要注意不要过多，以免影响系统性能。</li><li><strong>连接池</strong>：对于数据库操作，可以使用数据库连接池来优化数据库连接的管理。这样可以避免每次查询都建立新的数据库连接，提高性能。</li><li><strong>分页查询</strong>：如果查询结果非常庞大，可以通过分页查询来减小每次查询的数据量，进一步提高性能。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>并行查询</strong>：通过将查询任务拆分为多个子任务，并行地处理，可以显著提高查询性能。</li><li><strong>并发查询</strong>：适用于在多个查询任务之间进行并发执行，无需等待每个查询任务逐个完成，可以加快整体查询速度。</li></ul><p>通过结合并行查询和并发查询策略，我们可以显著提高电商平台或其他业务系统的查询响应速度，尤其是在高并发的环境中，保证系统的高效性。</p><h2 id="11-SQL-Server-实例优化"><a href="#11-SQL-Server-实例优化" class="headerlink" title="11. SQL Server 实例优化"></a>11. SQL Server 实例优化</h2><ul><li><strong>定期重启 SQL Server 实例</strong>：如果 SQL Server 长时间运行，可能会导致缓存过多或内存泄漏等问题，定期重启可以帮助释放资源并优化性能。</li><li><strong>启用压缩</strong>：SQL Server 提供数据压缩功能，可以节省存储空间，并提高查询性能，尤其是在读取数据时。</li></ul><p>SQL Server 实例优化是提升数据库整体性能的一个重要方面。在大型业务系统中，SQL Server 的性能往往直接影响到整个应用的响应速度和稳定性。实例优化包括硬件资源的合理配置、SQL Server 配置参数的优化、内存和 I&#x2F;O 管理、查询优化以及监控等方面。</p><p>假设我们有一个在线电商平台，业务量很大，包含大量的商品、订单、用户等数据。我们需要对 SQL Server 实例进行优化，以确保高效的查询性能、稳定的事务处理和快速的数据读取能力。</p><h3 id="1-硬件配置优化"><a href="#1-硬件配置优化" class="headerlink" title="1. 硬件配置优化"></a>1. 硬件配置优化</h3><p>SQL Server 实例的性能在很大程度上取决于底层硬件的配置，尤其是内存、CPU、磁盘等资源。</p><ul><li><strong>内存</strong>：SQL Server 是一个内存密集型应用，内存越大，缓存命中率越高，查询性能也越好。</li><li><strong>CPU</strong>：更多的 CPU 核心可以处理更多并发请求。</li><li><strong>磁盘</strong>：SSD 驱动器在磁盘 I&#x2F;O 性能方面要优于传统硬盘，尤其是在大型数据库的读写操作中。</li></ul><h3 id="2-SQL-Server-配置优化"><a href="#2-SQL-Server-配置优化" class="headerlink" title="2. SQL Server 配置优化"></a>2. SQL Server 配置优化</h3><p>SQL Server 提供了很多配置参数来调整实例的行为，可以通过这些参数来优化性能。</p><h4 id="配置参数示例"><a href="#配置参数示例" class="headerlink" title="配置参数示例"></a>配置参数示例</h4><ul><li><strong>max degree of parallelism</strong>：控制 SQL Server 查询的并行度。通过合理设置并行度，可以提高多核 CPU 系统的查询效率。</li><li><strong>max server memory</strong>：限制 SQL Server 使用的最大内存量，防止 SQL Server 占用过多内存导致操作系统性能下降。</li><li><strong>cost threshold for parallelism</strong>：设置查询执行的代价阈值，只有当查询的成本超过该值时，SQL Server 才会使用并行执行。</li></ul><h3 id="3-索引优化"><a href="#3-索引优化" class="headerlink" title="3. 索引优化"></a>3. 索引优化</h3><p>索引是提高查询性能的关键，可以根据业务场景为频繁查询的字段创建索引。但过多的索引会影响插入、更新和删除操作的性能，因此需要在查询性能和维护成本之间找到平衡。</p><h3 id="4-查询优化-1"><a href="#4-查询优化-1" class="headerlink" title="4. 查询优化"></a>4. 查询优化</h3><p>对于大型业务系统，查询优化尤为重要。优化查询可以减少数据库的负担，提升响应速度。</p><h4 id="业务场景-6"><a href="#业务场景-6" class="headerlink" title="业务场景"></a>业务场景</h4><p>假设电商平台需要处理大量的订单数据，查询常常涉及到联接多个表，比如查询某个用户在某个时间段内的所有订单。我们可以通过优化 SQL 查询来提高查询速度。</p><h3 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="1-设置-SQL-Server-实例配置参数"><a href="#1-设置-SQL-Server-实例配置参数" class="headerlink" title="1. 设置 SQL Server 实例配置参数"></a>1. 设置 SQL Server 实例配置参数</h4><p>在 SQL Server 实例中，我们可以通过以下 T-SQL 语句来设置一些基本的优化参数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置最大内存使用量为 16 GB</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;max server memory&#x27;</span>, <span class="number">16384</span>;  <span class="comment">-- 单位：MB</span></span><br><span class="line">RECONFIGURE;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置最大并行度为 8 核 CPU</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;max degree of parallelism&#x27;</span>, <span class="number">8</span>;</span><br><span class="line">RECONFIGURE;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置查询的成本阈值为 10</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;cost threshold for parallelism&#x27;</span>, <span class="number">10</span>;</span><br><span class="line">RECONFIGURE;</span><br></pre></td></tr></table></figure><h4 id="2-查询优化-1"><a href="#2-查询优化-1" class="headerlink" title="2. 查询优化"></a>2. 查询优化</h4><p>为了提高查询性能，可以在查询时使用以下技巧：</p><ul><li>避免 SELECT *，仅选择需要的字段。</li><li>使用 JOIN 替代子查询，避免不必要的嵌套查询。</li><li>创建适当的索引来加速查询。</li><li>利用分页查询减少单次查询的数据量。</li></ul><p>以下是一个优化后的查询示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 假设我们需要查询某个用户的订单信息，优化后的 SQL 查询</span></span><br><span class="line"><span class="keyword">SELECT</span> o.OrderID, o.OrderDate, o.TotalAmount, u.UserName</span><br><span class="line"><span class="keyword">FROM</span> Orders o</span><br><span class="line"><span class="keyword">JOIN</span> Users u <span class="keyword">ON</span> o.UserID <span class="operator">=</span> u.UserID</span><br><span class="line"><span class="keyword">WHERE</span> o.OrderDate <span class="keyword">BETWEEN</span> <span class="string">&#x27;2024-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2024-12-31&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> u.UserID <span class="operator">=</span> <span class="number">12345</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> o.OrderDate <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><h4 id="3-索引优化-1"><a href="#3-索引优化-1" class="headerlink" title="3. 索引优化"></a>3. 索引优化</h4><p>为了优化查询，我们可以在 <code>Orders</code> 表的 <code>UserID</code>、<code>OrderDate</code> 字段上创建索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 为 UserID 列创建索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_user_id <span class="keyword">ON</span> Orders(UserID);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为 OrderDate 列创建索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_order_date <span class="keyword">ON</span> Orders(OrderDate);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为 UserID 和 OrderDate 的组合创建复合索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_user_order_date <span class="keyword">ON</span> Orders(UserID, OrderDate);</span><br></pre></td></tr></table></figure><h4 id="4-数据库备份和维护"><a href="#4-数据库备份和维护" class="headerlink" title="4. 数据库备份和维护"></a>4. 数据库备份和维护</h4><p>定期备份和维护数据库可以确保系统在高负载下保持高效。定期的数据库优化任务包括：</p><ul><li>备份数据。</li><li>更新统计信息。</li><li>重建索引。</li></ul><p>以下是一个定期重建索引的示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 重建所有表的索引</span></span><br><span class="line"><span class="keyword">ALTER</span> INDEX <span class="keyword">ALL</span> <span class="keyword">ON</span> Orders REBUILD;</span><br><span class="line"><span class="keyword">ALTER</span> INDEX <span class="keyword">ALL</span> <span class="keyword">ON</span> Users REBUILD;</span><br></pre></td></tr></table></figure><h3 id="5-使用-SQL-Server-的性能监控工具"><a href="#5-使用-SQL-Server-的性能监控工具" class="headerlink" title="5. 使用 SQL Server 的性能监控工具"></a>5. 使用 SQL Server 的性能监控工具</h3><p>SQL Server 提供了一些性能监控工具来帮助识别性能瓶颈。例如，<code>SQL Server Profiler</code> 和 <code>Dynamic Management Views (DMVs)</code> 可以帮助我们实时监控 SQL Server 实例的性能，并根据实际情况进行调优。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看 SQL Server 实例当前的资源使用情况</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sys.dm_exec_requests;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看 SQL Server 实例的内存使用情况</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sys.dm_os_memory_clerks;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看 SQL Server 实例的磁盘 I/O 使用情况</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sys.dm_io_virtual_file_stats(<span class="keyword">NULL</span>, <span class="keyword">NULL</span>);</span><br></pre></td></tr></table></figure><h3 id="小结一下-9"><a href="#小结一下-9" class="headerlink" title="小结一下"></a>小结一下</h3><ol><li><strong>硬件优化</strong>：合理配置 CPU、内存和磁盘，提升 SQL Server 实例的性能。</li><li><strong>实例配置优化</strong>：通过配置 SQL Server 的参数，如内存限制、并行度等，优化性能。</li><li><strong>索引优化</strong>：合理设计索引结构，提高查询效率。</li><li><strong>查询优化</strong>：使用高效的 SQL 查询语句，避免不必要的计算和 I&#x2F;O 操作。</li><li><strong>定期维护和备份</strong>：定期进行数据库维护和备份，确保系统稳定运行。</li></ol><p>通过对 SQL Server 实例的优化，可以显著提升数据库的性能，确保电商平台在高并发、高负载的情况下仍能保持高效响应。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>以上11种优化方案供你参考，优化 SQL Server 数据库性能得从多个方面着手，包括硬件配置、数据库结构、查询优化、索引管理、分区分表、并行处理等。通过合理的索引、查询优化、数据分区等技术，可以在数据量增大时保持较好的性能。同时，定期进行数据库维护和清理，保证数据库高效运行。关注威哥爱编程，V哥做你的技术门童。</p><p>本文来自博客园，作者：<a href="https://www.cnblogs.com/wgjava/">威哥爱编程</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/wgjava/p/18534481">https://www.cnblogs.com/wgjava/p/18534481</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;[南月晨的blog](&lt;a href=&quot;https://leiyu-code.github.io/&quot;&gt;南月晨的博客 (leiyu-code.github.io)&lt;/a&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;leiyu-code.github.io&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.linuxcool.com/&quot;&gt;Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h4&gt;&lt;p&gt;在 SQL Server 中，当数据量增大时，数据库的性能可能会受到影响，导致查询速度变慢、响应时间变长等问题。为了应对大量数据，以下是一些常用的优化策略和案例详解。&lt;/p&gt;
&lt;h2 id=&quot;1-索引优化&quot;&gt;&lt;a href=&quot;#1-索引优化&quot; class=&quot;headerlink&quot; title=&quot;1. 索引优化&quot;&gt;&lt;/a&gt;1. 索引优化&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;创建索引&lt;/strong&gt;：索引可以显著提高查询速度，特别是在使用 &lt;code&gt;WHERE&lt;/code&gt;、&lt;code&gt;JOIN&lt;/code&gt; 和 &lt;code&gt;ORDER BY&lt;/code&gt; 子句时。为常用的查询字段（尤其是筛选条件字段）创建合适的索引。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;选择合适的索引类型&lt;/strong&gt;：使用聚集索引（Clustered Index）和非聚集索引（Non-clustered Index）来优化查询性能。聚集索引适用于排序、范围查询等，而非聚集索引适用于单一列或组合列的查询。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;避免过多索引&lt;/strong&gt;：虽然索引能提高查询性能，但过多的索引会增加更新、插入和删除操作的成本，因此要平衡索引的数量和性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 SQL Server 中，索引优化是提高查询性能的重要手段。以下是一个具体的业务场景，假设我们有一个销售订单系统，订单表 &lt;code&gt;Orders&lt;/code&gt; 需要根据不同的查询需求来进行索引优化。&lt;/p&gt;
&lt;h3 id=&quot;业务场景&quot;&gt;&lt;a href=&quot;#业务场景&quot; class=&quot;headerlink&quot; title=&quot;业务场景&quot;&gt;&lt;/a&gt;业务场景&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;查询需求1：按 &lt;code&gt;CustomerID&lt;/code&gt; 和 &lt;code&gt;OrderDate&lt;/code&gt; 查询订单信息。&lt;/li&gt;
&lt;li&gt;查询需求2：按 &lt;code&gt;ProductID&lt;/code&gt; 查询所有相关的订单。&lt;/li&gt;
&lt;li&gt;查询需求3：查询某一订单的详细信息（通过 &lt;code&gt;OrderID&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于这些需求，我们将为 &lt;code&gt;Orders&lt;/code&gt; 表创建索引，并展示如何选择合适的索引类型。&lt;/p&gt;
&lt;h3 id=&quot;1-创建表-Orders&quot;&gt;&lt;a href=&quot;#1-创建表-Orders&quot; class=&quot;headerlink&quot; title=&quot;1. 创建表 Orders&quot;&gt;&lt;/a&gt;1. 创建表 &lt;code&gt;Orders&lt;/code&gt;&lt;/h3&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;TABLE&lt;/span&gt; Orders (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    OrderID &lt;span class=&quot;type&quot;&gt;INT&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;PRIMARY&lt;/span&gt; KEY,         &lt;span class=&quot;comment&quot;&gt;-- 主键索引，自动创建聚集索引&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CustomerID &lt;span class=&quot;type&quot;&gt;INT&lt;/span&gt;,                  &lt;span class=&quot;comment&quot;&gt;-- 客户ID&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    OrderDate DATETIME,              &lt;span class=&quot;comment&quot;&gt;-- 订单日期&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ProductID &lt;span class=&quot;type&quot;&gt;INT&lt;/span&gt;,                   &lt;span class=&quot;comment&quot;&gt;-- 产品ID&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TotalAmount &lt;span class=&quot;type&quot;&gt;DECIMAL&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;18&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;),      &lt;span class=&quot;comment&quot;&gt;-- 订单总金额&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Status &lt;span class=&quot;type&quot;&gt;VARCHAR&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;)               &lt;span class=&quot;comment&quot;&gt;-- 订单状态&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="workNote" scheme="http://example.com/categories/workNote/"/>
    
    
    <category term="database" scheme="http://example.com/tags/database/"/>
    
    <category term="sqlserver" scheme="http://example.com/tags/sqlserver/"/>
    
  </entry>
  
  <entry>
    <title>数据库损坏或置疑中间件连接不了数据库</title>
    <link href="http://example.com/2024/11/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BD%AE%E7%96%91/"/>
    <id>http://example.com/2024/11/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BD%AE%E7%96%91/</id>
    <published>2024-11-12T02:10:06.000Z</published>
    <updated>2024-11-12T02:50:42.225Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p><p>leiyu-code.github.io</p><p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p>数据库变为可疑状态通常是由于突然断电、服务器死机或强制关机等原因导致的。为了避免这种情况，建议定期备份数据库，确保有完整的备份文件。此外，确保服务器稳定运行，避免不必要的关机操作，可以减少数据库损坏的风险</p><p><em><strong>1、最简单的解决方法是用备份的数据库文件恢复数据库</strong></em></p><p><em><strong>2、用以下语句可以修复数据库</strong></em></p><span id="more"></span><p>先断开与网络的连接</p><p>将可疑的数据库修改为紧急状态，以便进行修复操作。可以使用以下SQL语句实现：<br><code>ALTER DATABASE 数据库名 SET EMERGENCY</code><br>执行此操作后，数据库会变为红色紧急状态，此时可以看到数据库的结构和数据，但无法进行备份等操作</p><p>接下来，将数据库设置为单用户模式，以便进行修复：<br><code>ALTER DATABASE 数据库名 SET SINGLE_USER</code><br>在单用户模式下，只有一个用户连接，这有助于避免并发问题，可以在后面加个WITH ROLLBACK IMMEDIATE从句立刻回滚未提交的修改</p><p>使用DBCC CHECKDB命令检查并修复数据库。此命令可以检测数据库的结构错误，并尝试修复它们。使用以下语句：<br><code>DBCC CHECKDB(数据库名, REPAIR_ALLOW_DATA_LOSS)</code><br>注意，使用此参数可能会造成数据丢失</p><p>将数据库恢复为多用户模式，允许正常访问：<br><code>ALTER DATABASE 数据库名 SET MULTI_USER</code></p><p>确保数据库设置为在线状态，以便进行正常的读写操作：<br><code>ALTER DATABASE 数据库名 SET ONLINE</code></p><p>退出数据库管理工具，重启sql服务<br>cmd命令   service.msc<br>停止MSSQLSERVER服务，再启动MSSQLSERVER服务</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;[南月晨的blog](&lt;a href=&quot;https://leiyu-code.github.io/&quot;&gt;南月晨的博客 (leiyu-code.github.io)&lt;/a&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;leiyu-code.github.io&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.linuxcool.com/&quot;&gt;Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h4&gt;&lt;p&gt;数据库变为可疑状态通常是由于突然断电、服务器死机或强制关机等原因导致的。为了避免这种情况，建议定期备份数据库，确保有完整的备份文件。此外，确保服务器稳定运行，避免不必要的关机操作，可以减少数据库损坏的风险&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;1、最简单的解决方法是用备份的数据库文件恢复数据库&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;2、用以下语句可以修复数据库&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="workNote" scheme="http://example.com/categories/workNote/"/>
    
    
    <category term="database" scheme="http://example.com/tags/database/"/>
    
    <category term="sqlserver" scheme="http://example.com/tags/sqlserver/"/>
    
  </entry>
  
  <entry>
    <title>数据库日志文件.ldf文件过大</title>
    <link href="http://example.com/2024/09/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A5%E5%BF%97%E6%95%B0%E6%8D%AE%E8%BF%87%E5%A4%A7/"/>
    <id>http://example.com/2024/09/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A5%E5%BF%97%E6%95%B0%E6%8D%AE%E8%BF%87%E5%A4%A7/</id>
    <published>2024-09-06T08:28:06.000Z</published>
    <updated>2024-09-11T02:15:39.618Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p><p>leiyu-code.github.io</p><p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p><em><strong>数据库LDF日志文件存储的是数据库操作数据的信息，其中包含有(新增数据、修改数据、删除数据等）</strong></em></p><p>ldf文件日志过大会占满整个硬盘分区，导致数据库管理软件进不去或数据库报错</p><h4 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h4><p><strong>收缩SQL2008数据库</strong></p><p>1，点击电脑左下角开始-Microsoft SQL Server2008 R2-SSMS-Microsoft SQL Server Management Studio,进入SSMS页面后使用Windows身份验证连接上SQL Server。</p><p><a href="https://imgse.com/i/pAmqBh6"><img src="https://s21.ax1x.com/2024/09/11/pAmqBh6.md.png" alt="pAmqBh6.md.png"></a></p><p>2，进入SSMS后在左侧数据库目录中找到需要收缩ldf文件的数据库名称（例如：QFBJZT）然后右键选择“属性”快捷命令。在打开的QFBJZT数据库属性页面单击“选项”标签，恢复模式后下拉菜单中选择“简单”模式，设置好后单击“确定”按钮使设置生效。</p><span id="more"></span><p><a href="https://imgse.com/i/pAmqs1O"><img src="https://s21.ax1x.com/2024/09/11/pAmqs1O.png" alt="pAmqs1O.png"></a></p><p>3，返回SSMS窗口，右键单击目标数据库名称QFBJZT，右键选择任务-收缩-数据库。</p><p><a href="https://imgse.com/i/pAmqycD"><img src="https://s21.ax1x.com/2024/09/11/pAmqycD.png" alt="pAmqycD.png"></a></p><p>4，在收缩数据库页面中无须调整参数，直接单击“确定”按钮开始收缩数据库的操作。日志文件在一些异常情况下往往是恢复数据库的重要依据，收缩数据库操作主要作用是收缩日志大小。所以需要定期进行上述操作，以免数据库日志过大。</p><p><a href="https://imgse.com/i/pAmq0tx"><img src="https://s21.ax1x.com/2024/09/11/pAmq0tx.png" alt="pAmq0tx.png"></a></p><p>5，最后再次右键数据库QFBJZT选择“属性”，在打开的QFBJZT数据库属性页面单击“选项”标签，恢复模式后下拉菜单中选择回“完整”模式，设置好后单击“确定”按钮使设置生效即可完成收缩数据库日志文件工作。</p><p><a href="https://imgse.com/i/pAmqr9K"><img src="https://s21.ax1x.com/2024/09/11/pAmqr9K.png" alt="pAmqr9K.png"></a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;[南月晨的blog](&lt;a href=&quot;https://leiyu-code.github.io/&quot;&gt;南月晨的博客 (leiyu-code.github.io)&lt;/a&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;leiyu-code.github.io&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.linuxcool.com/&quot;&gt;Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h4&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;数据库LDF日志文件存储的是数据库操作数据的信息，其中包含有(新增数据、修改数据、删除数据等）&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;ldf文件日志过大会占满整个硬盘分区，导致数据库管理软件进不去或数据库报错&lt;/p&gt;
&lt;h4 id=&quot;解决方法：&quot;&gt;&lt;a href=&quot;#解决方法：&quot; class=&quot;headerlink&quot; title=&quot;解决方法：&quot;&gt;&lt;/a&gt;解决方法：&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;收缩SQL2008数据库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1，点击电脑左下角开始-Microsoft SQL Server2008 R2-SSMS-Microsoft SQL Server Management Studio,进入SSMS页面后使用Windows身份验证连接上SQL Server。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://imgse.com/i/pAmqBh6&quot;&gt;&lt;img src=&quot;https://s21.ax1x.com/2024/09/11/pAmqBh6.md.png&quot; alt=&quot;pAmqBh6.md.png&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2，进入SSMS后在左侧数据库目录中找到需要收缩ldf文件的数据库名称（例如：QFBJZT）然后右键选择“属性”快捷命令。在打开的QFBJZT数据库属性页面单击“选项”标签，恢复模式后下拉菜单中选择“简单”模式，设置好后单击“确定”按钮使设置生效。&lt;/p&gt;</summary>
    
    
    
    <category term="workNote" scheme="http://example.com/categories/workNote/"/>
    
    
    <category term="database" scheme="http://example.com/tags/database/"/>
    
    <category term="sqlserver" scheme="http://example.com/tags/sqlserver/"/>
    
  </entry>
  
  <entry>
    <title>王熙凤毒设相思局　贾天祥正照风月鉴</title>
    <link href="http://example.com/2024/09/05/%E7%8E%8B%E7%86%99%E5%87%A4%E6%AF%92%E8%AE%BE%E7%9B%B8%E6%80%9D%E5%B1%80%E3%80%80%E8%B4%BE%E5%A4%A9%E7%A5%A5%E6%AD%A3%E7%85%A7%E9%A3%8E%E6%9C%88%E9%89%B4/"/>
    <id>http://example.com/2024/09/05/%E7%8E%8B%E7%86%99%E5%87%A4%E6%AF%92%E8%AE%BE%E7%9B%B8%E6%80%9D%E5%B1%80%E3%80%80%E8%B4%BE%E5%A4%A9%E7%A5%A5%E6%AD%A3%E7%85%A7%E9%A3%8E%E6%9C%88%E9%89%B4/</id>
    <published>2024-09-05T03:41:06.000Z</published>
    <updated>2024-09-11T02:04:48.571Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p><p><a href="http://leiyu-code.github.io">leiyu-code.github.io</a></p><p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p><h1>《红楼梦》-第12回</h1><h1>王熙凤毒设相思局　贾天祥正照风月鉴</h1><p>​话说凤姐正与平儿说话，只见有人回说：“瑞大爷来了。”凤姐急命“快请进来。”贾瑞见往里让，心中喜出望外，急忙进来，见了凤姐，满面陪笑，连连问好。凤姐儿也假意殷勤，让茶让坐。</p><p>贾瑞见凤姐如此打扮，亦发酥倒，因饧了眼问道：“二哥哥怎么还不回来？”凤姐道：“不知什么原故。”贾瑞笑道：“别是路上有人绊住了脚了，舍不得回来也未可知？”凤姐道：“也未可知。男人家见一个爱一个也是有的。”贾瑞笑道：“嫂子这话说错了，我就不这样。”凤姐笑道：“像你这样的人能有几个呢，十个里也挑不出一个来。”贾瑞听了喜的抓耳挠腮，又道：“嫂子天天也闷的很。”凤姐道：“正是呢，只盼个人来说话解解闷儿。”贾瑞笑道：“我倒天天闲着，天天过来替嫂子解解闲闷可好不好？”凤姐笑道：“你哄我呢，你那里肯往我这里来。”贾瑞道：“我在嫂子跟前，若有一点谎话，天打雷劈！只因素日闻得人说，嫂子是个利害人，在你跟前一点也错不得，所以唬住了我。如今见嫂子最是个有说有笑极疼人的，我怎么不来，----死了也愿意！”凤姐笑道：“果然你是个明白人，比贾蓉两个强远了。我看他那样清秀，只当他们心里明白，谁知竟是两个胡涂虫，一点不知人心。”</p><span id="more"></span><p>贾瑞听了这话，越发撞在心坎儿上，由不得又往前凑了一凑，觑着眼看凤姐带的荷包，然后又问带着什么戒指。凤姐悄悄道：“放尊重着，别叫丫头们看了笑话。”贾瑞如听纶音佛语一般，忙往后退。凤姐笑道：“你该走了。”贾瑞说：“我再坐一坐儿。----好狠心的嫂子。”凤姐又悄悄的道：“大天白日，人来人往，你就在这里也不方便。你且去，等着晚上起了更你来，悄悄的在西边穿堂儿等我。”贾瑞听了，如得珍宝，忙问道：“你别哄我。但只那里人过的多，怎么好躲的？”凤姐道：“你只放心。我把上夜的小厮们都放了假，两边门一关，再没别人了。”贾瑞听了，喜之不尽，忙忙的告辞而去，心内以为得手。</p><p>盼到晚上，果然黑地里摸入荣府，趁掩门时，钻入穿堂。果见漆黑无一人，往贾母那边去的门户已倒锁，只有向东的门未关。贾瑞侧耳听着，半日不见人来，忽听咯噔一声，东边的门也倒关了。贾瑞急的也不敢则声，只得悄悄的出来，将门撼了撼，关的铁桶一般。此时要求出去亦不能够，南北皆是大房墙，要跳亦无攀援。这屋内又是过门风，空落落，现是腊月天气，夜又长，朔风凛凛，侵肌裂骨，一夜几乎不曾冻死。好容易盼到早晨，只见一个老婆子先将东门开了，进去叫西门。贾瑞瞅他背着脸，一溜烟抱着肩跑了出来，幸而天气尚早，人都未起，从后门一径跑回家去。</p><p>原来贾瑞父母早亡，只有他祖父代儒教养。那代儒素日教训最严，不许贾瑞多走一步，生怕他在外吃酒赌钱，有误学业。今忽见他一夜不归，只料定他在外非饮即赌，嫖娼宿妓，那里想到这段公案，因此气了一夜。贾瑞也捻着一把汗，少不得回来撒谎，只说：“往舅舅家去了，天黑了，留我住了一夜。”代儒道：“自来出门，非禀我不敢擅出，如何昨日私自去了？据此亦该打，何况是撒谎。”因此，发狠到底打了三四十扳，不许吃饭，令他跪在院内读文章，定要补出十天的工课来方罢。贾瑞直冻了一夜，今又遭了苦打，且饿着肚子，跪着在风地里读文章，其苦万状。</p><p>此时贾瑞前心犹是未改，再想不到是凤姐捉弄他。过后两日，得了空，便仍来找凤姐。凤姐故意抱怨他失信，贾瑞急的赌身发誓。凤姐因见他自投罗网，少不得再寻别计令他知改，故又约他道：“今日晚上，你别在那里了。你在我这房后小过道子里那间空屋里等我，可别冒撞了。”贾瑞道：“果真？”凤姐道：“谁可哄你，你不信就别来。”贾瑞道：“来，来，来。死也要来！”凤姐道：“这会子你先去罢。”贾瑞料定晚间必妥，此时先去了。凤姐在这里便点兵派将，设下圈套。</p><p>那贾瑞只盼不到晚上，偏生家里亲戚又来了，直等吃了晚饭才去，那天已有掌灯时候。又等他祖父安歇了，方溜进荣府，直往那夹道中屋子里来等着，热锅上的蚂蚁一般，只是干转。左等不见人影，右听也没声响，心下自思：“别是又不来了，又冻我一夜不成？”正自胡猜，只见黑曀曀的来了一个人，贾瑞便意定是凤姐，不管皂白，饿虎一般，等那人刚至门前，便如猫捕鼠的一般，抱住叫道：“亲嫂子，等死我了。”说着，抱到屋里炕上就亲嘴扯裤子，满口里“亲娘”“亲爹”的乱叫起来。那人只不作声。贾瑞拉了自己裤子，硬帮帮的就想顶入。忽见灯光一闪，只见贾蔷举着个捻子照道：“谁在屋里？”只见炕上那人笑道：“瑞大叔要臊我呢。”贾瑞一见，却是贾蓉，真臊的无地可入，不知要怎么样才好，回身就要跑，被贾蔷一把揪住道：“别走！如今琏二嫂已经告到太太跟前，说你无故调戏他。他暂用了个脱身计，哄你在这边等着，太太气死过去，因此叫我来拿你。刚才你又拦住他，没的说，跟我去见太太！”</p><p>贾瑞听了，魂不附体，只说：“好侄儿，只说没有见我，明日我重重的谢你。”贾蔷道：“你若谢我，放你不值什么，只不知你谢我多少？况且口说无凭，写一文契来。”贾瑞道：“这如何落纸呢？”贾蔷道：“这也不妨，写一个赌钱输了外人帐目，借头家银若干两便罢。”贾瑞道：“这也容易。只是此时无纸笔。”贾蔷道：“这也容易。”说罢翻身出来，纸笔现成，拿来命贾瑞写。他两作好作歹，只写了五十两，然后画了押，贾蔷收起来。然后撕逻贾蓉。贾蓉先咬定牙不依，只说：“明日告诉族中的人评评理。”贾瑞急的至于叩头。贾蔷作好作歹的，也写了一张五十两欠契才罢。贾蔷又道：“如今要放你，我就担着不是。老太太那边的门早已关了，老爷正在厅上看南京的东西，那一条路定难过去，如今只好走后门。若这一走，倘或遇见了人，连我也完了。等我们先去哨探哨探，再来领你。这屋你还藏不得，少时就来堆东西。等我寻个地方。”说毕，拉着贾瑞，仍熄了灯，出至院外，摸着大台矶底下，说道：“这窝儿里好，你只蹲着，别哼一声，等我们来再动。”说毕，二人去了。</p><p>贾瑞此时身不由己，只得蹲在那里。心下正盘算，只听头顶上一声响，嗗拉拉一净桶尿粪从上面直泼下来，可巧浇了他一身一头。贾瑞掌不住嗳哟了一声，忙又掩住口，不敢声张，满头满脸浑身皆是尿屎，冰冷打战。只见贾蔷跑来叫：“快走，快走！”贾瑞如得了命，三步两步从后门跑到家里，天已三更，只得叫门。开门人见他这般景况，问是怎的。少不得扯谎说：“黑了，失脚掉在茅厕里了。”一面到了自己房中更衣洗濯，心下方想到是凤姐顽他，因此发一回恨，再想想凤姐的模样儿，又恨不得一时搂在怀内，一夜竟不曾合眼。</p><p>自此满心想凤姐，只不敢往荣府去了。贾蓉两个又常常的来索银子，他又怕祖父知道，正是相思尚且难禁，更又添了债务，日间工课又紧，他二十来岁人，尚未娶亲，迩来想着凤姐，未免有那指头告了消乏等事，更兼两回冻恼奔波，因此三五下里夹攻，不觉就得了一病：心内发膨胀，口中无滋味，脚下如绵，眼中似醋，黑夜作烧，白昼常倦，下溺连精，嗽痰带血。诸如此症，不上一年都添全了。于是不能支持，一头睡倒，合上眼还只梦魂颠倒，满口乱说胡话，惊怖异常。百般请医疗治，诸如肉桂，附子，鳖甲，麦冬，玉竹等药，吃了有几十斤下去，也不见个动静。</p><p>倏又腊尽春回，这病更又沉重。代儒也着了忙，各处请医疗治，皆不见效。因后来吃“独参汤”，代儒如何有这力量，只得往荣府来寻。王夫人命凤姐秤二两给他，凤姐回说：“前儿新近都替老太太配了药，那整的太太又说留着送杨提督的太太配药，偏生昨儿我已送了去了。”王夫人道：“就是咱们这边没了，你打发个人往你婆婆那边问问，或是你珍大哥哥那府里再寻些来，凑着给人家。吃好了，救人一命，也是你的好处。”凤姐听了，也不遣人去寻，只得将些渣末泡须凑了几钱，命人送去，只说：“太太送来的，再也没了。”然后回王夫人，只说：“都寻了来，共凑了有二两送去。”</p><p>那贾瑞此时要命心甚切，无药不吃，只是白花钱，不见效。忽然这日有个跛足道人来化斋，口称专治冤业之症。贾瑞偏生在内就听见了，直着声叫喊说：“快请进那位菩萨来救我！”一面叫，一面在枕上叩首。众人只得带了那道士进来。贾瑞一把拉住，连叫“菩萨救我！”那道士叹道：“你这病非药可医。我有个宝贝与你，你天天看时，此命可保矣。”说毕，从褡裢中取出一面镜子来----两面皆可照人，镜把上面錾着“风月宝鉴”四字----递与贾瑞道：“这物出自太虚幻境空灵殿上，警幻仙子所制，专治邪思妄动之症，有济世保生之功。所以带他到世上，单与那些聪明杰俊，风雅王孙等看照。千万不可照正面，只照他的背面，要紧，要紧！三日后吾来收取，管叫你好了。”说毕，佯常而去，众人苦留不住。</p><p>贾瑞收了镜子，想道：“这道士倒有意思，我何不照一照试试。”想毕，拿起“风月鉴”来，向反面一照，只见一个骷髅立在里面，唬得贾瑞连忙掩了，骂：“道士混帐，如何吓我！----我倒再照照正面是什么。”想着，又将正面一照，只见凤姐站在里面招手叫他。贾瑞心中一喜，荡悠悠的觉得进了镜子，与凤姐云雨一番，凤姐仍送他出来。到了床上，哎哟了一声，一睁眼，镜子从手里掉过来，仍是反面立着一个骷髅。贾瑞自觉汗津津的，底下已遗了一滩精。心中到底不足，又翻过正面来，只见凤姐还招手叫他，他又进去。如此三四次。到了这次，刚要出镜子来，只见两个人走来，拿铁锁把他套住，拉了就走。贾瑞叫道：“让我拿了镜子再走。”----只说了这句，就再不能说话了。</p><p>旁边伏侍贾瑞的众人，只见他先还拿着镜子照，落下来，仍睁开眼拾在手内，末后镜子落下来便不动了。众人上来看看，已没了气。身子底下冰凉渍湿一大滩精，这才忙着穿衣抬床。代儒夫妇哭的死去活来，大骂道士，“是何妖镜！若不早毁此物，遗害于世不小。”遂命架火来烧，只听镜内哭道：“谁叫你们瞧正面了！你们自己以假为真，何苦来烧我？”正哭着，只见那跛足道人从外面跑来，喊道：“谁毁‘风月鉴’，吾来救也！”说着，直入中堂，抢入手内，飘然去了。</p><p>当下，代儒料理丧事，各处去报丧。三日起经，七日发引，寄灵于铁槛寺，日后带回原籍。当下贾家众人齐来吊问，荣国府贾赦赠银二十两，贾政亦是二十两，宁国府贾珍亦有二十两，别者族中贫富不等，或三两五两，不可胜数。另有各同窗家分资，也凑了二三十两。代儒家道虽然淡薄，倒也丰丰富富完了此事。</p><p>谁知这年冬底，林如海的书信寄来，却为身染重疾，写书特来接林黛玉回去。贾母听了，未免又加忧闷，只得忙忙的打点黛玉起身。宝玉大不自在，争奈父女之情，也不好拦劝。于是贾母定要贾琏送他去，仍叫带回来。一应土仪盘缠，不消烦说，自然要妥贴。作速择了日期，贾琏与林黛玉辞别了贾母等，带领仆从，登舟往扬州去了。要知端的，且听下回分解。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;[南月晨的blog](&lt;a href=&quot;https://leiyu-code.github.io/&quot;&gt;南月晨的博客 (leiyu-code.github.io)&lt;/a&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://leiyu-code.github.io&quot;&gt;leiyu-code.github.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.linuxcool.com/&quot;&gt;Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;《红楼梦》-第12回&lt;/h1&gt;
&lt;h1&gt;王熙凤毒设相思局　贾天祥正照风月鉴&lt;/h1&gt;
&lt;p&gt;​		话说凤姐正与平儿说话，只见有人回说：“瑞大爷来了。”凤姐急命“快请进来。”贾瑞见往里让，心中喜出望外，急忙进来，见了凤姐，满面陪笑，连连问好。凤姐儿也假意殷勤，让茶让坐。&lt;/p&gt;
&lt;p&gt;贾瑞见凤姐如此打扮，亦发酥倒，因饧了眼问道：“二哥哥怎么还不回来？”凤姐道：“不知什么原故。”贾瑞笑道：“别是路上有人绊住了脚了，舍不得回来也未可知？”凤姐道：“也未可知。男人家见一个爱一个也是有的。”贾瑞笑道：“嫂子这话说错了，我就不这样。”凤姐笑道：“像你这样的人能有几个呢，十个里也挑不出一个来。”贾瑞听了喜的抓耳挠腮，又道：“嫂子天天也闷的很。”凤姐道：“正是呢，只盼个人来说话解解闷儿。”贾瑞笑道：“我倒天天闲着，天天过来替嫂子解解闲闷可好不好？”凤姐笑道：“你哄我呢，你那里肯往我这里来。”贾瑞道：“我在嫂子跟前，若有一点谎话，天打雷劈！只因素日闻得人说，嫂子是个利害人，在你跟前一点也错不得，所以唬住了我。如今见嫂子最是个有说有笑极疼人的，我怎么不来，----死了也愿意！”凤姐笑道：“果然你是个明白人，比贾蓉两个强远了。我看他那样清秀，只当他们心里明白，谁知竟是两个胡涂虫，一点不知人心。”&lt;/p&gt;</summary>
    
    
    
    <category term="excerpt" scheme="http://example.com/categories/excerpt/"/>
    
    
    <category term="红楼梦" scheme="http://example.com/tags/%E7%BA%A2%E6%A5%BC%E6%A2%A6/"/>
    
    <category term="原文" scheme="http://example.com/tags/%E5%8E%9F%E6%96%87/"/>
    
    <category term="宝物" scheme="http://example.com/tags/%E5%AE%9D%E7%89%A9/"/>
    
  </entry>
  
  <entry>
    <title>用命令行激活windows</title>
    <link href="http://example.com/2024/08/14/%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BF%80%E6%B4%BBwindows/"/>
    <id>http://example.com/2024/08/14/%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BF%80%E6%B4%BBwindows/</id>
    <published>2024-08-14T01:45:06.000Z</published>
    <updated>2024-08-14T01:56:29.984Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p><p><a href="http://leiyu-code.github.io">leiyu-code.github.io</a></p><p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p><p>直接以管理员打开CMD或POWERSHELL:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、slmgr.vbs /upk</span><br><span class="line"><span class="number">2</span>、slmgr /ipk W269N-WFGWX-YVC9B-<span class="number">4</span>J6C9-T83GX</span><br><span class="line"><span class="number">3</span>、slmgr /skms zh.us.to</span><br><span class="line"><span class="number">4</span>、slmgr -ato</span><br></pre></td></tr></table></figure><span id="more"></span><p>要是不行，把第三行改成slmgr -skms <a href="http://kms.03k.org">kms.03k.org</a><br>slmgr.vbs /upk<br>slmgr /ipk M7XTQ-FN8P6-TTKYV-9D4CC-J462D<br>slmgr -skms <a href="http://kms.03k.org">kms.03k.org</a><br>slmgr -ato<br>slmgr.<br>slmgr.vbs /upk<br>slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX<br>slmgr<br>slmgr -skms <a href="http://kms.03k.org">kms.03k.org</a></p><p><a href="https://www.jianshu.com/p/4968e4f494d4">永久激活windows11 - 简书 (jianshu.com)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;[南月晨的blog](&lt;a href=&quot;https://leiyu-code.github.io/&quot;&gt;南月晨的博客 (leiyu-code.github.io)&lt;/a&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://leiyu-code.github.io&quot;&gt;leiyu-code.github.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.linuxcool.com/&quot;&gt;Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;直接以管理员打开CMD或POWERSHELL:&lt;/p&gt;
&lt;figure class=&quot;highlight cmd&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;、slmgr.vbs /upk&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;、slmgr /ipk W269N-WFGWX-YVC9B-&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;J6C9-T83GX&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;、slmgr /skms zh.us.to&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;、slmgr -ato&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Active" scheme="http://example.com/categories/Active/"/>
    
    
    <category term="windows" scheme="http://example.com/tags/windows/"/>
    
    <category term="windows11" scheme="http://example.com/tags/windows11/"/>
    
  </entry>
  
  <entry>
    <title>社区型免费蜜罐-hfish</title>
    <link href="http://example.com/2024/06/23/%E7%A4%BE%E5%8C%BA%E5%9E%8B%E5%85%8D%E8%B4%B9%E8%9C%9C%E7%BD%90-hfish/"/>
    <id>http://example.com/2024/06/23/%E7%A4%BE%E5%8C%BA%E5%9E%8B%E5%85%8D%E8%B4%B9%E8%9C%9C%E7%BD%90-hfish/</id>
    <published>2024-06-23T09:28:06.000Z</published>
    <updated>2024-06-23T09:01:57.385Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p><p><a href="http://leiyu-code.github.io">leiyu-code.github.io</a></p><p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p><h4 id="HFish"><a href="https://hfish.net/#/README?id=hfish%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5">HFish</a></h4><p>HFish是一款社区型免费蜜罐，侧重企业安全场景，从内网失陷检测、外网威胁感知、威胁情报生产三个场景出发，为用户提供可独立操作且实用的功能，通过安全、敏捷、可靠的中低交互蜜罐增加用户在失陷感知和威胁情报领域的能力。</p><p>HFish支持基本网络 服务、OA系统、CRM系统、NAS存储系统、Web服务器、运维平台、安全产品、无线AP、交换机/路由器、邮件系统、IoT设备等90多种蜜罐服务、支持用户制作自定义Web蜜罐、支持流量牵引到免费云蜜网、支持可开关的全端口扫描感知能力、支持可自定义的蜜饵配置、一键部署、跨平台多架构，支持Linux x32/x64/ARM、Windows x32/x64平台和多种国产操作系统、支持龙芯、海光、飞腾、鲲鹏、腾云、兆芯等国产CPU、极低的性能要求、邮件/syslog/webhook/企业微信/钉钉/飞书告警等多项特性，帮助用户降低运维成本，提升运营效率。</p><p>用户需要先部署管理端，再通过管理端内置蜜罐节点或部署新节点：</p><p><a href="https://hfish.net/#/2-2-linux">Linux管理端下载</a></p><p><a href="https://hfish.net/#/2-3-windows">Windows管理端下载</a></p><p><a href="https://hfish.net/#/2-1-docker">Docker镜像下载</a></p><span id="more"></span><p>如果有企业下载需求，您也可以前往<a href="https://hfish.net/#/docs">HFish文档区域</a>下载部署文档方案。</p><h4 id="为什么选择HFish"><a href="https://hfish.net/#/README?id=%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9hfish">为什么选择HFish</a></h4><blockquote><h5 id="免费、简单、安全的蜜罐产品"><a href="https://hfish.net/#/README?id=%E5%85%8D%E8%B4%B9%E3%80%81%E7%AE%80%E5%8D%95%E3%80%81%E5%AE%89%E5%85%A8%E7%9A%84%E8%9C%9C%E7%BD%90%E4%BA%A7%E5%93%81">免费、简单、安全的蜜罐产品</a></h5></blockquote><p>蜜罐通常被定义为具有轻量级检测能力、低误报率的检测产品，同时它也是企业生产本地威胁情报的优质来源之一。HFish可以帮助中小型企业用户在日常安全运营中进行避免告警洪水、低成本的增加威胁感知和情报生产能力。目前，社区的力量正在不断帮助HFish完善自身，共同探索欺骗防御的最佳实践。</p><blockquote><h5 id="安全、敏捷的威胁感知节点"><a href="https://hfish.net/#/README?id=%E5%AE%89%E5%85%A8%E3%80%81%E6%95%8F%E6%8D%B7%E7%9A%84%E5%A8%81%E8%83%81%E6%84%9F%E7%9F%A5%E8%8A%82%E7%82%B9">安全、敏捷的威胁感知节点</a></h5></blockquote><p>HFish被广泛应用于感知办公内网、生产环境、云内网及其他环境失陷主机横向移动、员工账号外泄、扫描和探测行为、私有情报生产甚至内部演练和安全意识培训，HFish的多种告警输出形式与态感、NDR、XDR或日志平台结合，极大拓展检测视野。</p><h4 id="HFish架构"><a href="https://hfish.net/#/README?id=hfish%E6%9E%B6%E6%9E%84">HFish架构</a></h4><p>HFish采用B/S架构，HFish由管理端（server）和节点端（client）组成，管理端用来生成和管理节点端，并接收、分析和展示节点端回传的数据，节点端接受管理端的控制并负责构建蜜罐服务。</p><p>在HFish中，<strong>管理端</strong>只用于<strong>数据的分析和展示</strong>，<strong>节点端</strong>进行<strong>虚拟蜜罐</strong>，最后由<strong>蜜罐来承受攻击</strong>。</p><p>HFish各模块关系图</p><p><img src="https://hfish.net/images/20210616174908.png" alt="image-20210611130621311"></p><h4 id="我们的故事"><a href="https://hfish.net/#/README?id=%E6%88%91%E4%BB%AC%E7%9A%84%E6%95%85%E4%BA%8B">我们的故事</a></h4><p>2019年的8月7日，我们发布了自己的第一款开源蜜罐HFish，在之后的16个月里，HFish在Github上获得2.6k个star，在Gitee上成为安全类目TOP5的GVP项目。</p><p>2021年2月9日，融合社区反馈和过去2年的思考，我们开启了全新概念的威胁捕捉和诱骗系统HFish v2版本，并宣布采用闭源共享方式向所有用户免费授权使用。</p><h4 id="联系我们"><a href="https://hfish.net/#/README?id=%E8%81%94%E7%B3%BB%E6%88%91%E4%BB%AC">联系我们</a></h4><p>HFish是北京微步在线科技有限公司旗下社区型免费蜜罐产品</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">联系地址：北京市海淀区苏州街49号盈智大厦4层</span><br><span class="line">联系电话：400-030-1051复制失败成功</span><br></pre></td></tr></table></figure><p><img src="http://img.threatbook.cn/hfish/image-20220729162931543.png" alt="image-20220729162931543"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;[南月晨的blog](&lt;a href=&quot;https://leiyu-code.github.io/&quot;&gt;南月晨的博客 (leiyu-code.github.io)&lt;/a&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://leiyu-code.github.io&quot;&gt;leiyu-code.github.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.linuxcool.com/&quot;&gt;Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;HFish&quot;&gt;&lt;a href=&quot;https://hfish.net/#/README?id=hfish%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5&quot;&gt;HFish&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;HFish是一款社区型免费蜜罐，侧重企业安全场景，从内网失陷检测、外网威胁感知、威胁情报生产三个场景出发，为用户提供可独立操作且实用的功能，通过安全、敏捷、可靠的中低交互蜜罐增加用户在失陷感知和威胁情报领域的能力。&lt;/p&gt;
&lt;p&gt;HFish支持基本网络 服务、OA系统、CRM系统、NAS存储系统、Web服务器、运维平台、安全产品、无线AP、交换机/路由器、邮件系统、IoT设备等90多种蜜罐服务、支持用户制作自定义Web蜜罐、支持流量牵引到免费云蜜网、支持可开关的全端口扫描感知能力、支持可自定义的蜜饵配置、一键部署、跨平台多架构，支持Linux x32/x64/ARM、Windows x32/x64平台和多种国产操作系统、支持龙芯、海光、飞腾、鲲鹏、腾云、兆芯等国产CPU、极低的性能要求、邮件/syslog/webhook/企业微信/钉钉/飞书告警等多项特性，帮助用户降低运维成本，提升运营效率。&lt;/p&gt;
&lt;p&gt;用户需要先部署管理端，再通过管理端内置蜜罐节点或部署新节点：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://hfish.net/#/2-2-linux&quot;&gt;Linux管理端下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://hfish.net/#/2-3-windows&quot;&gt;Windows管理端下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://hfish.net/#/2-1-docker&quot;&gt;Docker镜像下载&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="safe" scheme="http://example.com/categories/safe/"/>
    
    
    <category term="hfish" scheme="http://example.com/tags/hfish/"/>
    
  </entry>
  
  <entry>
    <title>windows命令-route</title>
    <link href="http://example.com/2024/06/23/windows%E5%91%BD%E4%BB%A4%E2%80%94route/"/>
    <id>http://example.com/2024/06/23/windows%E5%91%BD%E4%BB%A4%E2%80%94route/</id>
    <published>2024-06-23T07:32:06.000Z</published>
    <updated>2024-06-23T07:59:50.393Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p><p>leiyu-code.github.io</p><p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p><h4 id="route命令"><a href="#route命令" class="headerlink" title="route命令"></a><em><strong>route命令</strong></em></h4><p>  route命令用于显示和操作IP路由表。要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者同时位于两个网络的网关来实现。windows环境下route命令常用于多网卡终端，默认路由指向连接访问互联网的网卡，静态路由指向内网网卡。</p><span id="more"></span><h5 id="1、获取命令帮助"><a href="#1、获取命令帮助" class="headerlink" title="1、获取命令帮助"></a>1、获取命令帮助</h5><p>route –help或者route命令获取帮助 </p><p><a href="https://imgse.com/i/pkr05VI"><img src="https://s21.ax1x.com/2024/06/23/pkr05VI.png" alt="pkr05VI.png"></a></p><h5 id="2、查看路由表"><a href="#2、查看路由表" class="headerlink" title="2、查看路由表"></a>2、查看路由表</h5><p>route print命令查看主机路由表，可以使用route print -4查看ipv4 路由表。 </p><p><a href="https://imgse.com/i/pkr0hqA"><img src="https://s21.ax1x.com/2024/06/23/pkr0hqA.png" alt="pkr0hqA.png"></a></p><h5 id="3、显示某网段路由"><a href="#3、显示某网段路由" class="headerlink" title="3、显示某网段路由"></a>3、显示某网段路由</h5><p>route print 192.168.3*显示192.168.3开头的路由段 </p><p><a href="https://imgse.com/i/pkr0frd"><img src="https://s21.ax1x.com/2024/06/23/pkr0frd.png" alt="pkr0frd.png"></a></p><h5 id="4、添加一条静态路由"><a href="#4、添加一条静态路由" class="headerlink" title="4、添加一条静态路由"></a>4、添加一条静态路由</h5><p>route add添加一条路由，此操作需要使用administrator管理员权限。 </p><p><a href="https://imgse.com/i/pkr02xe"><img src="https://s21.ax1x.com/2024/06/23/pkr02xe.png" alt="pkr02xe.png"></a></p><h5 id="5、修改一条路由"><a href="#5、修改一条路由" class="headerlink" title="5、修改一条路由"></a>5、修改一条路由</h5><p>route change修改路由网关或者跃点数。 </p><p><a href="https://imgse.com/i/pkr0WKH"><img src="https://s21.ax1x.com/2024/06/23/pkr0WKH.png" alt="pkr0WKH.png"></a></p><h5 id="6、删除一条路由"><a href="#6、删除一条路由" class="headerlink" title="6、删除一条路由"></a>6、删除一条路由</h5><p>route delete删除一条路由 </p><p><a href="https://imgse.com/i/pkr0Iat"><img src="https://s21.ax1x.com/2024/06/23/pkr0Iat.png" alt="pkr0Iat.png"></a></p><h5 id="7、永久添加一条路由"><a href="#7、永久添加一条路由" class="headerlink" title="7、永久添加一条路由"></a>7、永久添加一条路由</h5><p>route add ipnet mask x.x.x.0 gateway -p添加永久路由 </p><p><a href="https://imgse.com/i/pkr0oIP"><img src="https://s21.ax1x.com/2024/06/23/pkr0oIP.png" alt="pkr0oIP.png"></a></p><p><em><strong>使用语法及参数说明</strong></em></p><h5 id="1、使用语法"><a href="#1、使用语法" class="headerlink" title="1、使用语法"></a>1、使用语法</h5><blockquote><p> 用法：ROUTE [-f] [-p] [-4|-6] command [destination] [MASK netmask] [gateway] [METRIC metric] [IF interface] </p></blockquote><h5 id="2、参数说明"><a href="#2、参数说明" class="headerlink" title="2、参数说明"></a>2、参数说明</h5><table><thead><tr><th align="left">参数</th><th align="left">参数说明</th></tr></thead><tbody><tr><td align="left">-f</td><td align="left">清除所有网关项的路由表。如果与某个命令结合使用，在运行该命令前，应清除路由表。</td></tr><tr><td align="left">-p</td><td align="left">与 ADD 命令结合使用时，将路由设置为在系统引导期间保持不变。默认情况下，重新启动系统时，不保存路由。忽略所有其他命令，这始终会影响相应的永久路由。Windows 95不支持此选项。</td></tr><tr><td align="left">-4</td><td align="left">强制使用 IPv4。</td></tr><tr><td align="left">-6</td><td align="left">强制使用 IPv6。</td></tr><tr><td align="left">command</td><td align="left">其中之一: PRINT 打印路由  ADD 添加路由  DELETE 删除路由  CHANGE 修改现有路由</td></tr><tr><td align="left">destination</td><td align="left">指定主机。</td></tr><tr><td align="left">MASK</td><td align="left">指定下一个参数为“网络掩码”值。</td></tr><tr><td align="left">netmask</td><td align="left">指定此路由项的子网掩码值。如果未指定，其默认设置为 255.255.255.255。</td></tr><tr><td align="left">gateway</td><td align="left">指定网关。</td></tr><tr><td align="left">interface</td><td align="left">指定路由的接口号码。</td></tr><tr><td align="left">METRIC</td><td align="left">指定跃点数，例如目标的成本。</td></tr></tbody></table><hr><p><em><strong>实例</strong></em></p><p>需求描述：<br>    1. Win10, 网卡1接外网，网卡2接内网，只能Ping通外网无法Ping通内网。<br>        如果禁用网卡1(外网)，即可Ping通网卡2（内网）</p><ol start="2"><li>备注：<br>① 这里的网卡对有线网卡或无线网卡都适用；<br>②Win10版本 64位1909;<br>③WIN7可以在“网络和共享中心”——“更改适配器设置”——“网络设置中界面中，按ALT键”调出隐藏菜单栏——在选项“高级-高级设置”中，可以手动调整网卡优先级。<br>But，Win10不可以，取消了，只能通过修改接口跃点数实现（不建议）。</li><li>解决方法：静态路由——只针对有限数量的IP<br>Eg. 网卡1网段192.168.20，网卡2网段10.19.20，只能Ping通网段1,需要和网段2的IP（11.20.203.5）建立通讯，那就在CMD命令中增加一个路由：<br>route -p add 11.20.203.5(目标IP) mask 255.255.255.0(子网掩码) 192.168.20.254（网关）<br>注意：以管理员运行CMD，运行完提示完成后，必须重启。</li></ol><p><a href="https://javaforall.cn/161116.html">https://javaforall.cn/161116.html</a></p><p>原文链接：<a href="https://javaforall.cn/">https://javaforall.cn</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;[南月晨的blog](&lt;a href=&quot;https://leiyu-code.github.io/&quot;&gt;南月晨的博客 (leiyu-code.github.io)&lt;/a&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;leiyu-code.github.io&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.linuxcool.com/&quot;&gt;Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;route命令&quot;&gt;&lt;a href=&quot;#route命令&quot; class=&quot;headerlink&quot; title=&quot;route命令&quot;&gt;&lt;/a&gt;&lt;em&gt;&lt;strong&gt;route命令&lt;/strong&gt;&lt;/em&gt;&lt;/h4&gt;&lt;p&gt;  route命令用于显示和操作IP路由表。要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者同时位于两个网络的网关来实现。windows环境下route命令常用于多网卡终端，默认路由指向连接访问互联网的网卡，静态路由指向内网网卡。&lt;/p&gt;</summary>
    
    
    
    <category term="windows" scheme="http://example.com/categories/windows/"/>
    
    
    <category term="cmd" scheme="http://example.com/tags/cmd/"/>
    
    <category term="route" scheme="http://example.com/tags/route/"/>
    
  </entry>
  
  <entry>
    <title>服务器安全批处理</title>
    <link href="http://example.com/2024/06/23/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E6%89%B9%E5%A4%84%E7%90%86/"/>
    <id>http://example.com/2024/06/23/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E6%89%B9%E5%A4%84%E7%90%86/</id>
    <published>2024-06-23T02:28:06.000Z</published>
    <updated>2024-06-23T02:38:16.193Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p><p><a href="http://leiyu-code.github.io">leiyu-code.github.io</a></p><p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p><p><em><strong>用法：</strong></em></p><p>桌面新建文本文件</p><p>将下列代码粘贴到文件文件，并且改文件名称后缀txt为bat，双击运行</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@<span class="built_in">ECHO</span> OFF </span><br><span class="line"><span class="built_in">CLS</span> </span><br><span class="line"><span class="built_in">TITLE</span> SERVER SAFE SETUP PRO </span><br><span class="line"><span class="built_in">COLOR</span> <span class="number">0</span>A </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe C:\ /p Administrators:f system:f &quot;network service&quot;:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe D:\ /p Administrators:f system:f servU:f &quot;network service&quot;:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe E:\ /p Administrators:f system:f servU:f &quot;network service&quot;:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe &quot;C:\Program Files&quot; /t /p Administrators:f system:f everyone:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe &quot;C:\Program Files\Common Files&quot; /t /g Administrators:f system:f everyone:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows /p Administrators:f system:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32 /p Administrators:f system:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe C:\WINDOWS\system32\inetsrv /p Administrators:f system:f everyone:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe &quot;C:\Documents and Settings&quot; /p Administrators:f system:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe &quot;C:\Documents and Settings\All Users&quot; /t /p Administrator:f system:f everyone:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\temp /p everyone:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe <span class="variable">%systemroot%</span>\system32\shell32.dll /p Administrators:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe <span class="variable">%systemroot%</span>\system32\wshom.ocx /p Administrators:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32\*.exe /p Administrators:f system:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe &quot;c:\Documents and Settings\All Users&quot; /e /g everyone:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe <span class="variable">%systemroot%</span>\system32\svchost.exe /e /g &quot;network service&quot;:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe <span class="variable">%systemroot%</span>\system32\msdtc.exe /e /g &quot;network service&quot;:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe <span class="variable">%windir%</span>\system32\mtxex.dll /e /g everyone:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32\<span class="built_in">cmd</span>.exe /p Administrator:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32\<span class="built_in">net</span>.exe /p Administrator:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32\net1.exe /p Administrator:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32\sc.exe /p Administrator:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32\<span class="built_in">at</span>.exe /p Administrator:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe <span class="variable">%windir%</span>\system32\dllhost.exe /e /g everyone:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32\netsh.exe /p Administrator:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32\<span class="built_in">net</span>.exe /p Administrator:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32\<span class="built_in">cacls</span>.exe /p Administrator:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32\cmdkey.exe /p Administrator:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32\ftp.exe /p Administrator:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32\tftp.exe /p Administrator:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32\reg.exe /p Administrator:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32\regedt32.exe /p Administrator:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32\regini.exe /p Administrator:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe <span class="variable">%windir%</span>\assembly /e /t /g &quot;network service&quot;:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe <span class="variable">%windir%</span>\Microsoft.<span class="built_in">NET</span> /e /t /g everyone:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe &quot;<span class="variable">%windir%</span>\Microsoft.<span class="built_in">NET</span>\Framework\v1.<span class="number">1</span>.<span class="number">4322</span>\Temporary ASP.<span class="built_in">NET</span> Files&quot; /e /t /g everyone:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe <span class="variable">%windir%</span>\system32\mscoree.dll /e /g everyone:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe <span class="variable">%windir%</span>\system32\ws03res.dll /e /g everyone:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe <span class="variable">%windir%</span>\system32\msxml*.dll /e /g everyone:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe C:\WINDOWS\system32\urlmon.dll /e /g everyone:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe C:\WINDOWS\system32\mlang.dll /e /g everyone:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe C:\WINDOWS\system32\TAPI32.dll /e /g everyone:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe C:\WINDOWS\system32\WININET.dll /e /g everyone:r </span><br><span class="line"><span class="built_in">cacls</span> c:\windows\assembly /e /t /p &quot;network service&quot;:r </span><br><span class="line"><span class="built_in">cacls</span> c:\windows\Microsoft.<span class="built_in">NET</span> /e /t /p &quot;network service&quot;:r </span><br><span class="line"><span class="built_in">cacls</span> &quot;C:\WINDOWS\Microsoft.<span class="built_in">NET</span>\Framework\v1.<span class="number">1</span>.<span class="number">4322</span>\Temporary ASP.<span class="built_in">NET</span> Files&quot; /e /t /p &quot;network service&quot;:f </span><br><span class="line"><span class="built_in">cacls</span> C:\WINDOWS\system32\mscoree.dll /e /g everyone:r </span><br><span class="line"><span class="built_in">cacls</span> C:\WINDOWS\system32\ws03res.dll /e /g everyone:r </span><br><span class="line"><span class="built_in">cacls</span> c:\WINDOWS /e /g &quot;network service&quot;:r </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">exist</span> c:\windows <span class="built_in">cacls</span> c:\windows /e /g &quot;network service&quot;:r </span><br><span class="line"><span class="built_in">cacls</span> c:\windows\Microsoft.<span class="built_in">NET</span> /e /t /p &quot;network service&quot;:r </span><br><span class="line"><span class="built_in">cacls</span> &quot;C:\WINDOWS\Microsoft.<span class="built_in">NET</span>\Framework\v1.<span class="number">1</span>.<span class="number">4322</span>\Temporary ASP.<span class="built_in">NET</span> Files&quot; /e /t /p &quot;network service&quot;:f </span><br><span class="line"><span class="built_in">cacls</span> &quot;C:\WINDOWS\Microsoft.<span class="built_in">NET</span>\Framework\v2.<span class="number">0</span>.<span class="number">50727</span>\Temporary ASP.<span class="built_in">NET</span> Files&quot; /e /t /p &quot;network service&quot;:f </span><br><span class="line"><span class="built_in">cacls</span> c:\windows\system32 /e /g &quot;network service&quot;:r </span><br><span class="line"><span class="built_in">cacls</span> c:\windows\system32\rasapi32.dll /e /g &quot;network service&quot;:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe C:\WINDOWS\system32\inetsrv\adsiis.dll /p Administrators:f autosystem:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe C:\WINDOWS\system32\inetsrv\iisadmpwd /p Administrators:f autosystem:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe C:\WINDOWS\system32\inetsrv\MetaBack /p Administrators:f autosystem:f </span><br><span class="line"><span class="built_in">cacls</span> C&quot;:\Program Files\Serv-U&quot; /e /g &quot;servu&quot;:f </span><br><span class="line"><span class="built_in">cacls</span> d:\wwwroot /e /g servU:f </span><br><span class="line"><span class="built_in">echo</span> 以上设置服务器目录权限 </span><br><span class="line"></span><br><span class="line"><span class="built_in">net</span> stop Browser </span><br><span class="line">sc config Browser <span class="built_in">start</span>= disabled </span><br><span class="line"><span class="built_in">net</span> stop lanmanserver </span><br><span class="line">sc config lanmanserver <span class="built_in">start</span>= disabled </span><br><span class="line"><span class="built_in">net</span> share c$ /delete </span><br><span class="line"><span class="built_in">net</span> share d$ /delete </span><br><span class="line"><span class="built_in">net</span> share e$ /delete </span><br><span class="line"><span class="built_in">net</span> share f$ /delete </span><br><span class="line"><span class="built_in">net</span> share admin$ /delete </span><br><span class="line"><span class="built_in">net</span> share ipc$ /delete </span><br><span class="line"><span class="built_in">echo</span> 以上删除默认共享，设置服务项 </span><br><span class="line"><span class="built_in">echo</span> .. delshare.reg ....... </span><br><span class="line"><span class="built_in">echo</span> Windows Registry Editor Version <span class="number">5</span>.<span class="number">00</span>&gt; c:\delshare.reg </span><br><span class="line"><span class="built_in">echo</span> [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\lanmanserver\parameters]&gt;&gt; c:\delshare.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;AutoShareWks&quot;=dword:<span class="number">00000000</span>&gt;&gt; c:\delshare.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;AutoShareServer&quot;=dword:<span class="number">00000000</span>&gt;&gt; c:\delshare.reg </span><br><span class="line"><span class="built_in">echo</span> .. delshare.reg ..... </span><br><span class="line">regedit /s c:\delshare.reg </span><br><span class="line"><span class="built_in">echo</span> .. delshare.reg .... </span><br><span class="line"><span class="built_in">del</span> c:\delshare.reg </span><br><span class="line"><span class="built_in">echo</span> . </span><br><span class="line"><span class="built_in">echo</span> ........ </span><br><span class="line"><span class="built_in">echo</span> . </span><br><span class="line"><span class="built_in">echo</span> ========================================================= </span><br><span class="line"><span class="built_in">echo</span> . </span><br><span class="line"><span class="built_in">echo</span> .....................dos.... </span><br><span class="line"><span class="built_in">echo</span> . </span><br><span class="line"><span class="built_in">echo</span> ......... </span><br><span class="line"><span class="built_in">echo</span> Windows Registry Editor Version <span class="number">5</span>.<span class="number">00</span>&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters]&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;EnableICMPRedirect&quot;=dword:<span class="number">00000000</span>&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;DeadGWDetectDefault&quot;=dword:<span class="number">00000001</span>&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;DontAddDefaultGatewayDefault&quot;=dword:<span class="number">00000000</span>&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;EnableSecurityFilters&quot;=dword:<span class="number">00000000</span>&quot;&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;AllowUnqualifiedQuery&quot;=dword:<span class="number">00000000</span>&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;PrioritizeRecordData&quot;=dword:<span class="number">00000001</span>&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;ReservedPorts&quot;=hex(<span class="number">7</span>):<span class="number">31</span>,<span class="number">00</span>,<span class="number">34</span>,<span class="number">00</span>,<span class="number">33</span>,<span class="number">00</span>,<span class="number">33</span>,<span class="number">00</span>,<span class="number">2</span>d,<span class="number">00</span>,<span class="number">31</span>,<span class="number">00</span>,<span class="number">34</span>,<span class="number">00</span>,<span class="number">33</span>,<span class="number">00</span>,<span class="number">34</span>,<span class="number">00</span>,\&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> <span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;SynAttackProtect&quot;=dword:<span class="number">00000002</span>&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;EnablePMTUDiscovery&quot;=dword:<span class="number">00000000</span>&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;NoNameReleaseOnDemand&quot;=dword:<span class="number">00000001</span>&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;EnableDeadGWDetect&quot;=dword:<span class="number">00000000</span>&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;KeepAliveTime&quot;=dword:<span class="number">00300000</span>&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;PerformRouterDiscovery&quot;=dword:<span class="number">00000000</span>&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;EnableICMPRedirects&quot;=dword:<span class="number">00000000</span>&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> . </span><br><span class="line"><span class="built_in">echo</span> ========================================================== </span><br><span class="line"><span class="built_in">echo</span> .. dosforwin.reg ..... </span><br><span class="line">regedit /s c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> .. dosforwin.reg .... </span><br><span class="line"><span class="built_in">del</span> c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> ============================================================== </span><br><span class="line"><span class="built_in">echo</span> . </span><br><span class="line"><span class="built_in">echo</span> =============================================================== </span><br><span class="line"><span class="built_in">echo</span> ..Remote Registry Service........... </span><br><span class="line"><span class="built_in">echo</span> ......... </span><br><span class="line"><span class="built_in">echo</span> . </span><br><span class="line"><span class="built_in">echo</span> Windows Registry Editor Version <span class="number">5</span>.<span class="number">00</span>&gt; c:\regedit.reg </span><br><span class="line"><span class="built_in">echo</span> [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\RemoteRegistry]&gt;&gt; c:\regedit.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;<span class="built_in">Start</span>&quot;=dword:<span class="number">00000004</span>&gt;&gt; c:\regedit.reg </span><br><span class="line"><span class="built_in">echo</span> . </span><br><span class="line"><span class="built_in">echo</span> .. regedit.reg ..... </span><br><span class="line">regedit /s c:\regedit.reg </span><br><span class="line"><span class="built_in">echo</span> . </span><br><span class="line"><span class="built_in">echo</span> ...... </span><br><span class="line"><span class="built_in">del</span> c:\regedit.reg </span><br><span class="line"><span class="built_in">echo</span> =============================================================== </span><br><span class="line"><span class="built_in">echo</span> ..Messenger....... </span><br><span class="line"><span class="built_in">echo</span> ......... </span><br><span class="line"><span class="built_in">echo</span> Windows Registry Editor Version <span class="number">5</span>.<span class="number">00</span>&gt; c:\message.reg </span><br><span class="line"><span class="built_in">echo</span> [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Messenger]&gt;&gt; c:\message.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;<span class="built_in">Start</span>&quot;=dword:<span class="number">00000004</span>&gt;&gt; c:\message.reg </span><br><span class="line"><span class="built_in">echo</span> . </span><br><span class="line"><span class="built_in">echo</span> .. message.reg ..... </span><br><span class="line">regedit /s c:\message.reg </span><br><span class="line"><span class="built_in">echo</span> . </span><br><span class="line"><span class="built_in">echo</span> .. message.reg </span><br><span class="line"><span class="built_in">del</span> c:\message.reg </span><br><span class="line"><span class="built_in">echo</span> =============================================================== </span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> =============================================================== </span><br><span class="line"><span class="built_in">echo</span> ..lanmanserver....... </span><br><span class="line"><span class="built_in">echo</span> ......... </span><br><span class="line"><span class="built_in">echo</span> Windows Registry Editor Version <span class="number">5</span>.<span class="number">00</span>&gt; c:\lanmanserver.reg </span><br><span class="line"><span class="built_in">echo</span> [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\lanmanserver]&gt;&gt; c:\lanmanserver.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;<span class="built_in">Start</span>&quot;=dword:<span class="number">00000004</span>&gt;&gt; c:\lanmanserver.reg </span><br><span class="line"><span class="built_in">echo</span> . </span><br><span class="line"><span class="built_in">echo</span> .. lanmanserver.reg ..... </span><br><span class="line">regedit /s c:\lanmanserver.reg </span><br><span class="line"><span class="built_in">echo</span> . </span><br><span class="line"><span class="built_in">echo</span> .. lanmanserver.reg </span><br><span class="line"><span class="built_in">del</span> c:\lanmanserver.reg </span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> ============================================================== </span><br><span class="line"><span class="built_in">echo</span> ...TCP/IP NetBIOS Helper Service </span><br><span class="line"><span class="built_in">echo</span> ......... </span><br><span class="line"><span class="built_in">echo</span> Windows Registry Editor Version <span class="number">5</span>.<span class="number">00</span>&gt; c:\netbios.reg </span><br><span class="line"><span class="built_in">echo</span> [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\LmHosts]&gt;&gt; c:\netbios.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;<span class="built_in">Start</span>&quot;=dword:<span class="number">00000004</span>&gt;&gt; c:\netbios.reg </span><br><span class="line"><span class="built_in">echo</span> . </span><br><span class="line"><span class="built_in">echo</span> .. netbios.reg ..... </span><br><span class="line">regedit /s c:\netbios.reg </span><br><span class="line"><span class="built_in">echo</span> . </span><br><span class="line"><span class="built_in">echo</span> .. netbios.reg </span><br><span class="line"><span class="built_in">del</span> c:\netbios.reg </span><br><span class="line">regedit /s forddos.reg </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;[南月晨的blog](&lt;a href=&quot;https://leiyu-code.github.io/&quot;&gt;南月晨的博客 (leiyu-code.github.io)&lt;/a&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://leiyu-code.</summary>
      
    
    
    
    <category term="server" scheme="http://example.com/categories/server/"/>
    
    
    <category term="safe" scheme="http://example.com/tags/safe/"/>
    
    <category term="bat" scheme="http://example.com/tags/bat/"/>
    
  </entry>
  
  <entry>
    <title>美食推荐——蒸鸡蛋糕</title>
    <link href="http://example.com/2024/06/21/%E7%BE%8E%E9%A3%9F%E6%8E%A8%E8%8D%90%E2%80%94%E2%80%94%E8%92%B8%E9%B8%A1%E8%9B%8B%E7%B3%95/"/>
    <id>http://example.com/2024/06/21/%E7%BE%8E%E9%A3%9F%E6%8E%A8%E8%8D%90%E2%80%94%E2%80%94%E8%92%B8%E9%B8%A1%E8%9B%8B%E7%B3%95/</id>
    <published>2024-06-21T12:28:06.000Z</published>
    <updated>2024-06-21T09:28:31.162Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p><p>leiyu-code.github.io</p><p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p><p><strong>问题：做蒸鸡蛋糕总是里边有孔洞</strong></p><p><a href="https://imgse.com/i/pkD2R10"><img src="https://s21.ax1x.com/2024/06/21/pkD2R10.png" alt="pkD2R10.png"></a></p><span id="more"></span><p>原料：鸡蛋、食盐、香油</p><p>制作步骤：</p><p>1、两个鸡蛋敲小碗里。</p><p>2、另一个小碗中加入与蛋液差不多量的清水。水对蛋液比例1：1到1：1.5之间均可。清水用温水好些，在水中加入食盐，搅拌均匀，使之充分溶解。食盐也可在后续搅蛋液的时候放，为了能更均匀所以先放清水里了。</p><p>3、把食盐水和蛋液混合，搅拌，至蛋液完全搅散。（这时候表面会有很多气泡，这样直接蒸的话里边的气泡就是孔洞的成因。）</p><p>4、现在<strong>进行消除气泡的工艺——过筛</strong>。用细筛网过一遍蛋液，气泡都留在筛网上了。过完筛的蛋液再去除表面少量的气泡，就可以了。</p><p>5、加入适量的香油。加香油蒸出来的鸡蛋糕是金黄的，很漂亮。没有香油加其他植物油也可，颜色上可能差些，但不耽误好吃。</p><p>6、上蒸锅，<strong>至关重要的第二道工艺来了——扣盘子。这样可以避免蒸的过程中蛋液起泡。</strong>（如果盛蛋液的容器口过大，用保鲜膜覆盖也可，效果是一样的。只是比扣盘子麻烦些，我试过。）</p><p>7、盖上锅盖，大火把水烧开。用中火，蒸12分钟即可。（蒸的过程中什么也不用管，例如开盖放气之类的，这些都已经被扣盘子的工艺解决了。）</p><p><a href="https://imgse.com/i/pkD22pq"><img src="https://s21.ax1x.com/2024/06/21/pkD22pq.png" alt="pkD22pq.png"></a></p><hr><p><strong>总结：</strong> <em><strong>过筛，是为了消气泡；</strong></em></p><p>​            <em><strong>扣盘子，是为了蒸制过程蛋液表面平整。</strong></em>这两个步骤很有用哦，其余就可自由发挥了，加些葱花、虾皮之类的也不错，全凭个人喜好～</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;[南月晨的blog](&lt;a href=&quot;https://leiyu-code.github.io/&quot;&gt;南月晨的博客 (leiyu-code.github.io)&lt;/a&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;leiyu-code.github.io&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.linuxcool.com/&quot;&gt;Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题：做蒸鸡蛋糕总是里边有孔洞&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://imgse.com/i/pkD2R10&quot;&gt;&lt;img src=&quot;https://s21.ax1x.com/2024/06/21/pkD2R10.png&quot; alt=&quot;pkD2R10.png&quot;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="food" scheme="http://example.com/categories/food/"/>
    
    
    <category term="eggcake" scheme="http://example.com/tags/eggcake/"/>
    
  </entry>
  
  <entry>
    <title>佳软推荐——最好用的PDF虚拟打印机CutePDF Writer</title>
    <link href="http://example.com/2024/06/21/%E4%BD%B3%E8%BD%AF%E6%8E%A8%E8%8D%90%E2%80%94%E2%80%94%E6%9C%80%E5%A5%BD%E7%94%A8%E7%9A%84PDF%E8%99%9A%E6%8B%9F%E6%89%93%E5%8D%B0%E6%9C%BACutePDF%20Writer/"/>
    <id>http://example.com/2024/06/21/%E4%BD%B3%E8%BD%AF%E6%8E%A8%E8%8D%90%E2%80%94%E2%80%94%E6%9C%80%E5%A5%BD%E7%94%A8%E7%9A%84PDF%E8%99%9A%E6%8B%9F%E6%89%93%E5%8D%B0%E6%9C%BACutePDF%20Writer/</id>
    <published>2024-06-21T11:28:06.000Z</published>
    <updated>2024-06-21T08:45:25.765Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p><p>leiyu-code.github.io</p><p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p><p>CutePDF Writer是 Acro Software公司出品的免费PDF虚拟打印机，支持 win98-win7，支持32位&#x2F;64位。<br><strong>软件优点：</strong>经典、稳定、持续但绝不频繁地升级；完美支持中文、字体美观。CutePDF Writer 是我使用时间跨度最长、纯使用时间最长的PDF虚拟打印机。<br>它也需要PS2PDF的转换器，当然，推荐的转换器依然是Ghostscript。并且，官方提供了一个专门制作的 GPLGS8.15 Converter，与 CutePDF Writer配合使用。相比自己下载的版本，它体积更小，并且兼容性更有保证。<br>完全免费，可以用于商业用途。（FREE for commercial and non-commercial use!）无水印。无弹出广告。</p><p><a href="https://imgse.com/i/pkDcl36"><img src="https://s21.ax1x.com/2024/06/21/pkDcl36.png" alt="pkDcl36.png"></a></p><span id="more"></span><p><em><strong>CutePDF Writer的安装：</strong></em></p><p>下载 <a href="http://download.cutepdf.com/download/CuteWriter.zip">zip安装包</a>（8MB），内含2个文件。<br>　　　- 先运行其中的 converter.exe （5MB），安装转换器。安装过程基本不需要任何干预。<br>　　　- 再运行其中的 CuteWriter.exe （3MB），安装PDF Writer。注意：安装过程<strong>有Ask Toobar推广广告，可以选择不安装</strong>（视频第50秒开始）。<br>　　　- 然后，就可以在任意程序的“打印”菜单中，选择CutePDF Writer，把文档打印为pdf了。</p><p><a href="https://imgse.com/i/pkDc3jO"><img src="https://s21.ax1x.com/2024/06/21/pkDc3jO.png" alt="pkDc3jO.png"></a></p><p><a href="https://imgse.com/i/pkDc1gK"><img src="https://s21.ax1x.com/2024/06/21/pkDc1gK.png" alt="pkDc1gK.png"></a></p><hr><p><strong>总结：最好用的pdf打印机CutePDF Writer，别的pdf打印机打出来乱码、格式不对的时候下来试试吧！</strong></p><p>​           <em><strong>WPS也自己带有pdf打印机，安装后就可以直接使用</strong></em></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;[南月晨的blog](&lt;a href=&quot;https://leiyu-code.github.io/&quot;&gt;南月晨的博客 (leiyu-code.github.io)&lt;/a&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;leiyu-code.github.io&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.linuxcool.com/&quot;&gt;Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CutePDF Writer是 Acro Software公司出品的免费PDF虚拟打印机，支持 win98-win7，支持32位&amp;#x2F;64位。&lt;br&gt;&lt;strong&gt;软件优点：&lt;/strong&gt;经典、稳定、持续但绝不频繁地升级；完美支持中文、字体美观。CutePDF Writer 是我使用时间跨度最长、纯使用时间最长的PDF虚拟打印机。&lt;br&gt;它也需要PS2PDF的转换器，当然，推荐的转换器依然是Ghostscript。并且，官方提供了一个专门制作的 GPLGS8.15 Converter，与 CutePDF Writer配合使用。相比自己下载的版本，它体积更小，并且兼容性更有保证。&lt;br&gt;完全免费，可以用于商业用途。（FREE for commercial and non-commercial use!）无水印。无弹出广告。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://imgse.com/i/pkDcl36&quot;&gt;&lt;img src=&quot;https://s21.ax1x.com/2024/06/21/pkDcl36.png&quot; alt=&quot;pkDcl36.png&quot;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="software" scheme="http://example.com/categories/software/"/>
    
    
    <category term="print" scheme="http://example.com/tags/print/"/>
    
    <category term="pdf" scheme="http://example.com/tags/pdf/"/>
    
  </entry>
  
  <entry>
    <title>com+错误代码8007042c-依赖服务或组无法启动</title>
    <link href="http://example.com/2024/06/21/com+%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%818007042c-%E4%BE%9D%E8%B5%96%E6%9C%8D%E5%8A%A1%E6%88%96%E7%BB%84%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8/"/>
    <id>http://example.com/2024/06/21/com+%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%818007042c-%E4%BE%9D%E8%B5%96%E6%9C%8D%E5%8A%A1%E6%88%96%E7%BB%84%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8/</id>
    <published>2024-06-21T06:39:06.000Z</published>
    <updated>2024-06-21T07:01:25.005Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p><p>leiyu-code.github.io</p><p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p><p><em><strong>com+错误代码8007042c-依赖服务或组无法启动</strong></em></p><p><a href="https://imgse.com/i/pkDwpDI"><img src="https://s21.ax1x.com/2024/06/21/pkDwpDI.png" alt="pkDwpDI.png"></a></p><span id="more"></span><p><em><strong>解决方法：</strong></em></p><ol><li><p>查看系统日志，发现与 COM+ System Application 服务相依的服务因下列错误system Event Notification Senice而无法启动:无法启动服务，原因可能是已被禁用或与其相关联的设备没有启动。</p></li><li><p>进入控制面板里的卸载或更改程序和功能，点击打开或关闭windows功能,勾选system Event Notification Senice，安装windows相关功能。</p><p><a href="https://imgse.com/i/pkDwPVP"><img src="https://s21.ax1x.com/2024/06/21/pkDwPVP.png" alt="pkDwPVP.png"></a></p><p><a href="https://imgse.com/i/pkDwSKA"><img src="https://s21.ax1x.com/2024/06/21/pkDwSKA.png" alt="pkDwSKA.png"></a></p><p><a href="https://imgse.com/i/pkDw9bt"><img src="https://s21.ax1x.com/2024/06/21/pkDw9bt.png" alt="pkDw9bt.png"></a></p></li><li><p>打开com+和dtc相关的服务。</p><p><a href="https://imgse.com/i/pkDBTDs"><img src="https://s21.ax1x.com/2024/06/21/pkDBTDs.png" alt="pkDBTDs.png"></a></p><p><a href="https://imgse.com/i/pkDBouj"><img src="https://s21.ax1x.com/2024/06/21/pkDBouj.png" alt="pkDBouj.png"></a></p></li></ol><hr><p><strong>总结：widows系统报错，先查看系统日志，应用程序日志，查看错误原因，无法启动服务就安装相应的windows功能，启动相应的服务，并将有关联的服务改成自动启动。</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;[南月晨的blog](&lt;a href=&quot;https://leiyu-code.github.io/&quot;&gt;南月晨的博客 (leiyu-code.github.io)&lt;/a&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;leiyu-code.github.io&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.linuxcool.com/&quot;&gt;Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;com+错误代码8007042c-依赖服务或组无法启动&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://imgse.com/i/pkDwpDI&quot;&gt;&lt;img src=&quot;https://s21.ax1x.com/2024/06/21/pkDwpDI.png&quot; alt=&quot;pkDwpDI.png&quot;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="workNote" scheme="http://example.com/categories/workNote/"/>
    
    
    <category term="windows" scheme="http://example.com/tags/windows/"/>
    
    <category term="wrong" scheme="http://example.com/tags/wrong/"/>
    
  </entry>
  
  <entry>
    <title>服务器安全配置基本设置</title>
    <link href="http://example.com/2024/06/21/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2024/06/21/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/</id>
    <published>2024-06-21T02:47:06.000Z</published>
    <updated>2024-06-23T03:12:49.952Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p><p>leiyu-code.github.io</p><p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p><p>对windows服务器进行以下的设置和相关策略的制定，可以有效的增加服务器的自身防御能力，防止黑客利用常见的攻击手段和方法对服务器进行入侵和破坏，降低数据被盗取的风险。</p><p><em><strong>gpedit.msc  组策略编辑器</strong></em></p><p><em><strong>regedit  注册表编辑器</strong></em></p><p><em><strong>services.msc  计算机服务</strong></em></p><p><em><strong>msconfig  系统配置</strong></em></p><p><em><strong>firewall.cpl  防火墙</strong></em></p><span id="more"></span><p><em><strong>计算机安全策略配置：</strong></em></p><p><strong>(一) 修改远程桌面端口</strong></p><p>将默认端口3389修改为XXX。</p><p><strong>(二) 帐户</strong></p><p>对系统管理员默认帐户administrator进行重命名，停用guest用户。</p><p><strong>(三) 开启windows防火墙</strong></p><p>  取消网络连接中的文件和打印共享。</p><p>  在例外里面添加远程桌面端口XXX。</p><p>  在防火墙高级设置时勾选Web服务和安全的Web服务。</p><p>  在防火墙开放FTP端口XX。</p><p>  开放短信发送平台端口：XXX</p><p><strong>(四) 禁用无关服务</strong></p><p>  Printspooler 打印服务</p><p>  Wirelessconfiguration 无线服务</p><p>  RoutingandRemoteAccess在局域网以及广域网环境中为企业提供路由服务。</p><p>  NTLMSecuritysupportprovide：telnet服务和MicrosoftSerch服务使用。</p><p>  Telnet允许远程用户登录到此计算机并运行程序。</p><p>  RemoteDesktopHelpSessionManager：远程协助服务。</p><p>  ErrorReportingService收集、存储和向Microsoft报告异常应用程序。</p><p>  RemoteRegistry 远程注册表操作。</p><p><strong>(五) 禁止IPC空连接</strong></p><p>打开注册表找到Local_Machine\System\CurrentControlSet\Control\LSA-RestrictAnonymous把这个值改成”1”即可。</p><p><strong>(六) 删除默认共享</strong></p><p>打开注册表找到HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters，新建AutoShareServer类型是REG_DWORD把值改为0。</p><p><strong>(七) 策略配置</strong></p><p>组策略配置:gpedit—&gt;计算机配置—&gt;windows设置—&gt;安全设置—&gt;本地策略。</p><p>在用户权利分配下，从通过网络访问此计算机中删除PowerUsers和BackupOperators;</p><p>启用不允许匿名访问SAM帐号和共享;</p><p>启用不允许为网络验证存储凭据或Passport;</p><p>从文件共享中删除允许匿名登录的DFS$和COMCFG;</p><p>启用交互登录：不显示上次的用户名;</p><p>启用在下一次密码变更时不存储LANMAN哈希值;</p><p>禁止IIS匿名用户在本地登录。</p><hr><p><strong>总结：</strong> 打开windows防火墙、windows更新，并进行简单的配置也能在最大的程度上防止黑客的入侵</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;[南月晨的blog](&lt;a href=&quot;https://leiyu-code.github.io/&quot;&gt;南月晨的博客 (leiyu-code.github.io)&lt;/a&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;leiyu-code.github.io&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.linuxcool.com/&quot;&gt;Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对windows服务器进行以下的设置和相关策略的制定，可以有效的增加服务器的自身防御能力，防止黑客利用常见的攻击手段和方法对服务器进行入侵和破坏，降低数据被盗取的风险。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;gpedit.msc  组策略编辑器&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;regedit  注册表编辑器&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;services.msc  计算机服务&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;msconfig  系统配置&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;firewall.cpl  防火墙&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="server" scheme="http://example.com/categories/server/"/>
    
    
    <category term="safe" scheme="http://example.com/tags/safe/"/>
    
  </entry>
  
  <entry>
    <title>斑马Zebra条码打印机软件和驱动须知</title>
    <link href="http://example.com/2024/06/20/%E6%96%91%E9%A9%ACZebra%E6%9D%A1%E7%A0%81%E6%89%93%E5%8D%B0%E6%9C%BA%E8%BD%AF%E4%BB%B6%E5%92%8C%E9%A9%B1%E5%8A%A8%E9%A1%BB%E7%9F%A5/"/>
    <id>http://example.com/2024/06/20/%E6%96%91%E9%A9%ACZebra%E6%9D%A1%E7%A0%81%E6%89%93%E5%8D%B0%E6%9C%BA%E8%BD%AF%E4%BB%B6%E5%92%8C%E9%A9%B1%E5%8A%A8%E9%A1%BB%E7%9F%A5/</id>
    <published>2024-06-20T08:28:06.000Z</published>
    <updated>2024-06-21T03:01:15.605Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p><p>leiyu-code.github.io</p><p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p><p><em><strong>条码打印机须知</strong></em></p><p>1、888T的打印方式是热敏&#x2F;热转印；</p><p>​      888D的打印方式是热敏</p><p>2、热敏打印和热转印是条码机的两种打印方式。</p><p>虽然每种方法都使用热敏打印头对打印表面加热。 </p><p>热转印是通过加热色带，在多种材料上打印出耐用、持久的图案。</p><p>热敏打印不使用色带，而是直接在标签材料上打印图案。</p><p>3、条码打印机使用的条码编辑软件要有相应的打印机驱动才能进入条码编辑软件</p><span id="more"></span><p><em><strong>热敏和热转印的区别：</strong></em></p><ol><li>技术原理</li></ol><p><strong>热敏打印：</strong>主要通过对打印头加热，并接触经过化学处理的热敏介质标签后打印出所需图案。热敏标签打印机在使用时不需要任何油墨、墨粉或碳带，使用成本相对较低。</p><p><strong>热转印打印：</strong>主要通过打印头对碳带加热，油墨转印在标签材料上形成图案。热转印标签打印机由于需要碳带，标签纸技术要求比热敏高，因此整体成本存在较大差距。</p><p><strong>02. 适配耗材</strong></p><p><strong>热敏打印：</strong>只能使用热敏纸</p><p><strong>热转印打印：</strong>可接受更多品种的介质，包括PP合成纸、PVC、PET等材质</p><p><strong>03. 保存时间</strong></p><p><strong>热敏打印标签：</strong>对热、光、化学溶剂和磨损敏感，在日常环境下长时间存放后，图案会随时间推移而褪色。市面上普通的热敏标签打印内容保存时间一般为几个月，精臣销售的热敏标签纸采用多层覆膜工艺，一般可保存1-2年不等（具体时长受实际使用环境因素影响决定）。</p><p><strong>热转印打印标签：</strong>能够提供其他打印技术无法匹敌的图案质量和耐久性，相较于热敏打印，保存时间更长久，一般为5年左右，具体时间受标签纸和碳带质量影响，精臣热转印标签采用高品质树脂基碳带，一般可保存8-10年时间。</p><p><strong>04. 使用场景</strong></p><p><strong>热敏打印：</strong>适用于家用、餐饮、商超零售、服装、物流等标签标识更新频率较快并且对条形码要求不高的行业。</p><p><strong>热转印打印：</strong>适用于制造业、汽车业、电力通信、医疗业、纺织业、化学工业、制药工业、零售分发业、运输业和物流、政府机构等多类行业。</p><p><em><strong>Zebra 888t条码打印机使用软件</strong></em></p><p>ZebraDesigner  V2</p><p><a href="https://imgse.com/i/pkDYyx1"><img src="https://s21.ax1x.com/2024/06/21/pkDYyx1.png" alt="pkDYyx1.png"></a></p><p><a href="https://imgse.com/i/pkDYcKx"><img src="https://s21.ax1x.com/2024/06/21/pkDYcKx.png" alt="pkDYcKx.png"></a></p><p><a href="https://imgse.com/i/pkDYs2R"><img src="https://s21.ax1x.com/2024/06/21/pkDYs2R.png" alt="pkDYs2R.png"></a></p><hr><p><strong>总结：打印条码需要选择带碳带的热转印条码打印机，比如Zebra 888t条码打印机</strong></p><p>​           <strong>条码打印机若是安不上驱动，检查打印数据线和打印口是否损坏，一般来讲，线插好后驱动安装完成后，条码打印机就可以打印测试页了</strong></p><p>​           <strong>条码打印机要是打印的不清晰，请先更换碳带，再选择相应的纸张，要么就与条码编辑软件里的字体设置有关系，需要更改字体</strong></p><p>​          <strong>斑马打印机选择的条码编辑软件为ZebraDesigner  V2，经测试可以正常使用。</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;[南月晨的blog](&lt;a href=&quot;https://leiyu-code.github.io/&quot;&gt;南月晨的博客 (leiyu-code.github.io)&lt;/a&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;leiyu-code.github.io&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.linuxcool.com/&quot;&gt;Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;条码打印机须知&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;1、888T的打印方式是热敏&amp;#x2F;热转印；&lt;/p&gt;
&lt;p&gt;​      888D的打印方式是热敏&lt;/p&gt;
&lt;p&gt;2、热敏打印和热转印是条码机的两种打印方式。&lt;/p&gt;
&lt;p&gt;虽然每种方法都使用热敏打印头对打印表面加热。 &lt;/p&gt;
&lt;p&gt;热转印是通过加热色带，在多种材料上打印出耐用、持久的图案。&lt;/p&gt;
&lt;p&gt;热敏打印不使用色带，而是直接在标签材料上打印图案。&lt;/p&gt;
&lt;p&gt;3、条码打印机使用的条码编辑软件要有相应的打印机驱动才能进入条码编辑软件&lt;/p&gt;</summary>
    
    
    
    <category term="workNote" scheme="http://example.com/categories/workNote/"/>
    
    
    <category term="software" scheme="http://example.com/tags/software/"/>
    
    <category term="print" scheme="http://example.com/tags/print/"/>
    
    <category term="zebra" scheme="http://example.com/tags/zebra/"/>
    
  </entry>
  
  <entry>
    <title>腾讯文档使用教程</title>
    <link href="http://example.com/2024/04/29/%E8%85%BE%E8%AE%AF%E6%96%87%E6%A1%A3%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://example.com/2024/04/29/%E8%85%BE%E8%AE%AF%E6%96%87%E6%A1%A3%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</id>
    <published>2024-04-29T02:30:06.000Z</published>
    <updated>2024-04-29T02:35:35.732Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p><p>leiyu-code.github.io</p><p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p><h1 id="腾讯文档使用教程"><a href="#腾讯文档使用教程" class="headerlink" title="腾讯文档使用教程"></a><strong>腾讯文档使用教程</strong></h1><h3 id="【图文教程】"><a href="#【图文教程】" class="headerlink" title="【图文教程】"></a><strong>【图文教程】</strong></h3><p>1、在线文档 (Word) 使用教程:</p><p><a href="https://docs.qq.com/doc/p/fc045c173c6cd5278d17893571b5ca1f2a907de1">https://docs.qq.com/doc/p/fc045c173c6cd5278d17893571b5ca1f2a907de1</a></p><p>2、在线表格 (Excel) 使用教程:</p><p><a href="https://docs.qq.com/doc/p/46053051e04c02507b9f889c3e7d5e7b342ab38e">https://docs.qq.com/doc/p/46053051e04c02507b9f889c3e7d5e7b342ab38e</a></p><p>3、在线幻灯片 (PPT) 使用教程：</p><p><a href="https://docs.qq.com/doc/p/7ec3015255751fe252077f1b1921124ec032142d">https://docs.qq.com/doc/p/7ec3015255751fe252077f1b1921124ec032142d</a></p><p>4、在线收集表使用教程:</p><p><a href="https://docs.qq.com/doc/p/9119455d5eadbb23a232efb4188feb7656fdd7e4">https://docs.qq.com/doc/p/9119455d5eadbb23a232efb4188feb7656fdd7e4</a></p><p>5、     智能表格使用教程:</p><p><a href="https://docs.qq.com/aio/DZmFVQ05WbUdOeXRI">https://docs.qq.com/aio/DZmFVQ05WbUdOeXRI</a></p><p>6、     智能文档使用教程：</p><p><a href="https://docs.qq.com/aio/DWXh1S2tCRnlhVEFL?p=18PtEOLdNUBVPBHaTmbfJT">https://docs.qq.com/aio/DWXh1S2tCRnlhVEFL</a></p><p>7、     思维导图（Mind）使用教程：</p><p><a href="https://docs.qq.com/doc/p/ba603297f82a62611bd7f25612655a048bd2f5c6?pub=1&dver=2.1.27141849">https://docs.qq.com/doc/p/ba603297f82a62611bd7f25612655a048bd2f5c6</a></p><p>8、     流程图（Flowchart）使用教程：</p><p><a href="https://docs.qq.com/doc/p/b0bad2bb71932d45900fa83105ce00bfe9dfc3a7">https://docs.qq.com/doc/p/b0bad2bb71932d45900fa83105ce00bfe9dfc3a7</a></p><h3 id="【视频教程】"><a href="#【视频教程】" class="headerlink" title="【视频教程】"></a><strong>【视频教程】</strong></h3><p>1、【视频教程】1分钟学会做项目规划</p><p><a href="https://v.qq.com/x/page/f30639oiqsl.html">https://v.qq.com/x/page/f30639oiqsl.html</a> </p><p>2、【视频教程】1分钟学会信息收集</p><p><a href="https://v.qq.com/x/page/i3063rsg6yq.html">https://v.qq.com/x/page/i3063rsg6yq.html</a></p><p>3、【视频教程】1分钟学会如何进行远程会议</p><p><a href="https://v.qq.com/x/page/n30637654dl.html">https://v.qq.com/x/page/n30637654dl.html</a> </p><p>4、【视频教程】1分钟学会如何追踪项目进度</p><p><a href="https://v.qq.com/x/page/c3063yywrdr.html">https://v.qq.com/x/page/c3063yywrdr.html</a> </p><p>5、【视频教程】1分钟学会做项目执行</p><p><a href="https://v.qq.com/x/page/v3063xxa8at.html">https://v.qq.com/x/page/v3063xxa8at.html</a> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;[南月晨的blog](&lt;a href=&quot;https://leiyu-code.github.io/&quot;&gt;南月晨的博客 (leiyu-code.github.io)&lt;/a&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;leiyu-code.github.io&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="Tencent" scheme="http://example.com/categories/Tencent/"/>
    
    
    <category term="software" scheme="http://example.com/tags/software/"/>
    
    <category term="TencentDocs" scheme="http://example.com/tags/TencentDocs/"/>
    
  </entry>
  
  <entry>
    <title>VMware Workstation重新安装报错的解决方法</title>
    <link href="http://example.com/2023/11/13/VMware%20Workstation%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85%E6%8A%A5%E9%94%99%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2023/11/13/VMware%20Workstation%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85%E6%8A%A5%E9%94%99%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</id>
    <published>2023-11-13T07:59:06.000Z</published>
    <updated>2024-04-29T02:36:09.084Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p><p>leiyu-code.github.io</p><p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p><p><strong>在重新安装VMware Workstation时会报错，错误的内容乱七八糟，了解了一下后，报错的原因如下：</strong></p><p><strong>1、软件安装临时目录里的反安装程序被删除，导致程序一直出现Vc++ runtime一直安装不了</strong></p><p><strong>2、卸载的时候软件目录里的文件未被清理干净</strong></p><p><strong>3、注册表文件未被清理干净</strong></p><p>解决方法：</p><p>1、卸载所有的C++运行库</p><p>2、重启后再重新安装运行库</p><p>3、重启后再重新安装运行库</p><p><em><strong>在安装过程中试了很多方法都不能成功地安装VM，最后使用了一款VM反安装工具后VM就能正常地安装了</strong></em></p><hr><p><strong>总结：软件安装不了最好先卸载所有的C++运行库，不行了再使用软件的专用清理工具清理下，就可以正常安装了</strong></p><span id="more"></span><p>VM清理工具在以下链接里，快去下来试试吧！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;[南月晨的blog](&lt;a href=&quot;https://leiyu-code.github.io/&quot;&gt;南月晨的博客 (leiyu-code.github.io)&lt;/a&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;leiyu-code.github.io&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.linuxcool.com/&quot;&gt;Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在重新安装VMware Workstation时会报错，错误的内容乱七八糟，了解了一下后，报错的原因如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、软件安装临时目录里的反安装程序被删除，导致程序一直出现Vc++ runtime一直安装不了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、卸载的时候软件目录里的文件未被清理干净&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、注册表文件未被清理干净&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;p&gt;1、卸载所有的C++运行库&lt;/p&gt;
&lt;p&gt;2、重启后再重新安装运行库&lt;/p&gt;
&lt;p&gt;3、重启后再重新安装运行库&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;在安装过程中试了很多方法都不能成功地安装VM，最后使用了一款VM反安装工具后VM就能正常地安装了&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;总结：软件安装不了最好先卸载所有的C++运行库，不行了再使用软件的专用清理工具清理下，就可以正常安装了&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Vm" scheme="http://example.com/categories/Vm/"/>
    
    
    <category term="vm" scheme="http://example.com/tags/vm/"/>
    
    <category term="software" scheme="http://example.com/tags/software/"/>
    
  </entry>
  
  <entry>
    <title>SQL语句学习手册实例</title>
    <link href="http://example.com/2023/07/10/SQL%E8%AF%AD%E5%8F%A5%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C%E5%AE%9E%E4%BE%8B/"/>
    <id>http://example.com/2023/07/10/SQL%E8%AF%AD%E5%8F%A5%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C%E5%AE%9E%E4%BE%8B/</id>
    <published>2023-07-10T08:20:06.000Z</published>
    <updated>2023-07-10T08:41:27.973Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p><p>leiyu-code.github.io</p><p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p><h2 id="SQL语句学习手册实例"><a href="#SQL语句学习手册实例" class="headerlink" title="SQL语句学习手册实例"></a>SQL语句学习手册实例</h2><p><strong>How to use sql &amp; examples</strong></p><p><em><strong>point:表</strong></em></p><p>​          <em><strong>视图</strong></em></p><p>​         <em><strong>索引</strong></em></p><p>​        <em><strong>表达式</strong></em></p><p>​        <em><strong>函数</strong></em></p><p>​        <em><strong>权限控制</strong></em></p><span id="more"></span><h3 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h3><p>例 1 对于表的教学管理数据库中的表 STUDENTS ，可以定义如下：<br>   CREATE TABLE STUDENTS<br>   (SNO      NUMERIC (6, 0) NOT NULL<br>   SNAME    CHAR (8) NOT NULL<br>   AGE      NUMERIC(3,0)<br>   SEX      CHAR(2)<br>   BPLACE CHAR(20)<br>   PRIMARY KEY(SNO))<br>例 2 对于表的教学管理数据库中的表 ENROLLS ，可以定义如下：<br>        CREATE TABLE ENROLLS<br>        (SNO      NUMERIC(6,0) NOT NULL<br>        CNO     CHAR(4) NOT NULL<br>        GRADE   INT<br>        PRIMARY KEY(SNO,CNO)<br>        FOREIGN KEY(SNO) REFERENCES STUDENTS(SNO)<br>        FOREIGN KEY(CNO) REFERENCES COURSES(CNO)<br>        CHECK ((GRADE IS NULL) OR (GRADE BETWEEN 0 AND 100)))<br>例 3 根据表的 STUDENTS 表，建立一个只包含学号、姓名、年龄的女学生表。<br>        CREATE TABLE GIRL<br>        AS SELECT SNO, SNAME, AGE<br>        FROM STUDENTS<br>        WHERE SEX&#x3D;’ 女 ‘; </p><p>例 4 删除教师表 TEACHER 。<br>        DROP TABLE TEACHER<br>例 5 在教师表中增加住址列。<br>       ALTER TABLE TEACHERS<br>       ADD (ADDR CHAR(50))<br>例 6 把 STUDENTS 表中的 BPLACE 列删除，并且把引用 BPLACE 列的所有视图和约束也一起删除。<br>        ALTER TABLE STUDENTS<br>        DROP BPLACE CASCADE<br>例 7 补充定义 ENROLLS 表的主关键字。<br>       ALTER TABLE ENROLLS<br>       ADD PRIMARY KEY (SNO,CNO) ； </p><h3 id="视图操作（虚表）"><a href="#视图操作（虚表）" class="headerlink" title="视图操作（虚表）"></a>视图操作（虚表）</h3><p>例 9 建立一个只包括教师号、姓名和年龄的视图 FACULTY 。 ( 在视图定义中不能包含 ORDER BY 子句 )<br>        CREATE VIEW FACULTY<br>        AS SELECT TNO, TNAME, AGE<br>        FROM TEACHERS<br>例 10 从学生表、课程表和选课表中产生一个视图 GRADE_TABLE ， 它包括学生姓名、课程名和成绩。<br>        CREATE VIEW GRADE_TABLE<br>        AS SELECT SNAME,CNAME,GRADE<br>        FROM STUDENTS,COURSES,ENROLLS<br>        WHERE STUDENTS.SNO ＝ ENROLLS.SNO AND<br>        COURSES.CNO&#x3D;ENROLLS.CNO<br>例 11 删除视图 GRADE_TABLE<br>        DROP VIEW GRADE_TABLE RESTRICT </p><h3 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h3><p>例 12 在学生表中按学号建立索引。<br>        CREATE  UNIQUE  INDEX  ST<br>        ON STUDENTS (SNO,ASC)<br>例 13 删除按学号所建立的索引。<br>        DROP INDEX ST </p><h3 id="数据库模式操作"><a href="#数据库模式操作" class="headerlink" title="数据库模式操作"></a>数据库模式操作</h3><p>例 14 创建一个简易教学数据库的数据库模式  TEACHING_DB ，属主为 ZHANG 。<br>        CREATE SCHEMA TEACHING_DB  AUTHRIZATION  ZHANG<br>例 15 删除简易教学数据库模式 TEACHING_DB 。（（ 1 ）选用 CASCADE ，即当删除数据库模式时，则本数据库模式和其下属的基本表、视图、索引等全部被删除。（ 2 ）选用 RESTRICT ，即本数据库模式下属的基本表、视图、索引等事先已清除，才能删除本数据库模式，否则拒绝删除。）<br>        DROP SCHEMA TEACHING_DB CASCADE </p><h3 id="单表操作"><a href="#单表操作" class="headerlink" title="单表操作"></a>单表操作</h3><p>例 16 找出 3 个学分的课程号和课程名。<br>         SELECT CNO, CNAME<br>         FROM 　 COURSES<br>         WHERE 　 CREDIT ＝ 3<br>例 17 查询年龄大于 22 岁的学生情况。<br>         SELECT *<br>         FROM   STUDENTS<br>         WHERE AGE ＞ 22<br>例 18   找出籍贯为河北的男生的姓名和年龄。<br>         SELECT SNAME, AGE<br>         FROM 　 STUDENTS<br>         WHERE 　 BPLACE ＝ ‘ 河北 ‘  AND SEX ＝ ‘ 男 ‘<br>例 19 找出年龄在 20 ～ 23 岁之间的学生的学号、姓名和年龄，并按年龄升序排序。 (ASC （升序）或 DESC （降序）声明排序的方式，缺省为升序。 )<br>         SELECT SNO, SNAME, AGE<br>         FROM   STUDENTS<br>         WHERE AGE BETWEEN 20 AND 23<br>         ORDER BY  AGE<br>例 20 找出年龄小于 23 岁、籍贯是湖南或湖北的学生的姓名和性别。（条件比较运算符＝、＜ 和逻辑运算符 AND （与），此外还可以使用的运算符有：＞（大于）、＞＝（大于等于）、＜＝（小于等于）、＜＞（不等于）、 NOT （非）、 OR （或）等。<br>谓词 LIKE 只能与字符串联用，常常是 “ ＜列名＞  LIKE pattern” 的格式。特殊字符 “_” 和 “%” 作为通配符。<br>谓词 IN 表示指定的属性应与后面的集合（括号中的值集或某个查询子句的结果）中的某个值相匹配，实际上是一系列的 OR （或）的缩写。谓词 NOT IN 表示指定的属性不与后面的集合中的某个值相匹配。<br>谓词 BETWEEN 是 “ 包含于 … 之中 ” 的意思。）<br>        SELECT SNAME, SEX<br>        FROM   STUDENTS<br>        WHERE AGE ＜ 23 AND BPLACE LIKE’ 湖％ ‘<br>        或<br>        SELECT SNAME, SEX<br>        FROM   STUDENTS<br>        WHERE AGE ＜ 23 AND BPLACE IN （ ‘ 湖南 ‘ ， ‘ 湖北 ‘ ）<br>例 22 找出学生表中籍贯是空值的学生的姓名和性别。（在 SQL 中不能使用条件：＜列名＞＝ NULL 。在 SQL 中只有一个特殊的查询条件允许查询 NULL 值：）<br>       SELECT SNAME, SEX<br>       FROM   STUDENTS<br>       WHERE BPLACE IS NULL </p><h3 id="多表操作"><a href="#多表操作" class="headerlink" title="多表操作"></a>多表操作</h3><p>例 23 找出成绩为 95 分的学生的姓名。（子查询）<br>        SELECT SNAME<br>        FROM 　 STUDENTS<br>        WHERE 　 SNO ＝<br>              (SELECT SNO<br>               FROM   ENROLLS<br>               WHERE GRADE ＝ 95)<br>例 24 找出成绩在 90 分以上的学生的姓名。<br>       SELECT SNAME<br>        FROM   STUDENTS<br>        WHERE SNO IN<br>                (SELECT SNO<br>                FROM ENROLLS<br>                WHERE GRADE ＞ 90)<br>        或<br>        SELECT SNAME<br>        FROM   STUDENTS<br>        WHERE SNO ＝ ANY<br>                (SELECT SNO<br>                FROM ENROLLS<br>                WHERE GRADE ＞ 90)<br>例 25 查询全部学生的学生名和所学课程号及成绩。（连接查询）<br>        SELECT SNAME, CNO, GRADE<br>        FROM   STUDENTS, ENROLLS<br>        WHERE STUDENTS.SNO ＝ ENROLLS.SNO<br>例 26 找出籍贯为山西或河北，成绩为 90 分以上的学生的姓名、籍贯和成绩。（当构造多表连接查询命令时，必须遵循两条规则。第一，连接条件数正好比表数少 1 （若有三个表，就有两个连接条件 ) ；第二，若一个表中的主关键字是由多个列组成，则对此主关键字中的每一个列都要有一个连接条件（也有少数例外情况））<br>        SELECT SNAME, BPLACE, GRADE<br>        FROM   STUDENTS, ENROLLS<br>        WHERE BPLACE IN (‘ 山西 ’ ， ‘ 河北 ’) AND GRADE ＞＝ 90 AND 　 STUDENTS.SNO&#x3D;ENROLLS.SNO<br>例 28 查出课程成绩在 80 分以上的女学生的姓名、课程名和成绩。（ FROM 子句中的子查询）<br>        SELECT SNAME,CNAME, GRADE<br>        FROM   (SELECT SNAME, CNAME , GRADE<br>                        FROM STUDENTS, ENROLLS,COURSES<br>                        WHERE SEX ＝ ‘ 女 ‘)<br>        AS TEMP (SNAME, CNAME,GRADE)<br>        WHERE GRADE ＞ 80 </p><h3 id="表达式与函数的使用"><a href="#表达式与函数的使用" class="headerlink" title="表达式与函数的使用"></a>表达式与函数的使用</h3><p>例 29 查询各课程的学时数。（算术表达式由算术运算符＋、－、 * 、／与列名或数值常量所组成。）<br>        SELECT CNAME,COURSE_TIME ＝ CREDIT<em>16<br>        FROM   COURSES<br>例 30 找出教师的最小年龄。（内部函数： SQL 标准中只使用 COUNT 、 SUM 、 AVG 、 MAX 、 MIN 函数，称之为聚集函数（ Set Function ）。 COUNT 函数的结果是该列统计值的总数目， SUM 函数求该列统计值之和， AVG 函数求该列统计值之平均值， MAX 函数求该列最大值， MIN 函数求该列最小值。）<br>        SELECT MIN(AGE)<br>        FROM   TEACHERS<br>例 31 统计年龄小于等于 22 岁的学生人数。（统计）<br>        SELECT COUNT(</em>)<br>        FROM   STUDENTS<br>        WHERE AGE &lt; ＝ 22<br>例 32 找出学生的平均成绩和所学课程门数。<br>        SELECT SNO, AVG(GRADE), COURSES ＝ COUNT(*)<br>        FROM   ENROLLS<br>        GROUP BY SNO </p><p>例 34 找出年龄超过平均年龄的学生姓名。<br>SELECT SNAME<br>FROM STUDENTS<br>WHERE AGE ＞<br>      (SELECT AVG(AGE)<br>        FROM   STUDENTS) </p><p>例 35 找出各课程的平均成绩，按课程号分组，且只选择学生超过 3 人的课程的成绩。（ GROUP BY 与 HAVING<br>        GROUP BY 子句把一个表按某一指定列（或一些列）上的值相等的原则分组，然后再对每组数据进行规定的操作。<br>        GROUP BY 子句总是跟在 WHERE 子句后面，当 WHERE 子句缺省时，它跟在 FROM 子句后面。<br>        HAVING 子句常用于在计算出聚集之后对行的查询进行控制。）<br>         SELECT CNO, AVG(GRADE), STUDENTS ＝ COUNT(<em>)<br>         FROM ENROLLS<br>         GROUP BY CNO<br>         HAVING COUNT(</em>) &gt;&#x3D; 3 </p><h3 id="相关子查询"><a href="#相关子查询" class="headerlink" title="相关子查询"></a>相关子查询</h3><p>例 37 查询没有选任何课程的学生的学号和姓名。（当一个子查询涉及到一个来自外部查询的列时，称为相关子查询（ Correlated Subquery) 。相关子查询要用到存在测试谓词 EXISTS 和 NOT EXISTS ，以及 ALL 、 ANY （ SOME ）等。）<br>        SELECT SNO, SNAME<br>        FROM   STUDENTS<br>        WHERE NOT EXISTS<br>              (SELECT *<br>              FROM ENROLLS<br>              WHERE ENROLLS.SNO&#x3D;STUDENTS.SNO)<br>例 38   查询哪些课程只有男生选读。<br>        SELECT DISTINCT CNAME<br>        FROM   COURSES C<br>        WHERE ‘ 男 ‘ ＝ ALL<br>               (SELECT SEX<br>                FROM ENROLLS ， STUDENTS<br>                WHERE ENROLLS.SNO&#x3D;STUDENTS.SNO AND<br>                      ENROLLS.CNO&#x3D;C.CNO)<br>例 39 要求给出一张学生、籍贯列表，该表中的学生的籍贯省份，也是其他一些学生的籍贯省份。<br>        SELECT SNAME, BPLACE<br>        FROM   STUDENTS A<br>        WHERE EXISTS<br>               (SELECT *<br>                 FROM STUDENTS B<br>                 WHERE A.BPLACE&#x3D;B.BPLACE AND<br>                       A.SNO &lt; &gt; B.SNO) </p><p>例 40 找出选修了全部课程的学生的姓名。<br>        本查询可以改为：查询这样一些学生，没有一门课程是他不选修的。<br>        SELECT SNAME<br>        FROM   STUDENTS<br>        WHERE NOT EXISTS<br>               (SELECT *<br>                FROM COURSES<br>                WHERE NOT EXISTS<br>                        (SELECT *<br>                         FROM ENROLLS<br>                         WHERE ENROLLS.SNO ＝ STUDENTS.SNO<br>                             AND ENROLLS.CNO ＝ COURSES.CNO)) </p><h3 id="关系代数运算"><a href="#关系代数运算" class="headerlink" title="关系代数运算"></a>关系代数运算</h3><p>例 41 设有某商场工作人员的两张表：营业员表 SP_SUBORD 和营销经理表 SP_MGR ，其关系数据模式如下：<br>        SP_SUBORD (SALPERS_ID, SALPERS_NAME, MANAGER_ID, OFFICE)<br>        SP_MGR (SALPERS_ID, SALPERS_NAME, MANAGER_ID, OFFICE)<br>        其中，属性 SALPERS_ID 为工作人员的编号 , SALPERS_NAME 为工作人员的姓名 , MANAGER_ID 为所在部门经理的编号 , OFFICE 为工作地点。<br>若查询全部商场工作人员，可以用下面的 SQL 语句：<br>        (SELECT * FROM SP_SUBORD)<br>        UNION<br>        (SELECT * FROM SP_MGR)<br>        或等价地用下面的 SQL 语句：<br>        SELECT *<br>        FROM (TABLE SP_SUBORD UNION TABLE SP_MGR)<br>（ 2 ） INTERSECT<br>         (SELECT * FROM SP_SUBORD)<br>         INTERSECT<br>         (SELECT * FROM SP_MGR)<br>        或等价地用下面的 SQL 语句：<br>        SELECT *<br>        FROM (TABLE SP_SUBORD INTERSECT TABLE SP_MGR)<br>        或用带 ALL 的 SQL 语句：<br>        (SELECT * FROM SP_SUBORD)<br>       INTERSECT ALL<br>        (SELECT * FROM SP_MGR)<br>        或<br>        SELECT *<br>        FROM (TABLE SP_SUBORD INTERSECT ALL TABLE SP_MGR)<br>（ 3 ） EXCEPT<br>        (SELECT * FROM SP_MGR)<br>        EXCEPT<br>        (SELECT * FROM SP_SUBORD)<br>        或等价地用下面的 SQL 语句：<br>        SELECT *<br>        FROM (TABLE SP_MGR EXCEPT TABLE SP_ SUBORD)<br>        或用带 ALL 的 SQL 语句：<br>        (SELECT * FROM SP_MGR)<br>        EXCEPT ALL<br>        (SELECT * FROM SP_SUBORD)<br>例 42 查询籍贯为四川、课程成绩在 80 分以上的学生信息及其成绩。（自然连接）<br>        (SELECT * FROM STUDENTS<br>         WHERE BPLACE&#x3D;‘ 四川 ’)<br>        NATURAL JOIN<br>        (SELECT * FROM ENROLLS<br>         WHERE GRADE &gt;&#x3D;80)<br>例3.43          列出全部教师的姓名及其任课的课程号、班级。<br>（外连接与外部并外连接允许在结果表中保留非匹配元组，空缺部分填以 NULL 。外连接的作用是在做连接操作时避免丢失信息。<br>        外连接有 3 类：<br>（ 1 ）左外连接（ Left Outer Join ）。连接运算谓词为 LEFT [OUTER] JOIN ，其结果表中保留左关系的所有元组。<br>（ 2 ）右外连接（ Right Outer Join ）。连接运算谓词为 RIGHT [OUTER] JOIN ，其结果表中保留右关系的所有元组。<br>（ 3 ）全外连接（ Full Outer Join ）。连接运算谓词为 FULL [OUTER] JOIN ，其结果表中保留左右两关系的所有元组。）<br>          SELECT TNAME, CNO, CLASS<br>          FROM TEACHERS LEFT OUTER JOIN TEACHING USING (TNO) </p><h3 id="SQL-的数据操作"><a href="#SQL-的数据操作" class="headerlink" title="SQL 的数据操作"></a>SQL 的数据操作</h3><p>例 44 把教师李映雪的记录加入到教师表 TEACHERS 中。（插入）<br>        INSERT INTO TEACHERS<br>        VALUES(1476 ， ‘ 李映雪 ‘ ， 44 ， ‘ 副教授 ‘)<br>例 45 成绩优秀的学生将留下当教师。<br>        INSERT INTO TEACHERS (TNO ， TNAME)<br>        SELECT DISTINCT SNO ， SNAME<br>        FROM   STUDENTS ， ENROLLS<br>        WHERE STUDENTS.SNO ＝ ENROLLS.SNO AND GRADE ＞＝ 90<br>例 47 把所有学生的年龄增加一岁。（修改）<br>        UPDATE STUDENTS<br>        SET AGE ＝ AGE+1<br>例 48 学生张春明在数据库课考试中作弊，该课成绩应作零分计。<br>        UPDATE ENROLLS<br>        SET GRADE ＝ 0<br>        WHERE CNO ＝ ‘C1’ AND<br>             ‘ 张春明 ‘ ＝<br>             (SELECT SNAME<br>             FROM STUDENTS<br>             WHERE STUDENTS.SNO&#x3D;ENROLLS.SNO)<br>例 49 从教师表中删除年龄已到 60 岁的退休教师的数据。（删除）<br>        DELETE FROM TEACHERS<br>        WHERE AGE ＞＝ 60 </p><h3 id="SQL-的数据权限控制"><a href="#SQL-的数据权限控制" class="headerlink" title="SQL 的数据权限控制"></a>SQL 的数据权限控制</h3><p>例 50 授予 LILI 有对表 STUDENTS 的查询权。（表／视图特权的授予<br>        一个 SQL 特权允许一个被授权者在给定的数据库对象上进行特定的操作。授权操作的数据库对象包括：表 &#x2F; 视图、列、域等。授权的操作包括： INSERT 、 UPDATE 、 DELETE 、 SELECT 、 REFERENCES 、 TRIGGER 、 UNDER 、 USAGE 、 EXECUTE 等。其中 INSERT 、 UPDATE 、 DELETE 、 SELECT 、 REFERENCES 、 TRIGGER 有对表做相应操作的权限，故称为表特权。）<br>        GRANT SELECT ON STUDENTS<br>        TO LILI<br>        WITH GRANT OPTION<br>例 51 取消 LILI 的存取 STUDENTS 表的特权。<br>        REVOKE ALL<br>        ON STUDENTS<br>        FROM LILI CASCADE </p><p>不断补充中：</p><ol><li>模糊查找:<br>它判断列值是否与指定的字符串格式相匹配。可用于char、varchar、text、ntext、datetime和smalldatetime等类型查询。<br>　　可使用以下通配字符：<br>　　百分号%：可匹配任意类型和长度的字符，如果是中文，请使用两个百分号即%%。<br>　　下划线_：匹配单个任意字符，它常用来限制表达式的字符长度。<br>　　方括号[]：指定一个字符、字符串或范围，要求所匹配对象为它们中的任一个。[^]：其取值也[] 相同，但它要求所匹配对象为指定字符以外的任一个字符。<br>　　 例如：<br>　　限制以Publishing结尾，使用LIKE ‘%Publishing’<br>　　限制以A开头：LIKE ‘[A]%’<br>　　限制以A开头外：LIKE ‘[^A]%’</li></ol><p>2.更改表格　<br>         ALTER TABLE table_name<br>        ADD COLUMN column_name DATATYPE<br>        说明：增加一个栏位（没有删除某个栏位的语法。)<br>        ALTER TABLE table_name<br>        ADD PRIMARY KEY (column_name)<br>        说明：更改表得的定义把某个栏位设为主键。<br>        ALTER TABLE table_name<br>        DROP PRIMARY KEY (column_name)<br>        说明：把主键的定义删除。<br>3.group by<br>在select 语句中可以使用group by 子句将行划分成较小的组，然后，使用聚组函数返回每一个组的汇总信息，另外，可以使用having子句限制返回的结果集。group by 子句可以将查询结果分组，并返回行的汇总信息Oracle 按照group by 子句中指定的表达式的值分组查询结果。<br>在带有group by 子句的查询语句中，在select 列表中指定的列要么是group by 子句中指定的列，要么包含聚组函数<br>select max(sal),job emp group by job;<br>(注意max(sal),job的job并非一定要出现，但有意义)<br>查询语句的select 和group by ,having 子句是聚组函数唯一出现的地方，在where 子句中不能使用聚组函数。<br>select deptno,sum(sal) from emp where sal&gt;1200 group by deptno having sum(sal)&gt;8500 order by deptno;<br>当在gropu by 子句中使用having 子句时，查询结果中只返回满足having条件的组。在一个sql语句中可以有where子句和having子句。having 与where 子句类似，均用于设置限定条件</p><p>where 子句的作用是在对查询结果进行分组前，将不符合where条件的行去掉，即在分组之前过滤数据，条件中不能包含聚组函数，使用where条件显示特定的行。<br>having 子句的作用是筛选满足条件的组，即在分组之后过滤数据，条件中经常包含聚组函数，使用having 条件显示特定的组，也可以使用多个分组标准进行分组。<br>查询每个部门的每种职位的雇员数<br>select deptno,job,count(*) from emp group by deptno,job;<br>4.外连接与内连接<br>有时候，即使在连接的表中没有相应的行，用户可能想从一张表中看数据，Oracle提供了外连接实现该功能。<br>内连接是指连接查询只显示完全满足连接条件的记录，即等值连接，外连接的查询结果是内连接查询结果的扩展。外连接不仅返回满足连接条件的所有记录而且也返回了一个表中那些在另一个表中没有匹配行的记录。外连接的操作符是“+”。“+”号放在连接条件中信息不完全的那一边（即没有相应行的那一边）。运算符“+”影响NULL行的建立。建一行或多行NULL来匹配连接的表中信息完全的行。<br>外连接运算符“+”只能出现在where子句中表达式的一边。<br>假如在多张表之间有多个连接条件，外连接运算符不能使用or,in逻辑运算符与其它条件组合。</p><p>假如emp表中deptno&#x3D;10的ename为空值，dept表中deptno&#x3D;20的loc为空值：<br>1.<br>select<br>ename,dept.deptno,loc<br>from<br>emp,dept<br>where<br>emp.depno(+)&#x3D;dept.deptno;<br>如果在dept.deptno中有的数值在emp.deptno中没有值，则在做外连接时，<br>结果中ename会产生一个空值。(emp.deptno&#x3D;10)<br>2.<br>select<br>ename,dept.deptno,loc<br>from<br>emp,dept<br>where<br>emp.depno&#x3D;dept.deptno(+);<br>如果在emp.deptno中有的数值在dept.deptno中没有值，则在做外连接时，<br>结果中loc会产生一个空值。。(dept.deptno&#x3D;20)</p><p>5.自连接<br>自连接是指同一张表的不同行间的连接。该连接不受其他表的影响。用自连接可以比较同一张表中不同行的某一列的值。因为自连接查询仅涉及到某一张表与其自身的连接。所以在from子句中该表名出现两次，分别用两个不同的别名表示，两个别名当作两张不同的表进行处理，与其它的表连接一样，别名之间也使用一个或多个相关的列连接。为了区分同一张表的不同行的列，在名前永别名加以限制。<br>select<br>worker.ename,<br>manager.ename manager<br>from<br>emp worker,<br>emp manager<br>where<br>work.mgr&#x3D;manager.empno;<br>6.集合运算<br>基合运算符可以用于从多张表中选择数据。<br>①UNION运算<br>用于求两个结果集合的并集（两个结果集合的所有记录），并自动去掉重复行。<br>select ename,sal from account where sal&gt;2000<br>union<br>select ename,sal from research where sal&gt;2000<br>union<br>select ename,sal from sales where sal&gt;2000;<br>注：ename,sal 是必须一致的。 </p><p>②UNION ALL运算<br>用于求两个结果集合的并集（两个结果集中的所有记录），并且不去掉重复行。<br>select ename,sal from account where sal&gt;2000<br>union<br>select ename,sal from research where sal&gt;2000<br>union<br>select ename,sal from sales where sal&gt;2000;<br>③INTERSECT运算<br>intersect运算返回查询结果中相同的部分。</p><p>各部门中有哪些相同的职位？<br>select Job from account<br>intersect<br>select Job from research<br>intersect<br>select Job from sales;</p><p>④MINUS运算<br>minus返回两个结果集的差集。（在第一个结果集中存在的，而在第二个结果集中不存在的行。）<br>有那些职位是财务部中有，而在销售部门中没有？<br>select Job from account<br>minus<br>select Job from sales;</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;[南月晨的blog](&lt;a href=&quot;https://leiyu-code.github.io/&quot;&gt;南月晨的博客 (leiyu-code.github.io)&lt;/a&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;leiyu-code.github.io&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.linuxcool.com/&quot;&gt;Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;SQL语句学习手册实例&quot;&gt;&lt;a href=&quot;#SQL语句学习手册实例&quot; class=&quot;headerlink&quot; title=&quot;SQL语句学习手册实例&quot;&gt;&lt;/a&gt;SQL语句学习手册实例&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;How to use sql &amp;amp; examples&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;point:表&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;​          &lt;em&gt;&lt;strong&gt;视图&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;​         &lt;em&gt;&lt;strong&gt;索引&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;​        &lt;em&gt;&lt;strong&gt;表达式&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;​        &lt;em&gt;&lt;strong&gt;函数&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;​        &lt;em&gt;&lt;strong&gt;权限控制&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Datebase" scheme="http://example.com/categories/Datebase/"/>
    
    
    <category term="sql" scheme="http://example.com/tags/sql/"/>
    
  </entry>
  
</feed>
