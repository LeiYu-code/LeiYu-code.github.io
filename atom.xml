<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>南月晨的博客</title>
  
  <subtitle>南山下，月落时，必有晨</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-11-12T06:57:50.170Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>yu skywalker</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>优化SQL server</title>
    <link href="http://example.com/2024/11/12/%E4%BC%98%E5%8C%96SQLserver/"/>
    <id>http://example.com/2024/11/12/%E4%BC%98%E5%8C%96SQLserver/</id>
    <published>2024-11-12T06:56:06.000Z</published>
    <updated>2024-11-12T06:57:50.170Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p><p>leiyu-code.github.io</p><p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p>在 SQL Server 中，当数据量增大时，数据库的性能可能会受到影响，导致查询速度变慢、响应时间变长等问题。为了应对大量数据，以下是一些常用的优化策略和案例详解。</p><h2 id="1-索引优化"><a href="#1-索引优化" class="headerlink" title="1. 索引优化"></a>1. 索引优化</h2><ul><li><strong>创建索引</strong>：索引可以显著提高查询速度，特别是在使用 <code>WHERE</code>、<code>JOIN</code> 和 <code>ORDER BY</code> 子句时。为常用的查询字段（尤其是筛选条件字段）创建合适的索引。</li><li><strong>选择合适的索引类型</strong>：使用聚集索引（Clustered Index）和非聚集索引（Non-clustered Index）来优化查询性能。聚集索引适用于排序、范围查询等，而非聚集索引适用于单一列或组合列的查询。</li><li><strong>避免过多索引</strong>：虽然索引能提高查询性能，但过多的索引会增加更新、插入和删除操作的成本，因此要平衡索引的数量和性能。</li></ul><p>在 SQL Server 中，索引优化是提高查询性能的重要手段。以下是一个具体的业务场景，假设我们有一个销售订单系统，订单表 <code>Orders</code> 需要根据不同的查询需求来进行索引优化。</p><h3 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h3><ul><li>查询需求1：按 <code>CustomerID</code> 和 <code>OrderDate</code> 查询订单信息。</li><li>查询需求2：按 <code>ProductID</code> 查询所有相关的订单。</li><li>查询需求3：查询某一订单的详细信息（通过 <code>OrderID</code>）。</li></ul><p>基于这些需求，我们将为 <code>Orders</code> 表创建索引，并展示如何选择合适的索引类型。</p><h3 id="1-创建表-Orders"><a href="#1-创建表-Orders" class="headerlink" title="1. 创建表 Orders"></a>1. 创建表 <code>Orders</code></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Orders (</span><br><span class="line">    OrderID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,         <span class="comment">-- 主键索引，自动创建聚集索引</span></span><br><span class="line">    CustomerID <span class="type">INT</span>,                  <span class="comment">-- 客户ID</span></span><br><span class="line">    OrderDate DATETIME,              <span class="comment">-- 订单日期</span></span><br><span class="line">    ProductID <span class="type">INT</span>,                   <span class="comment">-- 产品ID</span></span><br><span class="line">    TotalAmount <span class="type">DECIMAL</span>(<span class="number">18</span>, <span class="number">2</span>),      <span class="comment">-- 订单总金额</span></span><br><span class="line">    Status <span class="type">VARCHAR</span>(<span class="number">20</span>)               <span class="comment">-- 订单状态</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="2-创建索引"><a href="#2-创建索引" class="headerlink" title="2. 创建索引"></a>2. 创建索引</h3><h4 id="2-1-创建聚集索引（Clustered-Index）"><a href="#2-1-创建聚集索引（Clustered-Index）" class="headerlink" title="2.1. 创建聚集索引（Clustered Index）"></a>2.1. 创建聚集索引（Clustered Index）</h4><p>聚集索引通常是基于主键或唯一约束创建的。它将数据按照索引顺序存储，因此在 <code>OrderID</code> 上创建聚集索引能够加速按 <code>OrderID</code> 查找的查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- OrderID 是主键，默认会创建聚集索引</span></span><br><span class="line"><span class="comment">-- 所以在这种情况下不需要额外创建聚集索引</span></span><br></pre></td></tr></table></figure><h4 id="2-2-创建非聚集索引（Non-clustered-Index）"><a href="#2-2-创建非聚集索引（Non-clustered-Index）" class="headerlink" title="2.2. 创建非聚集索引（Non-clustered Index）"></a>2.2. 创建非聚集索引（Non-clustered Index）</h4><p>对于 <code>CustomerID</code> 和 <code>OrderDate</code> 组合字段的查询需求，我们可以为其创建一个复合非聚集索引。这样可以加速基于 <code>CustomerID</code> 和 <code>OrderDate</code> 的查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> NONCLUSTERED INDEX idx_Customer_OrderDate</span><br><span class="line"><span class="keyword">ON</span> Orders (CustomerID, OrderDate);</span><br></pre></td></tr></table></figure><ul><li><strong>使用场景</strong>：该索引有助于加速按 <code>CustomerID</code> 和 <code>OrderDate</code> 查询的性能，特别是当订单数据量较大时。</li></ul><h4 id="2-3-创建单列非聚集索引"><a href="#2-3-创建单列非聚集索引" class="headerlink" title="2.3. 创建单列非聚集索引"></a>2.3. 创建单列非聚集索引</h4><p>对于查询需求2，如果我们需要按 <code>ProductID</code> 查找所有相关订单，我们可以为 <code>ProductID</code> 创建单列非聚集索引。这样可以提高查询效率。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> NONCLUSTERED INDEX idx_ProductID</span><br><span class="line"><span class="keyword">ON</span> Orders (ProductID);</span><br></pre></td></tr></table></figure><ul><li><strong>使用场景</strong>：查询某个产品相关的所有订单时，通过该索引可以显著提高查询性能。</li></ul><h3 id="3-删除冗余索引"><a href="#3-删除冗余索引" class="headerlink" title="3. 删除冗余索引"></a>3. 删除冗余索引</h3><p>如果发现某个查询经常访问多个列，而我们在这些列上创建了多个单列索引，可能会导致性能下降。比如，创建多个针对单列的非聚集索引，可能会降低插入和更新操作的效率。为了避免这种情况，可以定期检查并删除冗余的索引。</p><p>假设我们发现 <code>ProductID</code> 和 <code>CustomerID</code> 常常一起出现在查询条件中，我们可以考虑删除 <code>idx_ProductID</code> 索引，改为创建一个组合索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除冗余的单列索引</span></span><br><span class="line"><span class="keyword">DROP</span> INDEX idx_ProductID <span class="keyword">ON</span> Orders;</span><br></pre></td></tr></table></figure><h3 id="4-查询优化"><a href="#4-查询优化" class="headerlink" title="4. 查询优化"></a>4. 查询优化</h3><p>现在，假设我们有以下几个查询，我们将展示如何利用创建的索引来优化查询性能。</p><h4 id="4-1-按-CustomerID-和-OrderDate-查询"><a href="#4-1-按-CustomerID-和-OrderDate-查询" class="headerlink" title="4.1. 按 CustomerID 和 OrderDate 查询"></a>4.1. 按 <code>CustomerID</code> 和 <code>OrderDate</code> 查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用 idx_Customer_OrderDate 索引</span></span><br><span class="line"><span class="keyword">SELECT</span> OrderID, ProductID, TotalAmount</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> CustomerID <span class="operator">=</span> <span class="number">1001</span> <span class="keyword">AND</span> OrderDate <span class="keyword">BETWEEN</span> <span class="string">&#x27;2024-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2024-12-31&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="4-2-按-ProductID-查询"><a href="#4-2-按-ProductID-查询" class="headerlink" title="4.2. 按 ProductID 查询"></a>4.2. 按 <code>ProductID</code> 查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用 idx_ProductID 索引</span></span><br><span class="line"><span class="keyword">SELECT</span> OrderID, CustomerID, TotalAmount</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> ProductID <span class="operator">=</span> <span class="number">500</span>;</span><br></pre></td></tr></table></figure><h4 id="4-3-查询特定订单详细信息"><a href="#4-3-查询特定订单详细信息" class="headerlink" title="4.3. 查询特定订单详细信息"></a>4.3. 查询特定订单详细信息</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 按 OrderID 查询，使用默认的聚集索引</span></span><br><span class="line"><span class="keyword">SELECT</span> CustomerID, ProductID, TotalAmount, Status</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> OrderID <span class="operator">=</span> <span class="number">123456</span>;</span><br></pre></td></tr></table></figure><h3 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5. 注意事项"></a>5. 注意事项</h3><ul><li><strong>索引的维护成本</strong>：虽然索引能显著提高查询性能，但每当进行 <code>INSERT</code>、<code>UPDATE</code> 或 <code>DELETE</code> 操作时，索引也需要维护。这会增加操作的成本。因此，索引不宜过多，需要根据查询需求进行优化。</li><li><strong>索引覆盖</strong>：尽量创建覆盖索引，即索引包含查询所需的所有列，这样可以避免查询时回表操作，提高查询效率。</li></ul><h3 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h3><p>通过为 <code>Orders</code> 表创建合适的索引，我们可以显著优化查询性能。在索引优化中，需要综合考虑查询需求、索引类型（聚集索引、非聚集索引）、索引的数量及其维护成本。</p><h2 id="2-查询优化"><a href="#2-查询优化" class="headerlink" title="2. 查询优化"></a>2. 查询优化</h2><ul><li><strong>优化 SQL 查询</strong>：确保 SQL 查询尽量高效。避免在查询中使用 <code>SELECT *</code>，而是只选择需要的列；避免重复的计算，尽量减少子查询。</li><li><strong>使用执行计划</strong>：利用 SQL Server Management Studio (SSMS) 的执行计划工具查看查询的执行计划，分析和优化查询中的瓶颈部分。</li><li><strong>避免复杂的嵌套查询</strong>：复杂的子查询可能会导致性能问题，考虑使用连接（<code>JOIN</code>）来代替。</li></ul><p>查询优化是通过精心设计 SQL 查询语句和优化索引来提高查询性能的过程。根据你提供的业务场景，我们将基于一个订单系统的 <code>Orders</code> 表，展示几种常见的查询优化方法。</p><h3 id="业务场景-1"><a href="#业务场景-1" class="headerlink" title="业务场景"></a>业务场景</h3><p>假设我们有一个销售订单系统，<code>Orders</code> 表包括以下字段：</p><ul><li><code>OrderID</code>：订单ID，主键。</li><li><code>CustomerID</code>：客户ID。</li><li><code>OrderDate</code>：订单日期。</li><li><code>ProductID</code>：产品ID。</li><li><code>TotalAmount</code>：订单总金额。</li><li><code>Status</code>：订单状态（如已支付、未支付等）。</li></ul><p>我们有以下几种查询需求：</p><ol><li>查询某个客户在某段时间内的所有订单。</li><li>查询某个产品在所有订单中的销售情况。</li><li>查询某个订单的详细信息。</li><li>查询多个客户的订单信息。</li></ol><h3 id="1-查询优化：按-CustomerID-和-OrderDate-查询订单"><a href="#1-查询优化：按-CustomerID-和-OrderDate-查询订单" class="headerlink" title="1. 查询优化：按 CustomerID 和 OrderDate 查询订单"></a>1. <strong>查询优化：按 <code>CustomerID</code> 和 <code>OrderDate</code> 查询订单</strong></h3><h4 id="查询需求："><a href="#查询需求：" class="headerlink" title="查询需求："></a>查询需求：</h4><p>查询某个客户在某段时间内的所有订单。</p><h4 id="查询语句："><a href="#查询语句：" class="headerlink" title="查询语句："></a>查询语句：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> OrderID, ProductID, TotalAmount, Status</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> CustomerID <span class="operator">=</span> <span class="number">1001</span></span><br><span class="line">  <span class="keyword">AND</span> OrderDate <span class="keyword">BETWEEN</span> <span class="string">&#x27;2024-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2024-12-31&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="优化建议："><a href="#优化建议：" class="headerlink" title="优化建议："></a>优化建议：</h4><ul><li><strong>索引优化</strong>：为 <code>CustomerID</code> 和 <code>OrderDate</code> 创建复合索引，因为这是常见的查询模式。复合索引可以加速基于这两个字段的查询。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> NONCLUSTERED INDEX idx_Customer_OrderDate</span><br><span class="line"><span class="keyword">ON</span> Orders (CustomerID, OrderDate);</span><br></pre></td></tr></table></figure><h4 id="执行计划优化："><a href="#执行计划优化：" class="headerlink" title="执行计划优化："></a>执行计划优化：</h4><ul><li>使用 <code>EXPLAIN</code> 或 <code>SET STATISTICS IO ON</code> 来查看执行计划，确认查询是否使用了索引。</li></ul><h3 id="2-查询优化：按-ProductID-查询所有相关订单"><a href="#2-查询优化：按-ProductID-查询所有相关订单" class="headerlink" title="2. 查询优化：按 ProductID 查询所有相关订单"></a>2. <strong>查询优化：按 <code>ProductID</code> 查询所有相关订单</strong></h3><h4 id="查询需求：-1"><a href="#查询需求：-1" class="headerlink" title="查询需求："></a>查询需求：</h4><p>查询某个产品的所有订单。</p><h4 id="查询语句：-1"><a href="#查询语句：-1" class="headerlink" title="查询语句："></a>查询语句：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> OrderID, CustomerID, TotalAmount, Status</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> ProductID <span class="operator">=</span> <span class="number">500</span>;</span><br></pre></td></tr></table></figure><h4 id="优化建议：-1"><a href="#优化建议：-1" class="headerlink" title="优化建议："></a>优化建议：</h4><ul><li><strong>索引优化</strong>：为 <code>ProductID</code> 创建索引，因为这个字段经常作为查询条件。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> NONCLUSTERED INDEX idx_ProductID</span><br><span class="line"><span class="keyword">ON</span> Orders (ProductID);</span><br></pre></td></tr></table></figure><h4 id="执行计划优化：-1"><a href="#执行计划优化：-1" class="headerlink" title="执行计划优化："></a>执行计划优化：</h4><ul><li>确保查询能够利用 <code>idx_ProductID</code> 索引，避免全表扫描。</li></ul><h3 id="3-查询优化：查询某个订单的详细信息"><a href="#3-查询优化：查询某个订单的详细信息" class="headerlink" title="3. 查询优化：查询某个订单的详细信息"></a>3. <strong>查询优化：查询某个订单的详细信息</strong></h3><h4 id="查询需求：-2"><a href="#查询需求：-2" class="headerlink" title="查询需求："></a>查询需求：</h4><p>查询某个订单的详细信息。</p><h4 id="查询语句：-2"><a href="#查询语句：-2" class="headerlink" title="查询语句："></a>查询语句：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CustomerID, ProductID, TotalAmount, Status</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> OrderID <span class="operator">=</span> <span class="number">123456</span>;</span><br></pre></td></tr></table></figure><h4 id="优化建议：-2"><a href="#优化建议：-2" class="headerlink" title="优化建议："></a>优化建议：</h4><ul><li><strong>索引优化</strong>：因为 <code>OrderID</code> 是主键字段，SQL Server 会自动创建聚集索引。查询 <code>OrderID</code> 字段时，查询会直接利用聚集索引。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 聚集索引已自动创建，无需额外创建</span></span><br></pre></td></tr></table></figure><h4 id="执行计划优化：-2"><a href="#执行计划优化：-2" class="headerlink" title="执行计划优化："></a>执行计划优化：</h4><ul><li>确保查询只扫描一行数据，利用 <code>OrderID</code> 主键索引。</li></ul><h3 id="4-查询优化：查询多个客户的订单信息"><a href="#4-查询优化：查询多个客户的订单信息" class="headerlink" title="4. 查询优化：查询多个客户的订单信息"></a>4. <strong>查询优化：查询多个客户的订单信息</strong></h3><h4 id="查询需求：-3"><a href="#查询需求：-3" class="headerlink" title="查询需求："></a>查询需求：</h4><p>查询多个客户的订单信息。</p><h4 id="查询语句：-3"><a href="#查询语句：-3" class="headerlink" title="查询语句："></a>查询语句：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> OrderID, CustomerID, ProductID, TotalAmount, Status</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> CustomerID <span class="keyword">IN</span> (<span class="number">1001</span>, <span class="number">1002</span>, <span class="number">1003</span>);</span><br></pre></td></tr></table></figure><h4 id="优化建议：-3"><a href="#优化建议：-3" class="headerlink" title="优化建议："></a>优化建议：</h4><ul><li><strong>索引优化</strong>：为 <code>CustomerID</code> 创建索引，以便快速过滤出目标客户的订单。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> NONCLUSTERED INDEX idx_CustomerID</span><br><span class="line"><span class="keyword">ON</span> Orders (CustomerID);</span><br></pre></td></tr></table></figure><h4 id="执行计划优化：-3"><a href="#执行计划优化：-3" class="headerlink" title="执行计划优化："></a>执行计划优化：</h4><ul><li>确保 <code>IN</code> 子句使用了 <code>idx_CustomerID</code> 索引来优化查询。</li></ul><h3 id="5-查询优化：避免使用-SELECT"><a href="#5-查询优化：避免使用-SELECT" class="headerlink" title="5. 查询优化：避免使用 SELECT \*"></a>5. <strong>查询优化：避免使用 <code>SELECT \*</code></strong></h3><h4 id="查询需求：-4"><a href="#查询需求：-4" class="headerlink" title="查询需求："></a>查询需求：</h4><p>查询所有字段（不推荐，通常用来调试或检查表结构）。</p><h4 id="查询语句：-4"><a href="#查询语句：-4" class="headerlink" title="查询语句："></a>查询语句：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Orders;</span><br></pre></td></tr></table></figure><h4 id="优化建议：-4"><a href="#优化建议：-4" class="headerlink" title="优化建议："></a>优化建议：</h4><ul><li><strong>明确选择需要的列</strong>：避免使用 <code>SELECT *</code>，明确列出查询需要的字段，避免读取不必要的列。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> OrderID, CustomerID, TotalAmount <span class="keyword">FROM</span> Orders;</span><br></pre></td></tr></table></figure><h3 id="6-查询优化：使用-JOIN-进行多表查询"><a href="#6-查询优化：使用-JOIN-进行多表查询" class="headerlink" title="6. 查询优化：使用 JOIN 进行多表查询"></a>6. <strong>查询优化：使用 <code>JOIN</code> 进行多表查询</strong></h3><h4 id="查询需求：-5"><a href="#查询需求：-5" class="headerlink" title="查询需求："></a>查询需求：</h4><p>查询某个客户的订单信息以及相关的产品信息。假设有一个 <code>Products</code> 表，包含 <code>ProductID</code> 和 <code>ProductName</code>。</p><h4 id="查询语句：-5"><a href="#查询语句：-5" class="headerlink" title="查询语句："></a>查询语句：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> o.OrderID, o.TotalAmount, p.ProductName</span><br><span class="line"><span class="keyword">FROM</span> Orders o</span><br><span class="line"><span class="keyword">JOIN</span> Products p <span class="keyword">ON</span> o.ProductID <span class="operator">=</span> p.ProductID</span><br><span class="line"><span class="keyword">WHERE</span> o.CustomerID <span class="operator">=</span> <span class="number">1001</span></span><br><span class="line">  <span class="keyword">AND</span> o.OrderDate <span class="keyword">BETWEEN</span> <span class="string">&#x27;2024-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2024-12-31&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="优化建议：-5"><a href="#优化建议：-5" class="headerlink" title="优化建议："></a>优化建议：</h4><ul><li><strong>索引优化</strong>：为 <code>Orders</code> 表的 <code>CustomerID</code>、<code>OrderDate</code> 和 <code>ProductID</code> 创建复合索引，为 <code>Products</code> 表的 <code>ProductID</code> 创建索引，以加速 <code>JOIN</code> 查询。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> NONCLUSTERED INDEX idx_Orders_Customer_OrderDate_Product</span><br><span class="line"><span class="keyword">ON</span> Orders (CustomerID, OrderDate, ProductID);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> NONCLUSTERED INDEX idx_Products_ProductID</span><br><span class="line"><span class="keyword">ON</span> Products (ProductID);</span><br></pre></td></tr></table></figure><h4 id="执行计划优化：-4"><a href="#执行计划优化：-4" class="headerlink" title="执行计划优化："></a>执行计划优化：</h4><ul><li>确保执行计划中使用了 <code>JOIN</code> 的相关索引，避免全表扫描。</li></ul><h3 id="7-查询优化：分页查询"><a href="#7-查询优化：分页查询" class="headerlink" title="7. 查询优化：分页查询"></a>7. <strong>查询优化：分页查询</strong></h3><h4 id="查询需求：-6"><a href="#查询需求：-6" class="headerlink" title="查询需求："></a>查询需求：</h4><p>查询某个时间段内的客户订单，并实现分页功能。</p><h4 id="查询语句：-6"><a href="#查询语句：-6" class="headerlink" title="查询语句："></a>查询语句：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> OrderID, CustomerID, TotalAmount, Status</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> OrderDate <span class="keyword">BETWEEN</span> <span class="string">&#x27;2024-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2024-12-31&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> OrderDate</span><br><span class="line"><span class="keyword">OFFSET</span> <span class="number">0</span> <span class="keyword">ROWS</span> <span class="keyword">FETCH</span> NEXT <span class="number">20</span> <span class="keyword">ROWS</span> <span class="keyword">ONLY</span>;</span><br></pre></td></tr></table></figure><h4 id="优化建议：-6"><a href="#优化建议：-6" class="headerlink" title="优化建议："></a>优化建议：</h4><ul><li><strong>索引优化</strong>：确保在 <code>OrderDate</code> 上有合适的索引，能够加速排序操作。</li><li>使用 <code>OFFSET</code> 和 <code>FETCH</code> 语句实现分页查询，避免一次性加载大量数据。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> NONCLUSTERED INDEX idx_OrderDate</span><br><span class="line"><span class="keyword">ON</span> Orders (OrderDate);</span><br></pre></td></tr></table></figure><h3 id="8-避免过多的子查询"><a href="#8-避免过多的子查询" class="headerlink" title="8. 避免过多的子查询"></a>8. <strong>避免过多的子查询</strong></h3><h4 id="查询需求：-7"><a href="#查询需求：-7" class="headerlink" title="查询需求："></a>查询需求：</h4><p>查询某个客户在某段时间内的订单总金额。</p><h4 id="查询语句：-7"><a href="#查询语句：-7" class="headerlink" title="查询语句："></a>查询语句：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CustomerID, </span><br><span class="line">       (<span class="keyword">SELECT</span> <span class="built_in">SUM</span>(TotalAmount) <span class="keyword">FROM</span> Orders <span class="keyword">WHERE</span> CustomerID <span class="operator">=</span> <span class="number">1001</span> <span class="keyword">AND</span> OrderDate <span class="keyword">BETWEEN</span> <span class="string">&#x27;2024-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2024-12-31&#x27;</span>) <span class="keyword">AS</span> TotalSpent</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> CustomerID <span class="operator">=</span> <span class="number">1001</span>;</span><br></pre></td></tr></table></figure><h4 id="优化建议：-7"><a href="#优化建议：-7" class="headerlink" title="优化建议："></a>优化建议：</h4><ul><li><strong>避免使用子查询</strong>：尽量避免在 <code>SELECT</code> 语句中使用子查询，可以改为 <code>JOIN</code> 或 <code>GROUP BY</code> 来提高效率。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> o.CustomerID, <span class="built_in">SUM</span>(o.TotalAmount) <span class="keyword">AS</span> TotalSpent</span><br><span class="line"><span class="keyword">FROM</span> Orders o</span><br><span class="line"><span class="keyword">WHERE</span> o.CustomerID <span class="operator">=</span> <span class="number">1001</span></span><br><span class="line">  <span class="keyword">AND</span> o.OrderDate <span class="keyword">BETWEEN</span> <span class="string">&#x27;2024-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2024-12-31&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> o.CustomerID;</span><br></pre></td></tr></table></figure><h3 id="小结一下-1"><a href="#小结一下-1" class="headerlink" title="小结一下"></a>小结一下</h3><p>通过优化 SQL 查询语句、合理使用索引以及减少不必要的操作，我们能够显著提高查询性能。具体做法包括：</p><ul><li>创建合适的索引（单列索引和复合索引）。</li><li>优化查询语句，避免使用 <code>SELECT *</code> 和过多的子查询。</li><li>使用合适的分页技术和 <code>JOIN</code> 优化多表查询。</li><li>分析查询执行计划，确保查询高效执行。</li></ul><p>这些优化措施可以帮助 SQL Server 在面对大量数据时保持高效的查询性能。</p><h2 id="3-数据分区和分表"><a href="#3-数据分区和分表" class="headerlink" title="3. 数据分区和分表"></a>3. 数据分区和分表</h2><ul><li><strong>表分区</strong>：对于非常大的表，可以考虑使用表分区。表分区可以根据某些条件（例如时间、ID 范围等）将数据分割到多个物理文件中，这样查询时只访问相关的分区，减少了全表扫描的开销。</li><li><strong>水平拆分（Sharding）</strong>：将数据分散到多个独立的表或数据库中，通常基于某种规则（如区域、日期等）。每个表包含数据的一个子集，可以提高查询效率。</li></ul><p>数据分区（Partitioning）和分表（Sharding）是优化数据库性能的关键手段，尤其在处理大数据量时。通过数据分区或分表，可以有效地减少查询和写入的压力，提高数据访问效率。以下是基于业务场景的具体代码案例，展示如何使用数据分区和分表来优化 SQL Server 的性能。</p><h3 id="业务场景-2"><a href="#业务场景-2" class="headerlink" title="业务场景"></a>业务场景</h3><p>假设我们有一个订单系统，<code>Orders</code> 表记录了所有订单信息。随着订单量的增加，单表的查询和维护变得越来越困难。因此，我们需要使用分区和分表技术来优化数据库的性能。</p><h3 id="1-数据分区（Partitioning）"><a href="#1-数据分区（Partitioning）" class="headerlink" title="1. 数据分区（Partitioning）"></a>1. <strong>数据分区（Partitioning）</strong></h3><p>数据分区是在单一表上进行逻辑分区，它允许将一个大的表按某个规则（如时间范围、数值区间等）分成多个物理段（分区）。每个分区可以独立管理，查询可以在特定的分区内进行，从而提高查询性能。</p><h4 id="业务需求"><a href="#业务需求" class="headerlink" title="业务需求"></a>业务需求</h4><ul><li>按照订单日期（<code>OrderDate</code>）将 <code>Orders</code> 表分区，以便在查询时快速定位到特定时间段内的订单。</li></ul><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><ol><li>创建分区函数（Partition Function）和分区方案（Partition Scheme）。</li><li>在 <code>Orders</code> 表上应用分区。</li></ol><h4 id="创建分区函数（Partition-Function）"><a href="#创建分区函数（Partition-Function）" class="headerlink" title="创建分区函数（Partition Function）"></a>创建分区函数（Partition Function）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建分区函数：按年度分区</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PARTITION</span> <span class="keyword">FUNCTION</span> OrderDatePartitionFunc (<span class="type">DATE</span>)</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">RANGE</span> <span class="keyword">RIGHT</span> <span class="keyword">FOR</span> <span class="keyword">VALUES</span> (<span class="string">&#x27;2023-01-01&#x27;</span>, <span class="string">&#x27;2024-01-01&#x27;</span>, <span class="string">&#x27;2025-01-01&#x27;</span>);</span><br></pre></td></tr></table></figure><p>该分区函数将根据订单日期（<code>OrderDate</code>）把数据分为多个区间，每个区间的范围是按年划分的。</p><h4 id="创建分区方案（Partition-Scheme）"><a href="#创建分区方案（Partition-Scheme）" class="headerlink" title="创建分区方案（Partition Scheme）"></a>创建分区方案（Partition Scheme）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建分区方案：将分区函数应用到物理文件组</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PARTITION</span> SCHEME OrderDatePartitionScheme</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">PARTITION</span> OrderDatePartitionFunc</span><br><span class="line"><span class="keyword">TO</span> ([<span class="keyword">PRIMARY</span>], [FG_2023], [FG_2024], [FG_2025]);</span><br></pre></td></tr></table></figure><p>此方案为每个分区指定一个物理文件组（如 <code>PRIMARY</code>、<code>FG_2023</code> 等）。</p><h4 id="创建分区表"><a href="#创建分区表" class="headerlink" title="创建分区表"></a>创建分区表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建分区表：应用分区方案</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Orders</span><br><span class="line">(</span><br><span class="line">    OrderID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    CustomerID <span class="type">INT</span>,</span><br><span class="line">    OrderDate <span class="type">DATE</span>,</span><br><span class="line">    ProductID <span class="type">INT</span>,</span><br><span class="line">    TotalAmount <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    Status <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">ON</span> OrderDatePartitionScheme (OrderDate);</span><br></pre></td></tr></table></figure><p><code>Orders</code> 表按 <code>OrderDate</code> 字段进行分区，数据会根据日期分布到不同的物理文件组中。</p><h4 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询 2024 年的订单，查询仅会访问相应的分区，提高查询效率</span></span><br><span class="line"><span class="keyword">SELECT</span> OrderID, CustomerID, ProductID, TotalAmount</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> OrderDate <span class="keyword">BETWEEN</span> <span class="string">&#x27;2024-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2024-12-31&#x27;</span>;</span><br></pre></td></tr></table></figure><p>通过分区，查询只会扫描相关分区的数据，从而提高查询速度。</p><h3 id="2-数据分表（Sharding）"><a href="#2-数据分表（Sharding）" class="headerlink" title="2. 数据分表（Sharding）"></a>2. <strong>数据分表（Sharding）</strong></h3><p>分表是将数据水平拆分到多个物理表中，每个表存储一部分数据。常见的分表策略包括按范围分表、按哈希值分表等。分表可以显著提升查询性能，但需要管理多个表及其关系。</p><h4 id="业务需求-1"><a href="#业务需求-1" class="headerlink" title="业务需求"></a>业务需求</h4><ul><li>按 <code>CustomerID</code> 将 <code>Orders</code> 表进行分表，客户ID为基础将数据分配到不同的表中。</li><li>客户ID的范围是均匀的，因此我们可以使用哈希分表策略。</li></ul><h4 id="步骤：-1"><a href="#步骤：-1" class="headerlink" title="步骤："></a>步骤：</h4><ol><li>创建多个分表。</li><li>在应用层处理分表逻辑。</li></ol><h4 id="创建分表"><a href="#创建分表" class="headerlink" title="创建分表"></a>创建分表</h4><p>假设我们决定将 <code>Orders</code> 表按 <code>CustomerID</code> 的哈希值分成 4 个表。可以通过以下方式创建 4 个分表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建 Orders_1 分表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Orders_1</span><br><span class="line">(</span><br><span class="line">    OrderID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    CustomerID <span class="type">INT</span>,</span><br><span class="line">    OrderDate <span class="type">DATE</span>,</span><br><span class="line">    ProductID <span class="type">INT</span>,</span><br><span class="line">    TotalAmount <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    Status <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建 Orders_2 分表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Orders_2</span><br><span class="line">(</span><br><span class="line">    OrderID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    CustomerID <span class="type">INT</span>,</span><br><span class="line">    OrderDate <span class="type">DATE</span>,</span><br><span class="line">    ProductID <span class="type">INT</span>,</span><br><span class="line">    TotalAmount <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    Status <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建 Orders_3 分表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Orders_3</span><br><span class="line">(</span><br><span class="line">    OrderID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    CustomerID <span class="type">INT</span>,</span><br><span class="line">    OrderDate <span class="type">DATE</span>,</span><br><span class="line">    ProductID <span class="type">INT</span>,</span><br><span class="line">    TotalAmount <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    Status <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建 Orders_4 分表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Orders_4</span><br><span class="line">(</span><br><span class="line">    OrderID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    CustomerID <span class="type">INT</span>,</span><br><span class="line">    OrderDate <span class="type">DATE</span>,</span><br><span class="line">    ProductID <span class="type">INT</span>,</span><br><span class="line">    TotalAmount <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    Status <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="分表逻辑"><a href="#分表逻辑" class="headerlink" title="分表逻辑"></a>分表逻辑</h4><p>在应用层，我们需要实现一个分表路由逻辑，通过哈希值来确定应该向哪个表插入数据或查询数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 示例：根据 CustomerID 哈希值选择分表</span></span><br><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@CustomerID</span> <span class="type">INT</span> <span class="operator">=</span> <span class="number">1001</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@TableSuffix</span> <span class="type">INT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用哈希算法来决定表</span></span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@TableSuffix</span> <span class="operator">=</span> <span class="variable">@CustomerID</span> <span class="operator">%</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line">IF <span class="variable">@TableSuffix</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> Orders_1 (OrderID, CustomerID, OrderDate, ProductID, TotalAmount, Status)</span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="number">123456</span>, <span class="number">1001</span>, <span class="string">&#x27;2024-01-01&#x27;</span>, <span class="number">101</span>, <span class="number">150.00</span>, <span class="string">&#x27;Paid&#x27;</span>);</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">ELSE</span> IF <span class="variable">@TableSuffix</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> Orders_2 (OrderID, CustomerID, OrderDate, ProductID, TotalAmount, Status)</span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="number">123457</span>, <span class="number">1002</span>, <span class="string">&#x27;2024-01-02&#x27;</span>, <span class="number">102</span>, <span class="number">250.00</span>, <span class="string">&#x27;Pending&#x27;</span>);</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">ELSE</span> IF <span class="variable">@TableSuffix</span> <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> Orders_3 (OrderID, CustomerID, OrderDate, ProductID, TotalAmount, Status)</span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="number">123458</span>, <span class="number">1003</span>, <span class="string">&#x27;2024-01-03&#x27;</span>, <span class="number">103</span>, <span class="number">350.00</span>, <span class="string">&#x27;Shipped&#x27;</span>);</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> Orders_4 (OrderID, CustomerID, OrderDate, ProductID, TotalAmount, Status)</span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="number">123459</span>, <span class="number">1004</span>, <span class="string">&#x27;2024-01-04&#x27;</span>, <span class="number">104</span>, <span class="number">450.00</span>, <span class="string">&#x27;Delivered&#x27;</span>);</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><h4 id="查询逻辑"><a href="#查询逻辑" class="headerlink" title="查询逻辑"></a>查询逻辑</h4><p>为了查询某个客户的订单，我们也需要在应用层决定查询哪个分表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询某个客户的订单</span></span><br><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@CustomerID</span> <span class="type">INT</span> <span class="operator">=</span> <span class="number">1001</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@TableSuffix</span> <span class="type">INT</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@TableSuffix</span> <span class="operator">=</span> <span class="variable">@CustomerID</span> <span class="operator">%</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询数据</span></span><br><span class="line">IF <span class="variable">@TableSuffix</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Orders_1 <span class="keyword">WHERE</span> CustomerID <span class="operator">=</span> <span class="variable">@CustomerID</span>;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">ELSE</span> IF <span class="variable">@TableSuffix</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Orders_2 <span class="keyword">WHERE</span> CustomerID <span class="operator">=</span> <span class="variable">@CustomerID</span>;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">ELSE</span> IF <span class="variable">@TableSuffix</span> <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Orders_3 <span class="keyword">WHERE</span> CustomerID <span class="operator">=</span> <span class="variable">@CustomerID</span>;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Orders_4 <span class="keyword">WHERE</span> CustomerID <span class="operator">=</span> <span class="variable">@CustomerID</span>;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><h3 id="3-分区和分表的选择"><a href="#3-分区和分表的选择" class="headerlink" title="3. 分区和分表的选择"></a>3. <strong>分区和分表的选择</strong></h3><ul><li><strong>分区</strong>：适用于对一个表进行物理划分，但仍然保持数据的逻辑统一性。例如，按时间（如订单日期）分区可以有效提高时间范围查询的性能。</li><li><strong>分表</strong>：适用于数据量特别大的情况，将数据拆分到多个表中，以减少单个表的查询压力。通常采用哈希分表或者范围分表。</li></ul><h3 id="小结一下-2"><a href="#小结一下-2" class="headerlink" title="小结一下"></a>小结一下</h3><ul><li><strong>分区</strong>可以让你在一个大的表上进行逻辑划分，在查询时只访问相关的分区，提高性能。</li><li><strong>分表</strong>则是将数据水平拆分到多个物理表，通常用于处理极大数据量的场景。</li><li>在 SQL Server 中实现分区和分表需要对表的设计、索引设计和查询策略进行综合考虑，以确保数据访问效率和维护的便利性。</li></ul><h2 id="4-数据归档"><a href="#4-数据归档" class="headerlink" title="4. 数据归档"></a>4. 数据归档</h2><ul><li><strong>归档旧数据</strong>：对于已经不常查询的数据，可以将其归档到独立的历史表或数据库中，从而减轻主数据库的负担。只保留近期数据在主表中，优化查询性能。</li><li><strong>压缩旧数据</strong>：可以通过压缩技术来存储归档数据，节省存储空间。</li></ul><p>数据归档是指将不再频繁访问的历史数据从主数据库中移除，并将其存储在归档系统或表中，从而提高主数据库的性能。数据归档通常用于老旧数据、历史记录等不再活跃但需要保留的数据。</p><h3 id="业务场景-3"><a href="#业务场景-3" class="headerlink" title="业务场景"></a>业务场景</h3><p>假设我们有一个订单系统，<code>Orders</code> 表记录了所有订单信息。随着时间的推移，订单数据量急剧增加，但在实际业务中，超过一定时间的订单数据查询频率下降。为了提高数据库性能，我们决定将超过 1 年的订单数据从主表中移除并存档到归档表中。</p><h3 id="步骤：-2"><a href="#步骤：-2" class="headerlink" title="步骤："></a>步骤：</h3><ol><li>创建主表（<code>Orders</code>）和归档表（<code>ArchivedOrders</code>）。</li><li>定期将超过 1 年的订单数据从 <code>Orders</code> 表移到 <code>ArchivedOrders</code> 表。</li><li>确保归档数据的查询不会影响到主表的性能。</li></ol><h3 id="1-创建主表和归档表"><a href="#1-创建主表和归档表" class="headerlink" title="1. 创建主表和归档表"></a>1. 创建主表和归档表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建主订单表 Orders</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Orders</span><br><span class="line">(</span><br><span class="line">    OrderID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    CustomerID <span class="type">INT</span>,</span><br><span class="line">    OrderDate <span class="type">DATE</span>,</span><br><span class="line">    ProductID <span class="type">INT</span>,</span><br><span class="line">    TotalAmount <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    Status <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建归档表 ArchivedOrders</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ArchivedOrders</span><br><span class="line">(</span><br><span class="line">    OrderID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    CustomerID <span class="type">INT</span>,</span><br><span class="line">    OrderDate <span class="type">DATE</span>,</span><br><span class="line">    ProductID <span class="type">INT</span>,</span><br><span class="line">    TotalAmount <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    Status <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="2-归档操作（将超过-1-年的订单移至归档表）"><a href="#2-归档操作（将超过-1-年的订单移至归档表）" class="headerlink" title="2. 归档操作（将超过 1 年的订单移至归档表）"></a>2. 归档操作（将超过 1 年的订单移至归档表）</h3><p>为了定期将过期的订单移至归档表，可以使用定时任务（如 SQL Server Agent 作业）来执行这个操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 将超过 1 年的订单数据从 Orders 表移到 ArchivedOrders 表</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> ArchivedOrders (OrderID, CustomerID, OrderDate, ProductID, TotalAmount, Status)</span><br><span class="line"><span class="keyword">SELECT</span> OrderID, CustomerID, OrderDate, ProductID, TotalAmount, Status</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> OrderDate <span class="operator">&lt;</span> DATEADD(<span class="keyword">YEAR</span>, <span class="number">-1</span>, GETDATE());</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除 Orders 表中超过 1 年的订单数据</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> OrderDate <span class="operator">&lt;</span> DATEADD(<span class="keyword">YEAR</span>, <span class="number">-1</span>, GETDATE());</span><br></pre></td></tr></table></figure><p>这段代码会将 <code>Orders</code> 表中 <code>OrderDate</code> 小于当前日期 1 年的订单数据插入到 <code>ArchivedOrders</code> 表，并将这些数据从 <code>Orders</code> 表中删除。</p><h3 id="3-定时归档任务（使用-SQL-Server-Agent）"><a href="#3-定时归档任务（使用-SQL-Server-Agent）" class="headerlink" title="3. 定时归档任务（使用 SQL Server Agent）"></a>3. 定时归档任务（使用 SQL Server Agent）</h3><p>我们可以使用 SQL Server Agent 来创建一个定时任务，定期执行数据归档操作。例如，每天运行一次，将 1 年前的订单数据归档：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在 SQL Server Agent 中创建作业来执行归档操作</span></span><br><span class="line">USE msdb;</span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXEC</span> sp_add_job</span><br><span class="line">    <span class="variable">@job</span>_name <span class="operator">=</span> N<span class="string">&#x27;ArchiveOldOrders&#x27;</span>;</span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXEC</span> sp_add_jobstep</span><br><span class="line">    <span class="variable">@job</span>_name <span class="operator">=</span> N<span class="string">&#x27;ArchiveOldOrders&#x27;</span>,</span><br><span class="line">    <span class="variable">@step</span>_name <span class="operator">=</span> N<span class="string">&#x27;ArchiveOrdersStep&#x27;</span>,</span><br><span class="line">    <span class="variable">@subsystem</span> <span class="operator">=</span> N<span class="string">&#x27;TSQL&#x27;</span>,</span><br><span class="line">    <span class="variable">@command</span> <span class="operator">=</span> N<span class="string">&#x27;</span></span><br><span class="line"><span class="string">        INSERT INTO ArchivedOrders (OrderID, CustomerID, OrderDate, ProductID, TotalAmount, Status)</span></span><br><span class="line"><span class="string">        SELECT OrderID, CustomerID, OrderDate, ProductID, TotalAmount, Status</span></span><br><span class="line"><span class="string">        FROM Orders</span></span><br><span class="line"><span class="string">        WHERE OrderDate &lt; DATEADD(YEAR, -1, GETDATE());</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        DELETE FROM Orders</span></span><br><span class="line"><span class="string">        WHERE OrderDate &lt; DATEADD(YEAR, -1, GETDATE());</span></span><br><span class="line"><span class="string">    &#x27;</span>,</span><br><span class="line">    <span class="variable">@database</span>_name <span class="operator">=</span> N<span class="string">&#x27;VGDB&#x27;</span>;</span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置作业的调度，例如每天运行一次</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_add_schedule</span><br><span class="line">    <span class="variable">@schedule</span>_name <span class="operator">=</span> N<span class="string">&#x27;ArchiveOrdersDaily&#x27;</span>,</span><br><span class="line">    <span class="variable">@enabled</span> <span class="operator">=</span> <span class="number">1</span>,</span><br><span class="line">    <span class="variable">@freq</span>_type <span class="operator">=</span> <span class="number">4</span>, <span class="comment">-- 每天</span></span><br><span class="line">    <span class="variable">@freq</span>_interval <span class="operator">=</span> <span class="number">1</span>, <span class="comment">-- 每天执行一次</span></span><br><span class="line">    <span class="variable">@active</span>_start_time <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXEC</span> sp_attach_schedule</span><br><span class="line">    <span class="variable">@job</span>_name <span class="operator">=</span> N<span class="string">&#x27;ArchiveOldOrders&#x27;</span>,</span><br><span class="line">    <span class="variable">@schedule</span>_name <span class="operator">=</span> N<span class="string">&#x27;ArchiveOrdersDaily&#x27;</span>;</span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 启动作业</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_start_job <span class="variable">@job</span>_name <span class="operator">=</span> N<span class="string">&#x27;ArchiveOldOrders&#x27;</span>;</span><br><span class="line">GO</span><br></pre></td></tr></table></figure><h3 id="4-查询归档数据"><a href="#4-查询归档数据" class="headerlink" title="4. 查询归档数据"></a>4. 查询归档数据</h3><p>归档后的数据依然可以查询，但不会影响主表的查询性能。为了查找某个客户的历史订单，可以查询归档表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询某个客户的历史订单</span></span><br><span class="line"><span class="keyword">SELECT</span> OrderID, CustomerID, OrderDate, ProductID, TotalAmount, Status</span><br><span class="line"><span class="keyword">FROM</span> ArchivedOrders</span><br><span class="line"><span class="keyword">WHERE</span> CustomerID <span class="operator">=</span> <span class="number">1001</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> OrderDate <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><h3 id="5-优化与注意事项"><a href="#5-优化与注意事项" class="headerlink" title="5. 优化与注意事项"></a>5. 优化与注意事项</h3><ul><li><strong>归档策略</strong>：可以根据实际业务需求选择合适的时间范围（例如，3 个月、6 个月或 1 年）。可以通过调整 <code>WHERE</code> 条件来修改归档规则。</li><li><strong>性能优化</strong>：定期归档操作可以减轻主表的负担，提高查询性能。定期删除旧数据也能减少主表的存储空间。</li><li><strong>归档数据的备份和恢复</strong>：归档数据同样需要定期备份，并能够在需要时恢复。确保归档表也包括足够的备份策略。</li></ul><h3 id="6-归档与清理数据的另一个选项：软删除"><a href="#6-归档与清理数据的另一个选项：软删除" class="headerlink" title="6. 归档与清理数据的另一个选项：软删除"></a>6. 归档与清理数据的另一个选项：软删除</h3><p>在某些情况下，数据归档后并没有从数据库中完全删除，而是标记为“已归档”或“已删除”。这种方法的优点是可以随时恢复数据，而不会丢失。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在 Orders 表中添加 Archived 标志</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Orders</span><br><span class="line"><span class="keyword">ADD</span> Archived BIT <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将数据标记为已归档</span></span><br><span class="line"><span class="keyword">UPDATE</span> Orders</span><br><span class="line"><span class="keyword">SET</span> Archived <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">WHERE</span> OrderDate <span class="operator">&lt;</span> DATEADD(<span class="keyword">YEAR</span>, <span class="number">-1</span>, GETDATE());</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询未归档的数据</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Orders <span class="keyword">WHERE</span> Archived <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询归档数据</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Orders <span class="keyword">WHERE</span> Archived <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>通过这种方法，归档的订单仍然保留在主表中，但通过 <code>Archived</code> 字段可以区分已归档和未归档的订单。</p><h3 id="小结一下-3"><a href="#小结一下-3" class="headerlink" title="小结一下"></a>小结一下</h3><p>数据归档操作是管理大数据量数据库的一种有效策略。通过定期将历史数据从主数据库表中迁移到归档表，可以显著提高数据库的查询性能，同时确保历史数据得以保留，便于以后查询和审计。</p><h2 id="5-存储和硬件优化"><a href="#5-存储和硬件优化" class="headerlink" title="5. 存储和硬件优化"></a>5. 存储和硬件优化</h2><ul><li><strong>磁盘 I&#x2F;O 优化</strong>：数据库的性能受到磁盘 I&#x2F;O 的限制，尤其是在处理大量数据时。使用 SSD 存储比传统的硬盘（HDD）提供更快的 I&#x2F;O 性能。</li><li><strong>增加内存</strong>：增加 SQL Server 的内存，可以使数据库缓冲池更大，从而减少磁盘 I&#x2F;O，提升查询性能。</li><li><strong>使用 RAID 配置</strong>：使用 RAID 10 或其他 RAID 配置，确保数据读写的高效性和可靠性。</li></ul><p>存储和硬件优化是提升数据库性能的关键部分，尤其是在大规模数据处理的环境中。通过合理的硬件资源分配、存储结构优化以及数据库配置，可以显著提高性能。下面我们将针对一个电商平台的订单系统来讲解如何在存储和硬件层面优化 SQL Server。</p><h3 id="业务场景："><a href="#业务场景：" class="headerlink" title="业务场景："></a>业务场景：</h3><p>假设你有一个电商平台，订单数据存储在 SQL Server 中，订单数量日益增加，导致查询性能下降。在此场景中，我们可以通过以下方法进行存储和硬件优化。</p><h3 id="优化策略："><a href="#优化策略：" class="headerlink" title="优化策略："></a>优化策略：</h3><ol><li><strong>磁盘 I&#x2F;O 优化</strong>：<ul><li>使用 SSD 替代传统硬盘（HDD）以提高读写速度。</li><li>将数据文件、日志文件和临时文件存储在不同的物理磁盘上。</li></ul></li><li><strong>表和索引存储</strong>：<ul><li>使用适当的存储格式和文件组织方式，如分区表和表压缩。</li><li>将频繁访问的表和索引放置在高性能的磁盘上。</li></ul></li><li><strong>硬件资源配置</strong>：<ul><li>增加内存以支持更多的数据缓存，减少磁盘访问。</li><li>使用多核 CPU 以提高并发查询的处理能力。</li></ul></li><li><strong>数据压缩</strong>：<ul><li>在 SQL Server 中启用数据压缩，以减少磁盘空间的使用并提高 I&#x2F;O 性能。</li></ul></li></ol><h3 id="1-创建表并优化存储"><a href="#1-创建表并优化存储" class="headerlink" title="1. 创建表并优化存储"></a>1. 创建表并优化存储</h3><p>首先，我们创建订单表，并为订单表的 <code>OrderID</code> 列创建聚集索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建 Orders 表并优化存储</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Orders</span><br><span class="line">(</span><br><span class="line">    OrderID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY CLUSTERED,  <span class="comment">-- 聚集索引</span></span><br><span class="line">    CustomerID <span class="type">INT</span>,</span><br><span class="line">    OrderDate DATETIME,</span><br><span class="line">    ProductID <span class="type">INT</span>,</span><br><span class="line">    TotalAmount <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    Status <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">) </span><br><span class="line"><span class="keyword">ON</span> [<span class="keyword">PRIMARY</span>]</span><br><span class="line"><span class="keyword">WITH</span> (DATA_COMPRESSION <span class="operator">=</span> PAGE);  <span class="comment">-- 启用数据页压缩以节省空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 启用非聚集索引，用于优化查询</span></span><br><span class="line"><span class="keyword">CREATE</span> NONCLUSTERED INDEX idx_OrderDate</span><br><span class="line"><span class="keyword">ON</span> Orders(OrderDate)</span><br><span class="line"><span class="keyword">WITH</span> (DATA_COMPRESSION <span class="operator">=</span> PAGE);  <span class="comment">-- 同样启用数据压缩</span></span><br></pre></td></tr></table></figure><p>通过使用 <code>DATA_COMPRESSION = PAGE</code>，我们启用了 SQL Server 的数据压缩功能，以节省存储空间并提高磁盘 I&#x2F;O 性能。<code>PAGE</code> 压缩比 <code>ROW</code> 压缩更高效，适合大型数据表。</p><h3 id="2-分区表优化"><a href="#2-分区表优化" class="headerlink" title="2. 分区表优化"></a>2. 分区表优化</h3><p>在订单数据量不断增加的情况下，我们可以将订单表进行分区。根据 <code>OrderDate</code> 列将数据划分为不同的分区，以减少查询时的扫描范围，提高查询效率。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建分区函数</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PARTITION</span> <span class="keyword">FUNCTION</span> pf_OrderDate (DATETIME)</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">RANGE</span> <span class="keyword">RIGHT</span> <span class="keyword">FOR</span> <span class="keyword">VALUES</span> (<span class="string">&#x27;2022-01-01&#x27;</span>, <span class="string">&#x27;2023-01-01&#x27;</span>, <span class="string">&#x27;2024-01-01&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建分区方案</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PARTITION</span> SCHEME ps_OrderDate</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">PARTITION</span> pf_OrderDate</span><br><span class="line"><span class="keyword">TO</span> ([<span class="keyword">PRIMARY</span>], [<span class="keyword">PRIMARY</span>], [<span class="keyword">PRIMARY</span>], [<span class="keyword">PRIMARY</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建分区表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Orders</span><br><span class="line">(</span><br><span class="line">    OrderID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY CLUSTERED, </span><br><span class="line">    CustomerID <span class="type">INT</span>,</span><br><span class="line">    OrderDate DATETIME,</span><br><span class="line">    ProductID <span class="type">INT</span>,</span><br><span class="line">    TotalAmount <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    Status <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">) </span><br><span class="line"><span class="keyword">ON</span> ps_OrderDate(OrderDate);  <span class="comment">-- 按 OrderDate 列进行分区</span></span><br></pre></td></tr></table></figure><p>在此代码中，我们根据 <code>OrderDate</code> 列的年份划分了不同的分区（如 2022 年、2023 年和 2024 年的订单数据）。这样可以使查询在某一特定时间范围内的性能更高，因为 SQL Server 只需要扫描相关分区的数据，而不是整个表。</p><h3 id="3-硬件优化配置"><a href="#3-硬件优化配置" class="headerlink" title="3. 硬件优化配置"></a>3. 硬件优化配置</h3><h4 id="3-1-确保使用-SSD-磁盘"><a href="#3-1-确保使用-SSD-磁盘" class="headerlink" title="3.1. 确保使用 SSD 磁盘"></a>3.1. 确保使用 SSD 磁盘</h4><p>SSD 磁盘比传统硬盘的读写速度快，因此将数据库的主要数据文件、日志文件和临时文件分别存储在不同的磁盘上（最好是 SSD）可以提高性能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 将 SQL Server 数据文件 (.mdf) 存储在 SSD 磁盘</span><br><span class="line">-- 将日志文件 (.ldf) 存储在 SSD 磁盘</span><br><span class="line">-- 将临时数据库文件 (.ndf) 存储在 SSD 磁盘</span><br></pre></td></tr></table></figure><h4 id="3-2-配置-SQL-Server-内存"><a href="#3-2-配置-SQL-Server-内存" class="headerlink" title="3.2. 配置 SQL Server 内存"></a>3.2. 配置 SQL Server 内存</h4><p>将 SQL Server 的内存设置为最大化，以便更多数据可以缓存在内存中，从而减少磁盘 I&#x2F;O。以下为如何设置 SQL Server 的最大内存配置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看当前内存设置</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;show advanced options&#x27;</span>, <span class="number">1</span>;</span><br><span class="line">RECONFIGURE;</span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;max server memory (MB)&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置最大内存为 16 GB</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;max server memory (MB)&#x27;</span>, <span class="number">16384</span>;</span><br><span class="line">RECONFIGURE;</span><br></pre></td></tr></table></figure><p>通过适当的内存配置，SQL Server 可以将更多数据缓存在内存中，从而减少对磁盘的访问，提高查询响应速度。</p><h4 id="3-3-配置-SQL-Server-并行处理"><a href="#3-3-配置-SQL-Server-并行处理" class="headerlink" title="3.3. 配置 SQL Server 并行处理"></a>3.3. 配置 SQL Server 并行处理</h4><p>如果服务器具有多核 CPU，可以通过设置 SQL Server 允许更多的并行查询操作，从而提高多线程查询的处理能力。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看当前并行度配置</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;max degree of parallelism&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置为 4，允许最多 4 个 CPU 并行处理查询</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;max degree of parallelism&#x27;</span>, <span class="number">4</span>;</span><br><span class="line">RECONFIGURE;</span><br></pre></td></tr></table></figure><h3 id="4-磁盘-I-x2F-O-优化：分开存储数据文件、日志文件和临时文件"><a href="#4-磁盘-I-x2F-O-优化：分开存储数据文件、日志文件和临时文件" class="headerlink" title="4. 磁盘 I&#x2F;O 优化：分开存储数据文件、日志文件和临时文件"></a>4. 磁盘 I&#x2F;O 优化：分开存储数据文件、日志文件和临时文件</h3><p>磁盘 I&#x2F;O 是数据库性能的瓶颈之一。为了提高数据库的性能，最好将数据文件、日志文件和临时文件存储在不同的物理磁盘上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 数据文件 (.mdf) 存储在磁盘 A</span><br><span class="line">-- 日志文件 (.ldf) 存储在磁盘 B</span><br><span class="line">-- 临时数据库文件 (.ndf) 存储在磁盘 C</span><br></pre></td></tr></table></figure><h3 id="5-数据备份和恢复优化"><a href="#5-数据备份和恢复优化" class="headerlink" title="5. 数据备份和恢复优化"></a>5. 数据备份和恢复优化</h3><p>确保定期备份数据，并使用增量备份、差异备份等方式以减少备份时的磁盘负担。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 进行完整备份</span></span><br><span class="line">BACKUP DATABASE VGDB <span class="keyword">TO</span> DISK <span class="operator">=</span> <span class="string">&#x27;D:\Backups\VGDB_full.bak&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 进行差异备份</span></span><br><span class="line">BACKUP DATABASE WGDB <span class="keyword">TO</span> DISK <span class="operator">=</span> <span class="string">&#x27;D:\Backups\VGDB_diff.bak&#x27;</span> <span class="keyword">WITH</span> DIFFERENTIAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 进行事务日志备份</span></span><br><span class="line">BACKUP LOG VGDB <span class="keyword">TO</span> DISK <span class="operator">=</span> <span class="string">&#x27;D:\Backups\VGDB_log.trn&#x27;</span>;</span><br></pre></td></tr></table></figure><p>通过这种方法，可以在系统崩溃时快速恢复数据，同时减少备份过程中对硬盘 I&#x2F;O 性能的影响。</p><h3 id="6-监控和维护"><a href="#6-监控和维护" class="headerlink" title="6. 监控和维护"></a>6. 监控和维护</h3><p>定期监控 SQL Server 的性能，并根据硬件和存储需求做出相应的调整。通过 SQL Server 的动态管理视图（DMV）来监控 I&#x2F;O 性能、查询执行计划、索引使用情况等。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看磁盘 I/O 状况</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sys.dm_io_virtual_file_stats(<span class="keyword">NULL</span>, <span class="keyword">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看查询执行计划的缓存</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sys.dm_exec_query_stats;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看当前的索引使用情况</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sys.dm_db_index_usage_stats;</span><br></pre></td></tr></table></figure><h3 id="小结一下-4"><a href="#小结一下-4" class="headerlink" title="小结一下"></a>小结一下</h3><p>通过存储和硬件优化，可以显著提升 SQL Server 数据库的性能。关键的优化措施包括使用 SSD 磁盘、将数据文件、日志文件和临时文件分开存储、启用数据压缩、使用分区表来提高查询效率以及调整内存和并行处理配置等。定期的维护和监控也能帮助你发现性能瓶颈并作出相应调整。</p><h2 id="6-数据库参数和配置优化"><a href="#6-数据库参数和配置优化" class="headerlink" title="6. 数据库参数和配置优化"></a>6. 数据库参数和配置优化</h2><ul><li><strong>调整最大并发连接数</strong>：确保 SQL Server 配置了足够的最大并发连接数，避免过多连接时导致性能下降。</li><li><strong>设置合适的内存限制</strong>：为 SQL Server 配置足够的内存（<code>max server memory</code>），避免内存溢出或过度使用磁盘交换。</li><li><strong>自动更新统计信息</strong>：确保 SQL Server 自动更新查询的统计信息（<code>AUTO_UPDATE_STATISTICS</code>），以便查询优化器选择最优执行计划。</li></ul><p>数据库参数和配置优化是确保数据库系统性能达到最佳状态的重要步骤。在高并发、高负载的场景下，合理的配置可以显著提高数据库性能，减少响应时间和延迟。以下是基于一个电商平台订单系统的业务场景，如何通过优化数据库的参数和配置来提升性能的完整代码案例。</p><h3 id="业务场景：-1"><a href="#业务场景：-1" class="headerlink" title="业务场景："></a>业务场景：</h3><p>假设电商平台的订单量非常大，系统每天处理数百万个订单，数据库的性能和响应速度是系统正常运行的关键。为确保数据库性能，在 SQL Server 中进行参数和配置优化至关重要。</p><h3 id="优化策略：-1"><a href="#优化策略：-1" class="headerlink" title="优化策略："></a>优化策略：</h3><ol><li><strong>调整内存配置</strong>：通过配置 SQL Server 使用更多的内存来缓存数据，减少磁盘 I&#x2F;O。</li><li><strong>设置最大并行度</strong>：根据 CPU 核心数，调整 SQL Server 的并行查询处理能力。</li><li><strong>优化磁盘和存储配置</strong>：确保日志文件、数据文件和临时文件分开存储。</li><li><strong>启用自动数据库优化</strong>：确保数据库能够自动进行碎片整理、更新统计信息等任务。</li><li><strong>调整事务日志和恢复模式</strong>：确保数据库在发生故障时能够快速恢复。</li></ol><h3 id="1-调整内存配置"><a href="#1-调整内存配置" class="headerlink" title="1. 调整内存配置"></a>1. 调整内存配置</h3><p>内存配置优化是提高 SQL Server 性能的关键部分。通过增加 SQL Server 的最大内存，可以保证查询操作不会因为磁盘 I&#x2F;O 的瓶颈而导致性能问题。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看当前最大内存配置</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;show advanced options&#x27;</span>, <span class="number">1</span>;</span><br><span class="line">RECONFIGURE;</span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;max server memory (MB)&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置最大内存为 16 GB</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;max server memory (MB)&#x27;</span>, <span class="number">16384</span>;  <span class="comment">-- 16 GB</span></span><br><span class="line">RECONFIGURE;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们将 SQL Server 的最大内存设置为 16 GB。适当配置内存可以提高查询性能，减少磁盘的访问。</p><h3 id="2-设置最大并行度"><a href="#2-设置最大并行度" class="headerlink" title="2. 设置最大并行度"></a>2. 设置最大并行度</h3><p>SQL Server 可以利用多个 CPU 核心进行并行查询处理。通过合理设置并行度，可以提高大查询的处理能力。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看当前的最大并行度设置</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;max degree of parallelism&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置最大并行度为 4（适用于 4 核 CPU 的机器）</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;max degree of parallelism&#x27;</span>, <span class="number">4</span>;</span><br><span class="line">RECONFIGURE;</span><br></pre></td></tr></table></figure><p>通过此设置，SQL Server 可以在查询时利用最多 4 个 CPU 核心进行并行处理。如果你的服务器有更多核心，可以根据实际情况调整这个参数。</p><h3 id="3-调整事务日志和恢复模式"><a href="#3-调整事务日志和恢复模式" class="headerlink" title="3. 调整事务日志和恢复模式"></a>3. 调整事务日志和恢复模式</h3><p>对于电商平台而言，事务日志的优化至关重要。确保在进行大规模事务操作时，日志文件能够高效地处理，并且确保恢复模式符合业务需求。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看数据库的恢复模式</span></span><br><span class="line"><span class="keyword">SELECT</span> name, recovery_model_desc</span><br><span class="line"><span class="keyword">FROM</span> sys.databases</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;VGDB&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置恢复模式为简单恢复模式</span></span><br><span class="line"><span class="keyword">ALTER</span> DATABASE VGDB</span><br><span class="line"><span class="keyword">SET</span> RECOVERY SIMPLE;</span><br></pre></td></tr></table></figure><p>对于不需要完整备份的数据库，使用简单恢复模式可以减少日志文件的增长，减轻磁盘 I&#x2F;O 压力。</p><h3 id="4-配置自动数据库优化"><a href="#4-配置自动数据库优化" class="headerlink" title="4. 配置自动数据库优化"></a>4. 配置自动数据库优化</h3><p>确保数据库能够定期执行自动优化任务，如重建索引、更新统计信息等。定期优化可以提高数据库的查询性能，避免碎片化问题。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 启用自动更新统计信息</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;auto update statistics&#x27;</span>, <span class="number">1</span>;</span><br><span class="line">RECONFIGURE;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 启用自动创建统计信息</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;auto create statistics&#x27;</span>, <span class="number">1</span>;</span><br><span class="line">RECONFIGURE;</span><br></pre></td></tr></table></figure><p>通过启用自动更新统计信息和自动创建统计信息，可以确保 SQL Server 在执行查询时能够使用最新的执行计划，减少查询优化器的负担。</p><h3 id="5-配置磁盘和存储"><a href="#5-配置磁盘和存储" class="headerlink" title="5. 配置磁盘和存储"></a>5. 配置磁盘和存储</h3><p>确保 SQL Server 的数据文件、日志文件和临时文件存储在不同的磁盘上，特别是将日志文件和数据文件存储在高速磁盘（如 SSD）上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 将数据文件 (.mdf) 存储在磁盘 A（SSD）</span><br><span class="line">-- 将日志文件 (.ldf) 存储在磁盘 B（SSD）</span><br><span class="line">-- 将临时数据库文件 (.ndf) 存储在磁盘 C（SSD）</span><br></pre></td></tr></table></figure><p>通过将数据文件、日志文件和临时文件分别存储在不同的磁盘上，可以避免磁盘 I&#x2F;O 争用，提升数据库的整体性能。</p><h3 id="6-启用数据库压缩"><a href="#6-启用数据库压缩" class="headerlink" title="6. 启用数据库压缩"></a>6. 启用数据库压缩</h3><p>对于需要存储大量数据的电商平台，启用数据压缩可以减少存储空间并提高查询性能，尤其是在磁盘 I&#x2F;O 上。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 启用表压缩</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Orders REBUILD <span class="keyword">PARTITION</span> <span class="operator">=</span> <span class="keyword">ALL</span> <span class="keyword">WITH</span> (DATA_COMPRESSION <span class="operator">=</span> PAGE);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 启用索引压缩</span></span><br><span class="line"><span class="keyword">ALTER</span> INDEX <span class="keyword">ALL</span> <span class="keyword">ON</span> Orders REBUILD <span class="keyword">PARTITION</span> <span class="operator">=</span> <span class="keyword">ALL</span> <span class="keyword">WITH</span> (DATA_COMPRESSION <span class="operator">=</span> PAGE);</span><br></pre></td></tr></table></figure><p>通过启用数据压缩，我们可以有效节省存储空间，减少磁盘 I&#x2F;O 操作，并提高查询速度。</p><h3 id="7-配置自动维护任务"><a href="#7-配置自动维护任务" class="headerlink" title="7. 配置自动维护任务"></a>7. 配置自动维护任务</h3><p>SQL Server 提供了自动维护任务，如索引重建、数据库碎片整理等，可以通过 SQL Server Agent 定时任务来自动执行这些任务，保持数据库的高效运行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建一个定期执行的作业，执行索引重建任务</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_add_job <span class="variable">@job</span>_name <span class="operator">=</span> <span class="string">&#x27;RebuildIndexes&#x27;</span>, <span class="variable">@enabled</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">EXEC</span> sp_add_jobstep <span class="variable">@job</span>_name <span class="operator">=</span> <span class="string">&#x27;RebuildIndexes&#x27;</span>, </span><br><span class="line">    <span class="variable">@step</span>_name <span class="operator">=</span> <span class="string">&#x27;RebuildIndexStep&#x27;</span>, </span><br><span class="line">    <span class="variable">@subsystem</span> <span class="operator">=</span> <span class="string">&#x27;TSQL&#x27;</span>, </span><br><span class="line">    <span class="variable">@command</span> <span class="operator">=</span> <span class="string">&#x27;ALTER INDEX ALL ON Orders REBUILD&#x27;</span>,</span><br><span class="line">    <span class="variable">@retry</span>_attempts <span class="operator">=</span> <span class="number">3</span>, </span><br><span class="line">    <span class="variable">@retry</span>_interval <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置作业运行频率：每天凌晨 2 点执行</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_add_schedule <span class="variable">@schedule</span>_name <span class="operator">=</span> <span class="string">&#x27;RebuildIndexSchedule&#x27;</span>,</span><br><span class="line">    <span class="variable">@enabled</span> <span class="operator">=</span> <span class="number">1</span>,</span><br><span class="line">    <span class="variable">@freq</span>_type <span class="operator">=</span> <span class="number">4</span>, </span><br><span class="line">    <span class="variable">@freq</span>_interval <span class="operator">=</span> <span class="number">1</span>, </span><br><span class="line">    <span class="variable">@active</span>_start_time <span class="operator">=</span> <span class="number">20000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXEC</span> sp_attach_schedule <span class="variable">@job</span>_name <span class="operator">=</span> <span class="string">&#x27;RebuildIndexes&#x27;</span>, <span class="variable">@schedule</span>_name <span class="operator">=</span> <span class="string">&#x27;RebuildIndexSchedule&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这个作业将在每天凌晨 2 点执行，重建 <code>Orders</code> 表上的所有索引，从而避免因索引碎片而降低查询性能。</p><h3 id="8-启用即时日志备份"><a href="#8-启用即时日志备份" class="headerlink" title="8. 启用即时日志备份"></a>8. 启用即时日志备份</h3><p>对于生产环境，尤其是电商平台，确保日志备份及时执行至关重要。启用日志备份可以保证在数据库发生故障时进行快速恢复。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置事务日志备份</span></span><br><span class="line">BACKUP LOG VGDB <span class="keyword">TO</span> DISK <span class="operator">=</span> <span class="string">&#x27;D:\Backups\YourDatabase_log.trn&#x27;</span>;</span><br></pre></td></tr></table></figure><p>通过定期执行事务日志备份，可以确保在发生故障时，数据库能够恢复到最新的状态。</p><h3 id="9-启用数据库缓存"><a href="#9-启用数据库缓存" class="headerlink" title="9. 启用数据库缓存"></a>9. 启用数据库缓存</h3><p>SQL Server 会缓存查询结果和数据页，通过调整缓存策略来优化性能。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看缓存的页面数量</span></span><br><span class="line">DBCC SHOW_STATISTICS(<span class="string">&#x27;Orders&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 强制清除缓存（有时可以用于测试）</span></span><br><span class="line">DBCC FREEPROCCACHE;</span><br><span class="line">DBCC DROPCLEANBUFFERS;</span><br></pre></td></tr></table></figure><p>在日常操作中，我们不建议经常清除缓存，但可以在需要时清除缓存来测试性能优化效果。</p><h3 id="小结一下-5"><a href="#小结一下-5" class="headerlink" title="小结一下"></a>小结一下</h3><p>通过优化 SQL Server 的配置和参数，可以显著提升电商平台的数据库性能。关键的优化措施包括调整内存和并行度、优化磁盘存储和日志配置、启用数据压缩、定期执行自动数据库优化任务、配置数据库压缩和定期备份等。根据业务需求和硬件资源进行合理配置，以确保数据库在高并发、高负载的环境中能够稳定高效地运行。</p><h2 id="7-批量数据处理"><a href="#7-批量数据处理" class="headerlink" title="7. 批量数据处理"></a>7. 批量数据处理</h2><ul><li><strong>批量插入&#x2F;更新操作</strong>：在处理大量数据时，可以使用批量插入或更新操作，而不是一行一行地进行。这能显著提高数据的加载速度。</li><li><strong>避免大事务</strong>：对于大量的数据修改，避免使用大事务，因为大事务可能会导致锁竞争、日志文件过大等问题。使用小批次事务进行操作。</li></ul><p>批量数据处理在大规模应用中是不可避免的，尤其是像电商平台、金融系统等业务场景，通常需要进行大批量的订单、用户信息处理等。批量操作能够显著提高数据处理效率，但也需要谨慎设计，以确保性能和稳定性。</p><h3 id="业务场景：-2"><a href="#业务场景：-2" class="headerlink" title="业务场景："></a>业务场景：</h3><p>假设在电商平台中，订单信息需要进行批量处理，比如批量更新订单状态、批量删除失效订单、批量插入订单数据等。通过设计合适的批量操作，能够有效减少单次操作的数据库访问次数，提升系统的响应能力。</p><h3 id="优化方案："><a href="#优化方案：" class="headerlink" title="优化方案："></a>优化方案：</h3><ol><li><strong>批量插入数据</strong>：通过 <code>BULK INSERT</code> 或者 <code>INSERT INTO</code> 多行插入方式，减少多次单独插入操作带来的性能瓶颈。</li><li><strong>批量更新数据</strong>：使用 <code>UPDATE</code> 操作一次性更新多条记录。</li><li><strong>批量删除数据</strong>：批量删除过期的订单，或者批量删除无效的用户信息。</li></ol><p>以下是具体的 SQL Server 批量数据处理的代码案例。</p><h3 id="1-批量插入数据"><a href="#1-批量插入数据" class="headerlink" title="1. 批量插入数据"></a>1. 批量插入数据</h3><p>批量插入可以减少大量单独插入操作的时间开销，通过 <code>INSERT INTO</code> 语句一次插入多条数据。</p><h4 id="示例：批量插入订单数据"><a href="#示例：批量插入订单数据" class="headerlink" title="示例：批量插入订单数据"></a>示例：批量插入订单数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 假设 Orders 表结构如下：OrderID INT, CustomerID INT, OrderDate DATETIME, OrderStatus VARCHAR(20)</span></span><br><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@OrderData</span> <span class="keyword">TABLE</span> (OrderID <span class="type">INT</span>, CustomerID <span class="type">INT</span>, OrderDate DATETIME, OrderStatus <span class="type">VARCHAR</span>(<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将订单数据插入临时表</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="variable">@OrderData</span> (OrderID, CustomerID, OrderDate, OrderStatus)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    (<span class="number">1</span>, <span class="number">101</span>, <span class="string">&#x27;2024-11-01&#x27;</span>, <span class="string">&#x27;Pending&#x27;</span>),</span><br><span class="line">    (<span class="number">2</span>, <span class="number">102</span>, <span class="string">&#x27;2024-11-02&#x27;</span>, <span class="string">&#x27;Shipped&#x27;</span>),</span><br><span class="line">    (<span class="number">3</span>, <span class="number">103</span>, <span class="string">&#x27;2024-11-03&#x27;</span>, <span class="string">&#x27;Delivered&#x27;</span>),</span><br><span class="line">    (<span class="number">4</span>, <span class="number">104</span>, <span class="string">&#x27;2024-11-04&#x27;</span>, <span class="string">&#x27;Cancelled&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 批量插入数据到 Orders 表</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Orders (OrderID, CustomerID, OrderDate, OrderStatus)</span><br><span class="line"><span class="keyword">SELECT</span> OrderID, CustomerID, OrderDate, OrderStatus</span><br><span class="line"><span class="keyword">FROM</span> <span class="variable">@OrderData</span>;</span><br></pre></td></tr></table></figure><p>在此例中，我们先将数据插入临时表 <code>@OrderData</code>，然后通过 <code>INSERT INTO SELECT</code> 语句批量插入 <code>Orders</code> 表。这种方式可以大大减少数据库访问的次数。</p><h3 id="2-批量更新数据"><a href="#2-批量更新数据" class="headerlink" title="2. 批量更新数据"></a>2. 批量更新数据</h3><p>批量更新操作通常用于修改多个记录中的某些字段，避免多次单独更新。</p><h4 id="示例：批量更新订单状态"><a href="#示例：批量更新订单状态" class="headerlink" title="示例：批量更新订单状态"></a>示例：批量更新订单状态</h4><p>假设需要批量更新所有未发货的订单状态为 “Shipped”，可以通过如下 SQL 来实现：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 批量更新订单状态</span></span><br><span class="line"><span class="keyword">UPDATE</span> Orders</span><br><span class="line"><span class="keyword">SET</span> OrderStatus <span class="operator">=</span> <span class="string">&#x27;Shipped&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> OrderStatus <span class="operator">=</span> <span class="string">&#x27;Pending&#x27;</span> <span class="keyword">AND</span> OrderDate <span class="operator">&lt;</span> <span class="string">&#x27;2024-11-01&#x27;</span>;</span><br></pre></td></tr></table></figure><p>该操作会一次性更新所有符合条件的记录，避免多次单独更新操作带来的性能问题。</p><h3 id="3-批量删除数据"><a href="#3-批量删除数据" class="headerlink" title="3. 批量删除数据"></a>3. 批量删除数据</h3><p>在某些场景下，我们需要批量删除某些过期或无效的数据。例如，删除 30 天之前的过期订单。</p><h4 id="示例：批量删除过期订单"><a href="#示例：批量删除过期订单" class="headerlink" title="示例：批量删除过期订单"></a>示例：批量删除过期订单</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除过期的订单</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> OrderDate <span class="operator">&lt;</span> DATEADD(<span class="keyword">DAY</span>, <span class="number">-30</span>, GETDATE()) <span class="keyword">AND</span> OrderStatus <span class="operator">=</span> <span class="string">&#x27;Completed&#x27;</span>;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们删除所有已完成且订单日期超过 30 天的订单。这种批量删除操作比逐个删除要高效得多。</p><h3 id="4-批量处理逻辑优化"><a href="#4-批量处理逻辑优化" class="headerlink" title="4. 批量处理逻辑优化"></a>4. 批量处理逻辑优化</h3><p>有时批量操作的数据量非常大，直接处理可能导致性能问题或数据库锁争用。可以考虑分批次执行操作来减轻系统负担。</p><h4 id="示例：按批次处理订单数据"><a href="#示例：按批次处理订单数据" class="headerlink" title="示例：按批次处理订单数据"></a>示例：按批次处理订单数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@BatchSize</span> <span class="type">INT</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@StartRow</span> <span class="type">INT</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@TotalRows</span> <span class="type">INT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 计算总记录数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@TotalRows</span> <span class="operator">=</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> Orders <span class="keyword">WHERE</span> OrderStatus <span class="operator">=</span> <span class="string">&#x27;Pending&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 循环批量处理数据</span></span><br><span class="line">WHILE <span class="variable">@StartRow</span> <span class="operator">&lt;</span> <span class="variable">@TotalRows</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- 批量更新 1000 条数据</span></span><br><span class="line">    <span class="keyword">UPDATE</span> TOP (<span class="variable">@BatchSize</span>) Orders</span><br><span class="line">    <span class="keyword">SET</span> OrderStatus <span class="operator">=</span> <span class="string">&#x27;Shipped&#x27;</span></span><br><span class="line">    <span class="keyword">WHERE</span> OrderStatus <span class="operator">=</span> <span class="string">&#x27;Pending&#x27;</span> <span class="keyword">AND</span> OrderDate <span class="operator">&lt;</span> <span class="string">&#x27;2024-11-01&#x27;</span> <span class="keyword">AND</span> OrderID <span class="operator">&gt;</span> <span class="variable">@StartRow</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 更新已处理的行数</span></span><br><span class="line">    <span class="keyword">SET</span> <span class="variable">@StartRow</span> <span class="operator">=</span> <span class="variable">@StartRow</span> <span class="operator">+</span> <span class="variable">@BatchSize</span>;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><p>通过分批次处理（每次处理 1000 条记录），可以避免一次性处理大量数据时造成的性能瓶颈或数据库锁的问题。适用于需要批量更新大量记录的情况。</p><h3 id="5-使用事务保证数据一致性"><a href="#5-使用事务保证数据一致性" class="headerlink" title="5. 使用事务保证数据一致性"></a>5. 使用事务保证数据一致性</h3><p>对于批量操作来说，通常需要使用事务来保证数据一致性，即要么全部成功，要么全部失败。</p><h4 id="示例：批量插入订单并使用事务"><a href="#示例：批量插入订单并使用事务" class="headerlink" title="示例：批量插入订单并使用事务"></a>示例：批量插入订单并使用事务</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> TRY</span><br><span class="line">    <span class="comment">-- 假设 Orders 表结构：OrderID INT, CustomerID INT, OrderDate DATETIME, OrderStatus VARCHAR(20)</span></span><br><span class="line">    <span class="keyword">DECLARE</span> <span class="variable">@OrderData</span> <span class="keyword">TABLE</span> (OrderID <span class="type">INT</span>, CustomerID <span class="type">INT</span>, OrderDate DATETIME, OrderStatus <span class="type">VARCHAR</span>(<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 批量插入订单数据</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="variable">@OrderData</span> (OrderID, CustomerID, OrderDate, OrderStatus)</span><br><span class="line">    <span class="keyword">VALUES</span></span><br><span class="line">        (<span class="number">5</span>, <span class="number">105</span>, <span class="string">&#x27;2024-11-05&#x27;</span>, <span class="string">&#x27;Pending&#x27;</span>),</span><br><span class="line">        (<span class="number">6</span>, <span class="number">106</span>, <span class="string">&#x27;2024-11-06&#x27;</span>, <span class="string">&#x27;Pending&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> Orders (OrderID, CustomerID, OrderDate, OrderStatus)</span><br><span class="line">    <span class="keyword">SELECT</span> OrderID, CustomerID, OrderDate, OrderStatus</span><br><span class="line">    <span class="keyword">FROM</span> <span class="variable">@OrderData</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 提交事务</span></span><br><span class="line">    <span class="keyword">COMMIT</span> TRANSACTION;</span><br><span class="line"><span class="keyword">END</span> TRY</span><br><span class="line"><span class="keyword">BEGIN</span> CATCH</span><br><span class="line">    <span class="comment">-- 错误处理并回滚事务</span></span><br><span class="line">    <span class="keyword">ROLLBACK</span> TRANSACTION;</span><br><span class="line">    PRINT <span class="string">&#x27;Error occurred: &#x27;</span> <span class="operator">+</span> ERROR_MESSAGE();</span><br><span class="line"><span class="keyword">END</span> CATCH;</span><br></pre></td></tr></table></figure><p>在这个例子中，批量插入操作被包含在一个事务中，确保插入操作的原子性，即要么全部成功，要么全部失败。如果在执行过程中发生错误，会回滚事务，避免数据不一致的情况。</p><h3 id="小结一下-6"><a href="#小结一下-6" class="headerlink" title="小结一下"></a>小结一下</h3><p>批量数据处理是提高 SQL Server 性能的有效手段，尤其是在数据量庞大的电商平台等业务场景中。通过合理使用批量插入、批量更新和批量删除操作，可以大幅度提高数据库的处理效率，减少数据库的 I&#x2F;O 操作次数和锁竞争。在执行批量操作时，记得通过事务保证数据的一致性，分批处理可以进一步优化大规模数据的处理性能。</p><h2 id="8-清理无用数据"><a href="#8-清理无用数据" class="headerlink" title="8. 清理无用数据"></a>8. 清理无用数据</h2><ul><li><strong>删除过期数据</strong>：定期清理过期或不再需要的数据，减少数据库的大小和查询的复杂性。</li><li><strong>清理数据库碎片</strong>：随着数据的增删，表和索引的碎片会增加，影响性能。定期重建索引或重新组织索引，减少碎片。</li></ul><p>清理无用数据是数据库维护中的常见任务，特别是在处理历史数据、过期记录或冗余数据时。定期清理无用数据不仅能够节省存储空间，还能提高数据库性能，避免无用数据对查询、索引等造成不必要的影响。</p><h3 id="业务场景：-3"><a href="#业务场景：-3" class="headerlink" title="业务场景："></a>业务场景：</h3><p>假设我们在一个电商平台中，用户的订单数据每年都会生成大量记录。为了避免订单表过于庞大，且不再使用的订单记录（比如 3 年之前的订单）会占用大量存储空间，我们需要定期清理这些过期订单数据。</p><h3 id="优化方案：-1"><a href="#优化方案：-1" class="headerlink" title="优化方案："></a>优化方案：</h3><ol><li><strong>删除过期数据</strong>：定期删除超过一定时间的订单数据（比如 3 年前的订单）。</li><li><strong>归档过期数据</strong>：将过期的订单数据移到一个历史表或外部存储中，保留必要的历史信息。</li></ol><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="1-定期删除过期数据"><a href="#1-定期删除过期数据" class="headerlink" title="1. 定期删除过期数据"></a>1. 定期删除过期数据</h4><p>假设我们的 <code>Orders</code> 表有字段 <code>OrderDate</code> 来记录订单的创建时间，<code>OrderStatus</code> 来标识订单状态。我们可以每月清理 3 年前的已完成或已取消的订单。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除 3 年前已完成或已取消的订单</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> OrderDate <span class="operator">&lt;</span> DATEADD(<span class="keyword">YEAR</span>, <span class="number">-3</span>, GETDATE()) </span><br><span class="line">    <span class="keyword">AND</span> OrderStatus <span class="keyword">IN</span> (<span class="string">&#x27;Completed&#x27;</span>, <span class="string">&#x27;Cancelled&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>DATEADD(YEAR, -3, GETDATE())</code> 会计算出当前日期 3 年前的日期，所有在此日期之前且状态为 <code>&#39;Completed&#39;</code> 或 <code>&#39;Cancelled&#39;</code> 的订单将被删除。</p><h4 id="2-定期归档过期数据"><a href="#2-定期归档过期数据" class="headerlink" title="2. 定期归档过期数据"></a>2. 定期归档过期数据</h4><p>如果删除数据不符合业务需求，可以选择将数据归档。比如，将 3 年前的订单转移到 <code>ArchivedOrders</code> 表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 将 3 年前的已完成或已取消的订单移动到 ArchivedOrders 表</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> ArchivedOrders (OrderID, CustomerID, OrderDate, OrderStatus)</span><br><span class="line"><span class="keyword">SELECT</span> OrderID, CustomerID, OrderDate, OrderStatus</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> OrderDate <span class="operator">&lt;</span> DATEADD(<span class="keyword">YEAR</span>, <span class="number">-3</span>, GETDATE()) </span><br><span class="line">    <span class="keyword">AND</span> OrderStatus <span class="keyword">IN</span> (<span class="string">&#x27;Completed&#x27;</span>, <span class="string">&#x27;Cancelled&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除已归档的订单</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> OrderDate <span class="operator">&lt;</span> DATEADD(<span class="keyword">YEAR</span>, <span class="number">-3</span>, GETDATE()) </span><br><span class="line">    <span class="keyword">AND</span> OrderStatus <span class="keyword">IN</span> (<span class="string">&#x27;Completed&#x27;</span>, <span class="string">&#x27;Cancelled&#x27;</span>);</span><br></pre></td></tr></table></figure><p>首先将符合条件的订单数据插入到 <code>ArchivedOrders</code> 表，然后再删除原 <code>Orders</code> 表中的这些数据。这样可以保持主表的清洁，减少存储压力，并保留历史数据。</p><h4 id="3-使用触发器自动清理无用数据"><a href="#3-使用触发器自动清理无用数据" class="headerlink" title="3. 使用触发器自动清理无用数据"></a>3. 使用触发器自动清理无用数据</h4><p>为了自动化清理操作，可以使用数据库触发器（Trigger），例如，在每次插入数据时检查数据是否超期，如果超期则触发清理操作。触发器可以周期性地执行清理任务。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建触发器，每天检查并删除 3 年前的订单</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> CleanOldOrders</span><br><span class="line"><span class="keyword">ON</span> Orders</span><br><span class="line">AFTER <span class="keyword">INSERT</span>, <span class="keyword">UPDATE</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- 清理过期订单：删除 3 年前的已完成或已取消订单</span></span><br><span class="line">    <span class="keyword">DELETE</span> <span class="keyword">FROM</span> Orders</span><br><span class="line">    <span class="keyword">WHERE</span> OrderDate <span class="operator">&lt;</span> DATEADD(<span class="keyword">YEAR</span>, <span class="number">-3</span>, GETDATE()) </span><br><span class="line">        <span class="keyword">AND</span> OrderStatus <span class="keyword">IN</span> (<span class="string">&#x27;Completed&#x27;</span>, <span class="string">&#x27;Cancelled&#x27;</span>);</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>此触发器将在 <code>Orders</code> 表每次执行插入或更新操作时触发，自动检查并清理过期的订单。</p><h4 id="4-分批次清理无用数据"><a href="#4-分批次清理无用数据" class="headerlink" title="4. 分批次清理无用数据"></a>4. 分批次清理无用数据</h4><p>如果订单数据量非常大，直接删除可能会导致性能瓶颈或数据库锁定问题。在这种情况下，可以分批次删除数据，以减少单次删除操作的负载。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@BatchSize</span> <span class="type">INT</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@StartRow</span> <span class="type">INT</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@TotalRows</span> <span class="type">INT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 计算需要删除的记录数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@TotalRows</span> <span class="operator">=</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> OrderDate <span class="operator">&lt;</span> DATEADD(<span class="keyword">YEAR</span>, <span class="number">-3</span>, GETDATE()) </span><br><span class="line">    <span class="keyword">AND</span> OrderStatus <span class="keyword">IN</span> (<span class="string">&#x27;Completed&#x27;</span>, <span class="string">&#x27;Cancelled&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分批次删除</span></span><br><span class="line">WHILE <span class="variable">@StartRow</span> <span class="operator">&lt;</span> <span class="variable">@TotalRows</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- 批量删除 1000 条数据</span></span><br><span class="line">    <span class="keyword">DELETE</span> TOP (<span class="variable">@BatchSize</span>) <span class="keyword">FROM</span> Orders</span><br><span class="line">    <span class="keyword">WHERE</span> OrderDate <span class="operator">&lt;</span> DATEADD(<span class="keyword">YEAR</span>, <span class="number">-3</span>, GETDATE()) </span><br><span class="line">        <span class="keyword">AND</span> OrderStatus <span class="keyword">IN</span> (<span class="string">&#x27;Completed&#x27;</span>, <span class="string">&#x27;Cancelled&#x27;</span>)</span><br><span class="line">        <span class="keyword">AND</span> OrderID <span class="operator">&gt;</span> <span class="variable">@StartRow</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 更新已删除的行数</span></span><br><span class="line">    <span class="keyword">SET</span> <span class="variable">@StartRow</span> <span class="operator">=</span> <span class="variable">@StartRow</span> <span class="operator">+</span> <span class="variable">@BatchSize</span>;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><p>通过分批次处理删除操作，每次删除少量记录，减少对数据库性能的影响，并避免长时间锁定表。</p><h4 id="5-使用作业调度器定期清理无用数据"><a href="#5-使用作业调度器定期清理无用数据" class="headerlink" title="5. 使用作业调度器定期清理无用数据"></a>5. 使用作业调度器定期清理无用数据</h4><p>如果您使用的是 SQL Server，可以使用作业调度器（SQL Server Agent）定期执行清理任务。首先，您可以创建一个存储过程来执行数据清理操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> CleanOldOrders</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DELETE</span> <span class="keyword">FROM</span> Orders</span><br><span class="line">    <span class="keyword">WHERE</span> OrderDate <span class="operator">&lt;</span> DATEADD(<span class="keyword">YEAR</span>, <span class="number">-3</span>, GETDATE()) </span><br><span class="line">        <span class="keyword">AND</span> OrderStatus <span class="keyword">IN</span> (<span class="string">&#x27;Completed&#x27;</span>, <span class="string">&#x27;Cancelled&#x27;</span>);</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>然后，在 SQL Server Management Studio 中设置定期作业（例如每天午夜运行该存储过程），这样可以确保无用数据定期清理。</p><h3 id="小结一下-7"><a href="#小结一下-7" class="headerlink" title="小结一下"></a>小结一下</h3><p>清理无用数据不仅有助于节省存储空间，还能提高数据库性能。根据实际业务需求，我们可以选择删除、归档或分批处理的方式来清理数据。特别是对于大数据量的表，分批清理和定期作业调度可以有效减少系统的负担。</p><h2 id="9-使用缓存"><a href="#9-使用缓存" class="headerlink" title="9. 使用缓存"></a>9. 使用缓存</h2><ul><li><strong>缓存常用查询结果</strong>：对于高频次查询，可以将查询结果缓存到内存中，避免每次查询都去数据库中查找。</li><li><strong>应用层缓存</strong>：使用 Redis 或 Memcached 等缓存系统，将一些常用数据缓存在内存中，从而减少数据库访问频率。</li></ul><p>在实际业务中，缓存是提高系统性能的常用手段，特别是对于高频访问的热点数据，通过将其存储在缓存中，可以减少数据库查询的次数和压力，提高响应速度。</p><h3 id="业务场景-4"><a href="#业务场景-4" class="headerlink" title="业务场景"></a>业务场景</h3><p>假设我们有一个电商平台，用户在浏览商品详情时，频繁地查询商品的基本信息（如价格、库存、描述等）。由于商品信息变化较少，而查询请求频繁，因此将商品信息缓存起来能够有效提高系统的性能。</p><p>我们使用 Redis 作为缓存数据库，常见的做法是：当查询某个商品时，首先检查缓存中是否存在该商品的详情，如果存在，则直接返回缓存中的数据；如果缓存中没有，则从数据库中查询，并将查询结果存入缓存中，以备下次使用。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li>使用 Redis 存储商品信息。</li><li>设置适当的过期时间（TTL，Time To Live），避免缓存数据过期。</li><li>使用适当的缓存更新策略（例如：每次更新商品信息时更新缓存）。</li></ol><h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="1-设置-Redis-缓存"><a href="#1-设置-Redis-缓存" class="headerlink" title="1. 设置 Redis 缓存"></a>1. 设置 Redis 缓存</h4><p>首先，使用 Redis 的客户端库（如 <code>redis-py</code>）连接 Redis 服务。假设商品信息表为 <code>Products</code>，有字段 <code>ProductID</code>, <code>ProductName</code>, <code>Price</code>, <code>Stock</code>, <code>Description</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 Redis 客户端</span></span><br><span class="line">pip install redis</span><br></pre></td></tr></table></figure><h4 id="2-商品查询和缓存逻辑"><a href="#2-商品查询和缓存逻辑" class="headerlink" title="2. 商品查询和缓存逻辑"></a>2. 商品查询和缓存逻辑</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接 Redis</span></span><br><span class="line">redis_client = redis.StrictRedis(host=<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">6379</span>, db=<span class="number">0</span>, decode_responses=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接 MySQL 数据库</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_db_connection</span>():</span><br><span class="line">    <span class="keyword">return</span> mysql.connector.connect(</span><br><span class="line">        host=<span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">        user=<span class="string">&quot;root&quot;</span>,</span><br><span class="line">        password=<span class="string">&quot;password&quot;</span>,</span><br><span class="line">        database=<span class="string">&quot;ecommerce&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取商品详情</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_product_details</span>(<span class="params">product_id</span>):</span><br><span class="line">    <span class="comment"># 检查缓存</span></span><br><span class="line">    cached_product = redis_client.get(<span class="string">f&quot;product:<span class="subst">&#123;product_id&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> cached_product:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;从缓存中获取商品信息&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> json.loads(cached_product)  <span class="comment"># 反序列化 JSON 数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果缓存中没有，查询数据库</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;从数据库中获取商品信息&quot;</span>)</span><br><span class="line">    connection = get_db_connection()</span><br><span class="line">    cursor = connection.cursor(dictionary=<span class="literal">True</span>)</span><br><span class="line">    cursor.execute(<span class="string">&quot;SELECT * FROM Products WHERE ProductID = %s&quot;</span>, (product_id,))</span><br><span class="line">    product = cursor.fetchone()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果商品存在，缓存到 Redis 中</span></span><br><span class="line">    <span class="keyword">if</span> product:</span><br><span class="line">        redis_client.setex(<span class="string">f&quot;product:<span class="subst">&#123;product_id&#125;</span>&quot;</span>, <span class="number">3600</span>, json.dumps(product))  <span class="comment"># 缓存 1 小时</span></span><br><span class="line">    cursor.close()</span><br><span class="line">    connection.close()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> product</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新商品信息并更新缓存</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update_product_details</span>(<span class="params">product_id, name, price, stock, description</span>):</span><br><span class="line">    <span class="comment"># 更新数据库</span></span><br><span class="line">    connection = get_db_connection()</span><br><span class="line">    cursor = connection.cursor()</span><br><span class="line">    cursor.execute(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        UPDATE Products</span></span><br><span class="line"><span class="string">        SET ProductName = %s, Price = %s, Stock = %s, Description = %s</span></span><br><span class="line"><span class="string">        WHERE ProductID = %s</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>, (name, price, stock, description, product_id))</span><br><span class="line">    connection.commit()</span><br><span class="line">    cursor.close()</span><br><span class="line">    connection.close()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 更新缓存</span></span><br><span class="line">    updated_product = &#123;</span><br><span class="line">        <span class="string">&quot;ProductID&quot;</span>: product_id,</span><br><span class="line">        <span class="string">&quot;ProductName&quot;</span>: name,</span><br><span class="line">        <span class="string">&quot;Price&quot;</span>: price,</span><br><span class="line">        <span class="string">&quot;Stock&quot;</span>: stock,</span><br><span class="line">        <span class="string">&quot;Description&quot;</span>: description</span><br><span class="line">    &#125;</span><br><span class="line">    redis_client.setex(<span class="string">f&quot;product:<span class="subst">&#123;product_id&#125;</span>&quot;</span>, <span class="number">3600</span>, json.dumps(updated_product))  <span class="comment"># 缓存 1 小时</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：查询商品 101 的信息</span></span><br><span class="line">product_info = get_product_details(<span class="number">101</span>)</span><br><span class="line"><span class="built_in">print</span>(product_info)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：更新商品 101 的信息</span></span><br><span class="line">update_product_details(<span class="number">101</span>, <span class="string">&quot;New Product Name&quot;</span>, <span class="number">199.99</span>, <span class="number">50</span>, <span class="string">&quot;Updated description&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h3><ol><li><strong>连接 Redis 和 MySQL：</strong> 使用 <code>redis-py</code> 连接 Redis，使用 <code>mysql.connector</code> 连接 MySQL 数据库。</li><li><strong>查询商品：</strong> 在 <code>get_product_details</code> 方法中，我们首先查询 Redis 缓存，看是否已经缓存了商品信息。如果缓存中存在，则直接返回缓存中的数据；如果缓存中没有，则从 MySQL 数据库中查询，并将查询结果缓存到 Redis 中。</li><li><strong>更新商品信息：</strong> 当商品信息发生变化时（例如商品名称、价格、库存等更新），我们在数据库中更新商品信息后，同时更新 Redis 缓存，以确保缓存数据的最新性。</li><li><strong>缓存设置过期时间：</strong> 使用 <code>setex</code> 方法将商品信息缓存到 Redis 中，并为缓存数据设置过期时间（TTL）。这样可以避免缓存过期数据的存在。</li></ol><h3 id="进一步优化"><a href="#进一步优化" class="headerlink" title="进一步优化"></a>进一步优化</h3><ol><li><strong>缓存穿透：</strong> 在查询时，除了检查缓存是否存在外，还可以添加一些防止缓存穿透的机制，如查询数据库时检查是否存在该商品。如果商品不存在，可以将其设置为 <code>None</code> 或空值，避免多次查询数据库。</li><li><strong>缓存淘汰策略：</strong> Redis 有多种缓存淘汰策略（如 LRU、LFU），可以根据实际业务需求配置 Redis 实例的缓存策略，确保热点数据可以长时间保持在缓存中。</li><li><strong>异步更新缓存：</strong> 在高并发的场景下，更新缓存的操作可能导致性能问题，可以使用队列和异步处理来优化缓存更新的时机，避免频繁更新缓存。</li></ol><h3 id="小结一下-8"><a href="#小结一下-8" class="headerlink" title="小结一下"></a>小结一下</h3><p>通过使用 Redis 缓存，电商平台能够有效提高查询商品信息的性能，减轻数据库负担。根据业务需求，我们可以进一步优化缓存策略和更新机制。</p><h2 id="10-并行查询与并发"><a href="#10-并行查询与并发" class="headerlink" title="10. 并行查询与并发"></a>10. 并行查询与并发</h2><ul><li><strong>启用并行查询</strong>：SQL Server 允许在查询中使用多个 CPU 核心来并行处理。适当调整并行查询的设置（如 <code>max degree of parallelism</code>）可以提高查询性能，尤其是在处理大量数据时。</li><li><strong>优化锁策略</strong>：确保数据库的锁策略合理，避免长时间的锁竞争。可以使用行级锁而不是表级锁，减少阻塞。</li></ul><p>在高并发场景下，使用并行查询可以显著提升数据查询的速度。并行查询的核心思想是将复杂的查询拆分成多个子任务，利用多个 CPU 核心同时处理这些子任务，从而提高整体查询性能。并发则是指在多个任务之间进行切换，使得 CPU 更高效地利用，在某些场景下，通过并发执行多个查询任务可以实现较高的性能。</p><h3 id="业务场景-5"><a href="#业务场景-5" class="headerlink" title="业务场景"></a>业务场景</h3><p>假设我们有一个电商平台，其中存储了大量的订单数据。用户查询订单数据时，可能涉及到多个表的联接、多个条件的筛选等复杂的查询操作。为了提高查询性能，我们可以通过并行查询和并发的方式，针对不同的查询任务进行优化。</p><p>例如，查询订单数据时，查询条件包括订单状态、订单日期范围和用户 ID 等。我们将该查询拆分为多个并行查询，分别查询不同的条件，再将结果合并返回。</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li><strong>并行查询：</strong> 将查询任务拆分成多个子任务，利用多线程或者多进程并行执行每个子任务。</li><li><strong>并发查询：</strong> 使用异步 IO 或者线程池来并发执行多个查询操作。</li></ol><p>我们将使用 Python 的 <code>concurrent.futures</code> 库来实现并行查询，并利用 MySQL 数据库来执行查询操作。</p><h3 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="1-并行查询"><a href="#1-并行查询" class="headerlink" title="1. 并行查询"></a>1. 并行查询</h4><p>我们将查询条件分为多个部分，并行地执行查询操作。例如：分别查询订单状态为 <code>Completed</code> 和 <code>Pending</code> 的订单数据，并行查询。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 MySQL 客户端库</span></span><br><span class="line">pip install mysql-connector-python</span><br><span class="line">import mysql.connector</span><br><span class="line">from concurrent.futures import ThreadPoolExecutor</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接 MySQL 数据库</span></span><br><span class="line">def get_db_connection():</span><br><span class="line">    <span class="built_in">return</span> mysql.connector.connect(</span><br><span class="line">        host=<span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">        user=<span class="string">&quot;root&quot;</span>,</span><br><span class="line">        password=<span class="string">&quot;123123&quot;</span>,</span><br><span class="line">        database=<span class="string">&quot;VGDB&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行查询：查询订单状态为指定状态的订单</span></span><br><span class="line">def query_orders_by_status(status):</span><br><span class="line">    connection = get_db_connection()</span><br><span class="line">    cursor = connection.cursor(dictionary=True)</span><br><span class="line">    query = <span class="string">&quot;SELECT * FROM Orders WHERE OrderStatus = %s&quot;</span></span><br><span class="line">    cursor.execute(query, (status,))</span><br><span class="line">    result = cursor.fetchall()</span><br><span class="line">    cursor.close()</span><br><span class="line">    connection.close()</span><br><span class="line">    <span class="built_in">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行并行查询</span></span><br><span class="line">def fetch_orders():</span><br><span class="line">    statuses = [<span class="string">&#x27;Completed&#x27;</span>, <span class="string">&#x27;Pending&#x27;</span>]  <span class="comment"># 定义我们需要查询的订单状态</span></span><br><span class="line">    <span class="comment"># 使用 ThreadPoolExecutor 并行查询</span></span><br><span class="line">    with ThreadPoolExecutor(max_workers=2) as executor:</span><br><span class="line">        <span class="comment"># 提交查询任务</span></span><br><span class="line">        futures = [executor.submit(query_orders_by_status, status) <span class="keyword">for</span> status <span class="keyword">in</span> statuses]</span><br><span class="line">        <span class="comment"># 获取查询结果</span></span><br><span class="line">        results = [future.result() <span class="keyword">for</span> future <span class="keyword">in</span> futures]</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">return</span> results</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：执行查询</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    orders = fetch_orders()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;查询结果：&quot;</span>, orders)</span><br><span class="line">    <span class="built_in">print</span>(f<span class="string">&quot;查询用时: &#123;time.time() - start_time&#125;秒&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="代码说明-1"><a href="#代码说明-1" class="headerlink" title="代码说明"></a>代码说明</h3><ol><li>**<code>query_orders_by_status</code>**：该方法执行数据库查询，查询指定状态的订单。</li><li>**<code>fetch_orders</code>**：该方法使用 <code>ThreadPoolExecutor</code> 来并行执行多个查询任务。在这里，我们将订单状态 <code>Completed</code> 和 <code>Pending</code> 分别作为任务提交到线程池中并行查询。</li><li>**<code>ThreadPoolExecutor</code>**：我们创建了一个最大工作线程数为 2 的线程池，并使用 <code>submit</code> 提交查询任务。每个查询会在一个独立的线程中执行。</li><li>**<code>future.result()</code>**：获取并行查询任务的返回结果。</li></ol><h4 id="2-并发查询"><a href="#2-并发查询" class="headerlink" title="2. 并发查询"></a>2. 并发查询</h4><p>我们可以通过异步查询或多线程来执行并发查询，适用于数据库查询不会互相依赖的情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="comment"># 异步查询数据库</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">query_orders_by_status_async</span>(<span class="params">status, loop</span>):</span><br><span class="line">    <span class="comment"># 使用 ThreadPoolExecutor 让数据库查询异步执行</span></span><br><span class="line">    result = <span class="keyword">await</span> loop.run_in_executor(<span class="literal">None</span>, query_orders_by_status, status)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行查询：查询订单状态为指定状态的订单</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">query_orders_by_status</span>(<span class="params">status</span>):</span><br><span class="line">    connection = get_db_connection()</span><br><span class="line">    cursor = connection.cursor(dictionary=<span class="literal">True</span>)</span><br><span class="line">    query = <span class="string">&quot;SELECT * FROM Orders WHERE OrderStatus = %s&quot;</span></span><br><span class="line">    cursor.execute(query, (status,))</span><br><span class="line">    result = cursor.fetchall()</span><br><span class="line">    cursor.close()</span><br><span class="line">    connection.close()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 异步并发查询</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fetch_orders_concurrently</span>():</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    statuses = [<span class="string">&#x27;Completed&#x27;</span>, <span class="string">&#x27;Pending&#x27;</span>, <span class="string">&#x27;Shipped&#x27;</span>]  <span class="comment"># 查询多个状态的订单</span></span><br><span class="line">    tasks = [query_orders_by_status_async(status, loop) <span class="keyword">for</span> status <span class="keyword">in</span> statuses]</span><br><span class="line">    orders = <span class="keyword">await</span> asyncio.gather(*tasks)  <span class="comment"># 等待所有任务完成</span></span><br><span class="line">    <span class="keyword">return</span> orders</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：执行并发查询</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    asyncio.run(fetch_orders_concurrently())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;查询用时: <span class="subst">&#123;time.time() - start_time&#125;</span>秒&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="代码说明-2"><a href="#代码说明-2" class="headerlink" title="代码说明"></a>代码说明</h3><ol><li>**<code>query_orders_by_status_async</code>**：此方法使用 <code>loop.run_in_executor</code> 来将数据库查询操作异步化。通过这种方式，尽管数据库查询是阻塞操作，我们可以并发地执行多个查询。</li><li>**<code>asyncio.gather</code>**：将多个异步任务组合在一起，等待所有任务完成后再返回结果。</li><li>**<code>asyncio.run</code>**：用于启动事件循环并执行异步查询。</li></ol><h3 id="进一步优化-1"><a href="#进一步优化-1" class="headerlink" title="进一步优化"></a>进一步优化</h3><ol><li><strong>线程池大小</strong>：根据业务需求，调整 <code>ThreadPoolExecutor</code> 中的 <code>max_workers</code> 参数。如果任务非常多，可以适当增加线程池大小，但要注意不要过多，以免影响系统性能。</li><li><strong>连接池</strong>：对于数据库操作，可以使用数据库连接池来优化数据库连接的管理。这样可以避免每次查询都建立新的数据库连接，提高性能。</li><li><strong>分页查询</strong>：如果查询结果非常庞大，可以通过分页查询来减小每次查询的数据量，进一步提高性能。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>并行查询</strong>：通过将查询任务拆分为多个子任务，并行地处理，可以显著提高查询性能。</li><li><strong>并发查询</strong>：适用于在多个查询任务之间进行并发执行，无需等待每个查询任务逐个完成，可以加快整体查询速度。</li></ul><p>通过结合并行查询和并发查询策略，我们可以显著提高电商平台或其他业务系统的查询响应速度，尤其是在高并发的环境中，保证系统的高效性。</p><h2 id="11-SQL-Server-实例优化"><a href="#11-SQL-Server-实例优化" class="headerlink" title="11. SQL Server 实例优化"></a>11. SQL Server 实例优化</h2><ul><li><strong>定期重启 SQL Server 实例</strong>：如果 SQL Server 长时间运行，可能会导致缓存过多或内存泄漏等问题，定期重启可以帮助释放资源并优化性能。</li><li><strong>启用压缩</strong>：SQL Server 提供数据压缩功能，可以节省存储空间，并提高查询性能，尤其是在读取数据时。</li></ul><p>SQL Server 实例优化是提升数据库整体性能的一个重要方面。在大型业务系统中，SQL Server 的性能往往直接影响到整个应用的响应速度和稳定性。实例优化包括硬件资源的合理配置、SQL Server 配置参数的优化、内存和 I&#x2F;O 管理、查询优化以及监控等方面。</p><p>假设我们有一个在线电商平台，业务量很大，包含大量的商品、订单、用户等数据。我们需要对 SQL Server 实例进行优化，以确保高效的查询性能、稳定的事务处理和快速的数据读取能力。</p><h3 id="1-硬件配置优化"><a href="#1-硬件配置优化" class="headerlink" title="1. 硬件配置优化"></a>1. 硬件配置优化</h3><p>SQL Server 实例的性能在很大程度上取决于底层硬件的配置，尤其是内存、CPU、磁盘等资源。</p><ul><li><strong>内存</strong>：SQL Server 是一个内存密集型应用，内存越大，缓存命中率越高，查询性能也越好。</li><li><strong>CPU</strong>：更多的 CPU 核心可以处理更多并发请求。</li><li><strong>磁盘</strong>：SSD 驱动器在磁盘 I&#x2F;O 性能方面要优于传统硬盘，尤其是在大型数据库的读写操作中。</li></ul><h3 id="2-SQL-Server-配置优化"><a href="#2-SQL-Server-配置优化" class="headerlink" title="2. SQL Server 配置优化"></a>2. SQL Server 配置优化</h3><p>SQL Server 提供了很多配置参数来调整实例的行为，可以通过这些参数来优化性能。</p><h4 id="配置参数示例"><a href="#配置参数示例" class="headerlink" title="配置参数示例"></a>配置参数示例</h4><ul><li><strong>max degree of parallelism</strong>：控制 SQL Server 查询的并行度。通过合理设置并行度，可以提高多核 CPU 系统的查询效率。</li><li><strong>max server memory</strong>：限制 SQL Server 使用的最大内存量，防止 SQL Server 占用过多内存导致操作系统性能下降。</li><li><strong>cost threshold for parallelism</strong>：设置查询执行的代价阈值，只有当查询的成本超过该值时，SQL Server 才会使用并行执行。</li></ul><h3 id="3-索引优化"><a href="#3-索引优化" class="headerlink" title="3. 索引优化"></a>3. 索引优化</h3><p>索引是提高查询性能的关键，可以根据业务场景为频繁查询的字段创建索引。但过多的索引会影响插入、更新和删除操作的性能，因此需要在查询性能和维护成本之间找到平衡。</p><h3 id="4-查询优化-1"><a href="#4-查询优化-1" class="headerlink" title="4. 查询优化"></a>4. 查询优化</h3><p>对于大型业务系统，查询优化尤为重要。优化查询可以减少数据库的负担，提升响应速度。</p><h4 id="业务场景-6"><a href="#业务场景-6" class="headerlink" title="业务场景"></a>业务场景</h4><p>假设电商平台需要处理大量的订单数据，查询常常涉及到联接多个表，比如查询某个用户在某个时间段内的所有订单。我们可以通过优化 SQL 查询来提高查询速度。</p><h3 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="1-设置-SQL-Server-实例配置参数"><a href="#1-设置-SQL-Server-实例配置参数" class="headerlink" title="1. 设置 SQL Server 实例配置参数"></a>1. 设置 SQL Server 实例配置参数</h4><p>在 SQL Server 实例中，我们可以通过以下 T-SQL 语句来设置一些基本的优化参数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置最大内存使用量为 16 GB</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;max server memory&#x27;</span>, <span class="number">16384</span>;  <span class="comment">-- 单位：MB</span></span><br><span class="line">RECONFIGURE;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置最大并行度为 8 核 CPU</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;max degree of parallelism&#x27;</span>, <span class="number">8</span>;</span><br><span class="line">RECONFIGURE;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置查询的成本阈值为 10</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;cost threshold for parallelism&#x27;</span>, <span class="number">10</span>;</span><br><span class="line">RECONFIGURE;</span><br></pre></td></tr></table></figure><h4 id="2-查询优化-1"><a href="#2-查询优化-1" class="headerlink" title="2. 查询优化"></a>2. 查询优化</h4><p>为了提高查询性能，可以在查询时使用以下技巧：</p><ul><li>避免 SELECT *，仅选择需要的字段。</li><li>使用 JOIN 替代子查询，避免不必要的嵌套查询。</li><li>创建适当的索引来加速查询。</li><li>利用分页查询减少单次查询的数据量。</li></ul><p>以下是一个优化后的查询示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 假设我们需要查询某个用户的订单信息，优化后的 SQL 查询</span></span><br><span class="line"><span class="keyword">SELECT</span> o.OrderID, o.OrderDate, o.TotalAmount, u.UserName</span><br><span class="line"><span class="keyword">FROM</span> Orders o</span><br><span class="line"><span class="keyword">JOIN</span> Users u <span class="keyword">ON</span> o.UserID <span class="operator">=</span> u.UserID</span><br><span class="line"><span class="keyword">WHERE</span> o.OrderDate <span class="keyword">BETWEEN</span> <span class="string">&#x27;2024-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2024-12-31&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> u.UserID <span class="operator">=</span> <span class="number">12345</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> o.OrderDate <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><h4 id="3-索引优化-1"><a href="#3-索引优化-1" class="headerlink" title="3. 索引优化"></a>3. 索引优化</h4><p>为了优化查询，我们可以在 <code>Orders</code> 表的 <code>UserID</code>、<code>OrderDate</code> 字段上创建索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 为 UserID 列创建索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_user_id <span class="keyword">ON</span> Orders(UserID);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为 OrderDate 列创建索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_order_date <span class="keyword">ON</span> Orders(OrderDate);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为 UserID 和 OrderDate 的组合创建复合索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_user_order_date <span class="keyword">ON</span> Orders(UserID, OrderDate);</span><br></pre></td></tr></table></figure><h4 id="4-数据库备份和维护"><a href="#4-数据库备份和维护" class="headerlink" title="4. 数据库备份和维护"></a>4. 数据库备份和维护</h4><p>定期备份和维护数据库可以确保系统在高负载下保持高效。定期的数据库优化任务包括：</p><ul><li>备份数据。</li><li>更新统计信息。</li><li>重建索引。</li></ul><p>以下是一个定期重建索引的示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 重建所有表的索引</span></span><br><span class="line"><span class="keyword">ALTER</span> INDEX <span class="keyword">ALL</span> <span class="keyword">ON</span> Orders REBUILD;</span><br><span class="line"><span class="keyword">ALTER</span> INDEX <span class="keyword">ALL</span> <span class="keyword">ON</span> Users REBUILD;</span><br></pre></td></tr></table></figure><h3 id="5-使用-SQL-Server-的性能监控工具"><a href="#5-使用-SQL-Server-的性能监控工具" class="headerlink" title="5. 使用 SQL Server 的性能监控工具"></a>5. 使用 SQL Server 的性能监控工具</h3><p>SQL Server 提供了一些性能监控工具来帮助识别性能瓶颈。例如，<code>SQL Server Profiler</code> 和 <code>Dynamic Management Views (DMVs)</code> 可以帮助我们实时监控 SQL Server 实例的性能，并根据实际情况进行调优。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看 SQL Server 实例当前的资源使用情况</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sys.dm_exec_requests;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看 SQL Server 实例的内存使用情况</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sys.dm_os_memory_clerks;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看 SQL Server 实例的磁盘 I/O 使用情况</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sys.dm_io_virtual_file_stats(<span class="keyword">NULL</span>, <span class="keyword">NULL</span>);</span><br></pre></td></tr></table></figure><h3 id="小结一下-9"><a href="#小结一下-9" class="headerlink" title="小结一下"></a>小结一下</h3><ol><li><strong>硬件优化</strong>：合理配置 CPU、内存和磁盘，提升 SQL Server 实例的性能。</li><li><strong>实例配置优化</strong>：通过配置 SQL Server 的参数，如内存限制、并行度等，优化性能。</li><li><strong>索引优化</strong>：合理设计索引结构，提高查询效率。</li><li><strong>查询优化</strong>：使用高效的 SQL 查询语句，避免不必要的计算和 I&#x2F;O 操作。</li><li><strong>定期维护和备份</strong>：定期进行数据库维护和备份，确保系统稳定运行。</li></ol><p>通过对 SQL Server 实例的优化，可以显著提升数据库的性能，确保电商平台在高并发、高负载的情况下仍能保持高效响应。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>以上11种优化方案供你参考，优化 SQL Server 数据库性能得从多个方面着手，包括硬件配置、数据库结构、查询优化、索引管理、分区分表、并行处理等。通过合理的索引、查询优化、数据分区等技术，可以在数据量增大时保持较好的性能。同时，定期进行数据库维护和清理，保证数据库高效运行。关注威哥爱编程，V哥做你的技术门童。</p><p>本文来自博客园，作者：<a href="https://www.cnblogs.com/wgjava/">威哥爱编程</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/wgjava/p/18534481">https://www.cnblogs.com/wgjava/p/18534481</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;[南月晨的blog](&lt;a href=&quot;https://leiyu-code.github.io/&quot;&gt;南月晨的博客 (leiyu-code.github.io)&lt;/a&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;leiyu-code.github.io&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.linuxcool.com/&quot;&gt;Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h4&gt;&lt;p&gt;在 SQL Server 中，当数据量增大时，数据库的性能可能会受到影响，导致查询速度变慢、响应时间变长等问题。为了应对大量数据，以下是一些常用的优化策略和案例详解。&lt;/p&gt;
&lt;h2 id=&quot;1-索引优化&quot;&gt;&lt;a href=&quot;#1-索引优化&quot; class=&quot;headerlink&quot; title=&quot;1. 索引优化&quot;&gt;&lt;/a&gt;1. 索引优化&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;创建索引&lt;/strong&gt;：索引可以显著提高查询速度，特别是在使用 &lt;code&gt;WHERE&lt;/code&gt;、&lt;code&gt;JOIN&lt;/code&gt; 和 &lt;code&gt;ORDER BY&lt;/code&gt; 子句时。为常用的查询字段（尤其是筛选条件字段）创建合适的索引。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;选择合适的索引类型&lt;/strong&gt;：使用聚集索引（Clustered Index）和非聚集索引（Non-clustered Index）来优化查询性能。聚集索引适用于排序、范围查询等，而非聚集索引适用于单一列或组合列的查询。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;避免过多索引&lt;/strong&gt;：虽然索引能提高查询性能，但过多的索引会增加更新、插入和删除操作的成本，因此要平衡索引的数量和性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 SQL Server 中，索引优化是提高查询性能的重要手段。以下是一个具体的业务场景，假设我们有一个销售订单系统，订单表 &lt;code&gt;Orders&lt;/code&gt; 需要根据不同的查询需求来进行索引优化。&lt;/p&gt;
&lt;h3 id=&quot;业务场景&quot;&gt;&lt;a href=&quot;#业务场景&quot; class=&quot;headerlink&quot; title=&quot;业务场景&quot;&gt;&lt;/a&gt;业务场景&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;查询需求1：按 &lt;code&gt;CustomerID&lt;/code&gt; 和 &lt;code&gt;OrderDate&lt;/code&gt; 查询订单信息。&lt;/li&gt;
&lt;li&gt;查询需求2：按 &lt;code&gt;ProductID&lt;/code&gt; 查询所有相关的订单。&lt;/li&gt;
&lt;li&gt;查询需求3：查询某一订单的详细信息（通过 &lt;code&gt;OrderID&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于这些需求，我们将为 &lt;code&gt;Orders&lt;/code&gt; 表创建索引，并展示如何选择合适的索引类型。&lt;/p&gt;
&lt;h3 id=&quot;1-创建表-Orders&quot;&gt;&lt;a href=&quot;#1-创建表-Orders&quot; class=&quot;headerlink&quot; title=&quot;1. 创建表 Orders&quot;&gt;&lt;/a&gt;1. 创建表 &lt;code&gt;Orders&lt;/code&gt;&lt;/h3&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;TABLE&lt;/span&gt; Orders (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    OrderID &lt;span class=&quot;type&quot;&gt;INT&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;PRIMARY&lt;/span&gt; KEY,         &lt;span class=&quot;comment&quot;&gt;-- 主键索引，自动创建聚集索引&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CustomerID &lt;span class=&quot;type&quot;&gt;INT&lt;/span&gt;,                  &lt;span class=&quot;comment&quot;&gt;-- 客户ID&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    OrderDate DATETIME,              &lt;span class=&quot;comment&quot;&gt;-- 订单日期&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ProductID &lt;span class=&quot;type&quot;&gt;INT&lt;/span&gt;,                   &lt;span class=&quot;comment&quot;&gt;-- 产品ID&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TotalAmount &lt;span class=&quot;type&quot;&gt;DECIMAL&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;18&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;),      &lt;span class=&quot;comment&quot;&gt;-- 订单总金额&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Status &lt;span class=&quot;type&quot;&gt;VARCHAR&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;)               &lt;span class=&quot;comment&quot;&gt;-- 订单状态&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="workNote" scheme="http://example.com/categories/workNote/"/>
    
    
    <category term="database" scheme="http://example.com/tags/database/"/>
    
    <category term="sqlserver" scheme="http://example.com/tags/sqlserver/"/>
    
  </entry>
  
  <entry>
    <title>数据库损坏或置疑中间件连接不了数据库</title>
    <link href="http://example.com/2024/11/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BD%AE%E7%96%91/"/>
    <id>http://example.com/2024/11/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BD%AE%E7%96%91/</id>
    <published>2024-11-12T02:10:06.000Z</published>
    <updated>2024-11-12T02:50:42.225Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p><p>leiyu-code.github.io</p><p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p>数据库变为可疑状态通常是由于突然断电、服务器死机或强制关机等原因导致的。为了避免这种情况，建议定期备份数据库，确保有完整的备份文件。此外，确保服务器稳定运行，避免不必要的关机操作，可以减少数据库损坏的风险</p><p><em><strong>1、最简单的解决方法是用备份的数据库文件恢复数据库</strong></em></p><p><em><strong>2、用以下语句可以修复数据库</strong></em></p><span id="more"></span><p>先断开与网络的连接</p><p>将可疑的数据库修改为紧急状态，以便进行修复操作。可以使用以下SQL语句实现：<br><code>ALTER DATABASE 数据库名 SET EMERGENCY</code><br>执行此操作后，数据库会变为红色紧急状态，此时可以看到数据库的结构和数据，但无法进行备份等操作</p><p>接下来，将数据库设置为单用户模式，以便进行修复：<br><code>ALTER DATABASE 数据库名 SET SINGLE_USER</code><br>在单用户模式下，只有一个用户连接，这有助于避免并发问题，可以在后面加个WITH ROLLBACK IMMEDIATE从句立刻回滚未提交的修改</p><p>使用DBCC CHECKDB命令检查并修复数据库。此命令可以检测数据库的结构错误，并尝试修复它们。使用以下语句：<br><code>DBCC CHECKDB(数据库名, REPAIR_ALLOW_DATA_LOSS)</code><br>注意，使用此参数可能会造成数据丢失</p><p>将数据库恢复为多用户模式，允许正常访问：<br><code>ALTER DATABASE 数据库名 SET MULTI_USER</code></p><p>确保数据库设置为在线状态，以便进行正常的读写操作：<br><code>ALTER DATABASE 数据库名 SET ONLINE</code></p><p>退出数据库管理工具，重启sql服务<br>cmd命令   service.msc<br>停止MSSQLSERVER服务，再启动MSSQLSERVER服务</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;[南月晨的blog](&lt;a href=&quot;https://leiyu-code.github.io/&quot;&gt;南月晨的博客 (leiyu-code.github.io)&lt;/a&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;leiyu-code.github.io&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.linuxcool.com/&quot;&gt;Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h4&gt;&lt;p&gt;数据库变为可疑状态通常是由于突然断电、服务器死机或强制关机等原因导致的。为了避免这种情况，建议定期备份数据库，确保有完整的备份文件。此外，确保服务器稳定运行，避免不必要的关机操作，可以减少数据库损坏的风险&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;1、最简单的解决方法是用备份的数据库文件恢复数据库&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;2、用以下语句可以修复数据库&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="workNote" scheme="http://example.com/categories/workNote/"/>
    
    
    <category term="database" scheme="http://example.com/tags/database/"/>
    
    <category term="sqlserver" scheme="http://example.com/tags/sqlserver/"/>
    
  </entry>
  
  <entry>
    <title>数据库日志文件.ldf文件过大</title>
    <link href="http://example.com/2024/09/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A5%E5%BF%97%E6%95%B0%E6%8D%AE%E8%BF%87%E5%A4%A7/"/>
    <id>http://example.com/2024/09/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A5%E5%BF%97%E6%95%B0%E6%8D%AE%E8%BF%87%E5%A4%A7/</id>
    <published>2024-09-06T08:28:06.000Z</published>
    <updated>2024-09-11T02:15:39.618Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p><p>leiyu-code.github.io</p><p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p><em><strong>数据库LDF日志文件存储的是数据库操作数据的信息，其中包含有(新增数据、修改数据、删除数据等）</strong></em></p><p>ldf文件日志过大会占满整个硬盘分区，导致数据库管理软件进不去或数据库报错</p><h4 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h4><p><strong>收缩SQL2008数据库</strong></p><p>1，点击电脑左下角开始-Microsoft SQL Server2008 R2-SSMS-Microsoft SQL Server Management Studio,进入SSMS页面后使用Windows身份验证连接上SQL Server。</p><p><a href="https://imgse.com/i/pAmqBh6"><img src="https://s21.ax1x.com/2024/09/11/pAmqBh6.md.png" alt="pAmqBh6.md.png"></a></p><p>2，进入SSMS后在左侧数据库目录中找到需要收缩ldf文件的数据库名称（例如：QFBJZT）然后右键选择“属性”快捷命令。在打开的QFBJZT数据库属性页面单击“选项”标签，恢复模式后下拉菜单中选择“简单”模式，设置好后单击“确定”按钮使设置生效。</p><span id="more"></span><p><a href="https://imgse.com/i/pAmqs1O"><img src="https://s21.ax1x.com/2024/09/11/pAmqs1O.png" alt="pAmqs1O.png"></a></p><p>3，返回SSMS窗口，右键单击目标数据库名称QFBJZT，右键选择任务-收缩-数据库。</p><p><a href="https://imgse.com/i/pAmqycD"><img src="https://s21.ax1x.com/2024/09/11/pAmqycD.png" alt="pAmqycD.png"></a></p><p>4，在收缩数据库页面中无须调整参数，直接单击“确定”按钮开始收缩数据库的操作。日志文件在一些异常情况下往往是恢复数据库的重要依据，收缩数据库操作主要作用是收缩日志大小。所以需要定期进行上述操作，以免数据库日志过大。</p><p><a href="https://imgse.com/i/pAmq0tx"><img src="https://s21.ax1x.com/2024/09/11/pAmq0tx.png" alt="pAmq0tx.png"></a></p><p>5，最后再次右键数据库QFBJZT选择“属性”，在打开的QFBJZT数据库属性页面单击“选项”标签，恢复模式后下拉菜单中选择回“完整”模式，设置好后单击“确定”按钮使设置生效即可完成收缩数据库日志文件工作。</p><p><a href="https://imgse.com/i/pAmqr9K"><img src="https://s21.ax1x.com/2024/09/11/pAmqr9K.png" alt="pAmqr9K.png"></a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;[南月晨的blog](&lt;a href=&quot;https://leiyu-code.github.io/&quot;&gt;南月晨的博客 (leiyu-code.github.io)&lt;/a&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;leiyu-code.github.io&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.linuxcool.com/&quot;&gt;Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h4&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;数据库LDF日志文件存储的是数据库操作数据的信息，其中包含有(新增数据、修改数据、删除数据等）&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;ldf文件日志过大会占满整个硬盘分区，导致数据库管理软件进不去或数据库报错&lt;/p&gt;
&lt;h4 id=&quot;解决方法：&quot;&gt;&lt;a href=&quot;#解决方法：&quot; class=&quot;headerlink&quot; title=&quot;解决方法：&quot;&gt;&lt;/a&gt;解决方法：&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;收缩SQL2008数据库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1，点击电脑左下角开始-Microsoft SQL Server2008 R2-SSMS-Microsoft SQL Server Management Studio,进入SSMS页面后使用Windows身份验证连接上SQL Server。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://imgse.com/i/pAmqBh6&quot;&gt;&lt;img src=&quot;https://s21.ax1x.com/2024/09/11/pAmqBh6.md.png&quot; alt=&quot;pAmqBh6.md.png&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2，进入SSMS后在左侧数据库目录中找到需要收缩ldf文件的数据库名称（例如：QFBJZT）然后右键选择“属性”快捷命令。在打开的QFBJZT数据库属性页面单击“选项”标签，恢复模式后下拉菜单中选择“简单”模式，设置好后单击“确定”按钮使设置生效。&lt;/p&gt;</summary>
    
    
    
    <category term="workNote" scheme="http://example.com/categories/workNote/"/>
    
    
    <category term="database" scheme="http://example.com/tags/database/"/>
    
    <category term="sqlserver" scheme="http://example.com/tags/sqlserver/"/>
    
  </entry>
  
  <entry>
    <title>王熙凤毒设相思局　贾天祥正照风月鉴</title>
    <link href="http://example.com/2024/09/05/%E7%8E%8B%E7%86%99%E5%87%A4%E6%AF%92%E8%AE%BE%E7%9B%B8%E6%80%9D%E5%B1%80%E3%80%80%E8%B4%BE%E5%A4%A9%E7%A5%A5%E6%AD%A3%E7%85%A7%E9%A3%8E%E6%9C%88%E9%89%B4/"/>
    <id>http://example.com/2024/09/05/%E7%8E%8B%E7%86%99%E5%87%A4%E6%AF%92%E8%AE%BE%E7%9B%B8%E6%80%9D%E5%B1%80%E3%80%80%E8%B4%BE%E5%A4%A9%E7%A5%A5%E6%AD%A3%E7%85%A7%E9%A3%8E%E6%9C%88%E9%89%B4/</id>
    <published>2024-09-05T03:41:06.000Z</published>
    <updated>2024-09-11T02:04:48.571Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p><p><a href="http://leiyu-code.github.io">leiyu-code.github.io</a></p><p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p><h1>《红楼梦》-第12回</h1><h1>王熙凤毒设相思局　贾天祥正照风月鉴</h1><p>​话说凤姐正与平儿说话，只见有人回说：“瑞大爷来了。”凤姐急命“快请进来。”贾瑞见往里让，心中喜出望外，急忙进来，见了凤姐，满面陪笑，连连问好。凤姐儿也假意殷勤，让茶让坐。</p><p>贾瑞见凤姐如此打扮，亦发酥倒，因饧了眼问道：“二哥哥怎么还不回来？”凤姐道：“不知什么原故。”贾瑞笑道：“别是路上有人绊住了脚了，舍不得回来也未可知？”凤姐道：“也未可知。男人家见一个爱一个也是有的。”贾瑞笑道：“嫂子这话说错了，我就不这样。”凤姐笑道：“像你这样的人能有几个呢，十个里也挑不出一个来。”贾瑞听了喜的抓耳挠腮，又道：“嫂子天天也闷的很。”凤姐道：“正是呢，只盼个人来说话解解闷儿。”贾瑞笑道：“我倒天天闲着，天天过来替嫂子解解闲闷可好不好？”凤姐笑道：“你哄我呢，你那里肯往我这里来。”贾瑞道：“我在嫂子跟前，若有一点谎话，天打雷劈！只因素日闻得人说，嫂子是个利害人，在你跟前一点也错不得，所以唬住了我。如今见嫂子最是个有说有笑极疼人的，我怎么不来，----死了也愿意！”凤姐笑道：“果然你是个明白人，比贾蓉两个强远了。我看他那样清秀，只当他们心里明白，谁知竟是两个胡涂虫，一点不知人心。”</p><span id="more"></span><p>贾瑞听了这话，越发撞在心坎儿上，由不得又往前凑了一凑，觑着眼看凤姐带的荷包，然后又问带着什么戒指。凤姐悄悄道：“放尊重着，别叫丫头们看了笑话。”贾瑞如听纶音佛语一般，忙往后退。凤姐笑道：“你该走了。”贾瑞说：“我再坐一坐儿。----好狠心的嫂子。”凤姐又悄悄的道：“大天白日，人来人往，你就在这里也不方便。你且去，等着晚上起了更你来，悄悄的在西边穿堂儿等我。”贾瑞听了，如得珍宝，忙问道：“你别哄我。但只那里人过的多，怎么好躲的？”凤姐道：“你只放心。我把上夜的小厮们都放了假，两边门一关，再没别人了。”贾瑞听了，喜之不尽，忙忙的告辞而去，心内以为得手。</p><p>盼到晚上，果然黑地里摸入荣府，趁掩门时，钻入穿堂。果见漆黑无一人，往贾母那边去的门户已倒锁，只有向东的门未关。贾瑞侧耳听着，半日不见人来，忽听咯噔一声，东边的门也倒关了。贾瑞急的也不敢则声，只得悄悄的出来，将门撼了撼，关的铁桶一般。此时要求出去亦不能够，南北皆是大房墙，要跳亦无攀援。这屋内又是过门风，空落落，现是腊月天气，夜又长，朔风凛凛，侵肌裂骨，一夜几乎不曾冻死。好容易盼到早晨，只见一个老婆子先将东门开了，进去叫西门。贾瑞瞅他背着脸，一溜烟抱着肩跑了出来，幸而天气尚早，人都未起，从后门一径跑回家去。</p><p>原来贾瑞父母早亡，只有他祖父代儒教养。那代儒素日教训最严，不许贾瑞多走一步，生怕他在外吃酒赌钱，有误学业。今忽见他一夜不归，只料定他在外非饮即赌，嫖娼宿妓，那里想到这段公案，因此气了一夜。贾瑞也捻着一把汗，少不得回来撒谎，只说：“往舅舅家去了，天黑了，留我住了一夜。”代儒道：“自来出门，非禀我不敢擅出，如何昨日私自去了？据此亦该打，何况是撒谎。”因此，发狠到底打了三四十扳，不许吃饭，令他跪在院内读文章，定要补出十天的工课来方罢。贾瑞直冻了一夜，今又遭了苦打，且饿着肚子，跪着在风地里读文章，其苦万状。</p><p>此时贾瑞前心犹是未改，再想不到是凤姐捉弄他。过后两日，得了空，便仍来找凤姐。凤姐故意抱怨他失信，贾瑞急的赌身发誓。凤姐因见他自投罗网，少不得再寻别计令他知改，故又约他道：“今日晚上，你别在那里了。你在我这房后小过道子里那间空屋里等我，可别冒撞了。”贾瑞道：“果真？”凤姐道：“谁可哄你，你不信就别来。”贾瑞道：“来，来，来。死也要来！”凤姐道：“这会子你先去罢。”贾瑞料定晚间必妥，此时先去了。凤姐在这里便点兵派将，设下圈套。</p><p>那贾瑞只盼不到晚上，偏生家里亲戚又来了，直等吃了晚饭才去，那天已有掌灯时候。又等他祖父安歇了，方溜进荣府，直往那夹道中屋子里来等着，热锅上的蚂蚁一般，只是干转。左等不见人影，右听也没声响，心下自思：“别是又不来了，又冻我一夜不成？”正自胡猜，只见黑曀曀的来了一个人，贾瑞便意定是凤姐，不管皂白，饿虎一般，等那人刚至门前，便如猫捕鼠的一般，抱住叫道：“亲嫂子，等死我了。”说着，抱到屋里炕上就亲嘴扯裤子，满口里“亲娘”“亲爹”的乱叫起来。那人只不作声。贾瑞拉了自己裤子，硬帮帮的就想顶入。忽见灯光一闪，只见贾蔷举着个捻子照道：“谁在屋里？”只见炕上那人笑道：“瑞大叔要臊我呢。”贾瑞一见，却是贾蓉，真臊的无地可入，不知要怎么样才好，回身就要跑，被贾蔷一把揪住道：“别走！如今琏二嫂已经告到太太跟前，说你无故调戏他。他暂用了个脱身计，哄你在这边等着，太太气死过去，因此叫我来拿你。刚才你又拦住他，没的说，跟我去见太太！”</p><p>贾瑞听了，魂不附体，只说：“好侄儿，只说没有见我，明日我重重的谢你。”贾蔷道：“你若谢我，放你不值什么，只不知你谢我多少？况且口说无凭，写一文契来。”贾瑞道：“这如何落纸呢？”贾蔷道：“这也不妨，写一个赌钱输了外人帐目，借头家银若干两便罢。”贾瑞道：“这也容易。只是此时无纸笔。”贾蔷道：“这也容易。”说罢翻身出来，纸笔现成，拿来命贾瑞写。他两作好作歹，只写了五十两，然后画了押，贾蔷收起来。然后撕逻贾蓉。贾蓉先咬定牙不依，只说：“明日告诉族中的人评评理。”贾瑞急的至于叩头。贾蔷作好作歹的，也写了一张五十两欠契才罢。贾蔷又道：“如今要放你，我就担着不是。老太太那边的门早已关了，老爷正在厅上看南京的东西，那一条路定难过去，如今只好走后门。若这一走，倘或遇见了人，连我也完了。等我们先去哨探哨探，再来领你。这屋你还藏不得，少时就来堆东西。等我寻个地方。”说毕，拉着贾瑞，仍熄了灯，出至院外，摸着大台矶底下，说道：“这窝儿里好，你只蹲着，别哼一声，等我们来再动。”说毕，二人去了。</p><p>贾瑞此时身不由己，只得蹲在那里。心下正盘算，只听头顶上一声响，嗗拉拉一净桶尿粪从上面直泼下来，可巧浇了他一身一头。贾瑞掌不住嗳哟了一声，忙又掩住口，不敢声张，满头满脸浑身皆是尿屎，冰冷打战。只见贾蔷跑来叫：“快走，快走！”贾瑞如得了命，三步两步从后门跑到家里，天已三更，只得叫门。开门人见他这般景况，问是怎的。少不得扯谎说：“黑了，失脚掉在茅厕里了。”一面到了自己房中更衣洗濯，心下方想到是凤姐顽他，因此发一回恨，再想想凤姐的模样儿，又恨不得一时搂在怀内，一夜竟不曾合眼。</p><p>自此满心想凤姐，只不敢往荣府去了。贾蓉两个又常常的来索银子，他又怕祖父知道，正是相思尚且难禁，更又添了债务，日间工课又紧，他二十来岁人，尚未娶亲，迩来想着凤姐，未免有那指头告了消乏等事，更兼两回冻恼奔波，因此三五下里夹攻，不觉就得了一病：心内发膨胀，口中无滋味，脚下如绵，眼中似醋，黑夜作烧，白昼常倦，下溺连精，嗽痰带血。诸如此症，不上一年都添全了。于是不能支持，一头睡倒，合上眼还只梦魂颠倒，满口乱说胡话，惊怖异常。百般请医疗治，诸如肉桂，附子，鳖甲，麦冬，玉竹等药，吃了有几十斤下去，也不见个动静。</p><p>倏又腊尽春回，这病更又沉重。代儒也着了忙，各处请医疗治，皆不见效。因后来吃“独参汤”，代儒如何有这力量，只得往荣府来寻。王夫人命凤姐秤二两给他，凤姐回说：“前儿新近都替老太太配了药，那整的太太又说留着送杨提督的太太配药，偏生昨儿我已送了去了。”王夫人道：“就是咱们这边没了，你打发个人往你婆婆那边问问，或是你珍大哥哥那府里再寻些来，凑着给人家。吃好了，救人一命，也是你的好处。”凤姐听了，也不遣人去寻，只得将些渣末泡须凑了几钱，命人送去，只说：“太太送来的，再也没了。”然后回王夫人，只说：“都寻了来，共凑了有二两送去。”</p><p>那贾瑞此时要命心甚切，无药不吃，只是白花钱，不见效。忽然这日有个跛足道人来化斋，口称专治冤业之症。贾瑞偏生在内就听见了，直着声叫喊说：“快请进那位菩萨来救我！”一面叫，一面在枕上叩首。众人只得带了那道士进来。贾瑞一把拉住，连叫“菩萨救我！”那道士叹道：“你这病非药可医。我有个宝贝与你，你天天看时，此命可保矣。”说毕，从褡裢中取出一面镜子来----两面皆可照人，镜把上面錾着“风月宝鉴”四字----递与贾瑞道：“这物出自太虚幻境空灵殿上，警幻仙子所制，专治邪思妄动之症，有济世保生之功。所以带他到世上，单与那些聪明杰俊，风雅王孙等看照。千万不可照正面，只照他的背面，要紧，要紧！三日后吾来收取，管叫你好了。”说毕，佯常而去，众人苦留不住。</p><p>贾瑞收了镜子，想道：“这道士倒有意思，我何不照一照试试。”想毕，拿起“风月鉴”来，向反面一照，只见一个骷髅立在里面，唬得贾瑞连忙掩了，骂：“道士混帐，如何吓我！----我倒再照照正面是什么。”想着，又将正面一照，只见凤姐站在里面招手叫他。贾瑞心中一喜，荡悠悠的觉得进了镜子，与凤姐云雨一番，凤姐仍送他出来。到了床上，哎哟了一声，一睁眼，镜子从手里掉过来，仍是反面立着一个骷髅。贾瑞自觉汗津津的，底下已遗了一滩精。心中到底不足，又翻过正面来，只见凤姐还招手叫他，他又进去。如此三四次。到了这次，刚要出镜子来，只见两个人走来，拿铁锁把他套住，拉了就走。贾瑞叫道：“让我拿了镜子再走。”----只说了这句，就再不能说话了。</p><p>旁边伏侍贾瑞的众人，只见他先还拿着镜子照，落下来，仍睁开眼拾在手内，末后镜子落下来便不动了。众人上来看看，已没了气。身子底下冰凉渍湿一大滩精，这才忙着穿衣抬床。代儒夫妇哭的死去活来，大骂道士，“是何妖镜！若不早毁此物，遗害于世不小。”遂命架火来烧，只听镜内哭道：“谁叫你们瞧正面了！你们自己以假为真，何苦来烧我？”正哭着，只见那跛足道人从外面跑来，喊道：“谁毁‘风月鉴’，吾来救也！”说着，直入中堂，抢入手内，飘然去了。</p><p>当下，代儒料理丧事，各处去报丧。三日起经，七日发引，寄灵于铁槛寺，日后带回原籍。当下贾家众人齐来吊问，荣国府贾赦赠银二十两，贾政亦是二十两，宁国府贾珍亦有二十两，别者族中贫富不等，或三两五两，不可胜数。另有各同窗家分资，也凑了二三十两。代儒家道虽然淡薄，倒也丰丰富富完了此事。</p><p>谁知这年冬底，林如海的书信寄来，却为身染重疾，写书特来接林黛玉回去。贾母听了，未免又加忧闷，只得忙忙的打点黛玉起身。宝玉大不自在，争奈父女之情，也不好拦劝。于是贾母定要贾琏送他去，仍叫带回来。一应土仪盘缠，不消烦说，自然要妥贴。作速择了日期，贾琏与林黛玉辞别了贾母等，带领仆从，登舟往扬州去了。要知端的，且听下回分解。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;[南月晨的blog](&lt;a href=&quot;https://leiyu-code.github.io/&quot;&gt;南月晨的博客 (leiyu-code.github.io)&lt;/a&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://leiyu-code.github.io&quot;&gt;leiyu-code.github.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.linuxcool.com/&quot;&gt;Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;《红楼梦》-第12回&lt;/h1&gt;
&lt;h1&gt;王熙凤毒设相思局　贾天祥正照风月鉴&lt;/h1&gt;
&lt;p&gt;​		话说凤姐正与平儿说话，只见有人回说：“瑞大爷来了。”凤姐急命“快请进来。”贾瑞见往里让，心中喜出望外，急忙进来，见了凤姐，满面陪笑，连连问好。凤姐儿也假意殷勤，让茶让坐。&lt;/p&gt;
&lt;p&gt;贾瑞见凤姐如此打扮，亦发酥倒，因饧了眼问道：“二哥哥怎么还不回来？”凤姐道：“不知什么原故。”贾瑞笑道：“别是路上有人绊住了脚了，舍不得回来也未可知？”凤姐道：“也未可知。男人家见一个爱一个也是有的。”贾瑞笑道：“嫂子这话说错了，我就不这样。”凤姐笑道：“像你这样的人能有几个呢，十个里也挑不出一个来。”贾瑞听了喜的抓耳挠腮，又道：“嫂子天天也闷的很。”凤姐道：“正是呢，只盼个人来说话解解闷儿。”贾瑞笑道：“我倒天天闲着，天天过来替嫂子解解闲闷可好不好？”凤姐笑道：“你哄我呢，你那里肯往我这里来。”贾瑞道：“我在嫂子跟前，若有一点谎话，天打雷劈！只因素日闻得人说，嫂子是个利害人，在你跟前一点也错不得，所以唬住了我。如今见嫂子最是个有说有笑极疼人的，我怎么不来，----死了也愿意！”凤姐笑道：“果然你是个明白人，比贾蓉两个强远了。我看他那样清秀，只当他们心里明白，谁知竟是两个胡涂虫，一点不知人心。”&lt;/p&gt;</summary>
    
    
    
    <category term="excerpt" scheme="http://example.com/categories/excerpt/"/>
    
    
    <category term="红楼梦" scheme="http://example.com/tags/%E7%BA%A2%E6%A5%BC%E6%A2%A6/"/>
    
    <category term="原文" scheme="http://example.com/tags/%E5%8E%9F%E6%96%87/"/>
    
    <category term="宝物" scheme="http://example.com/tags/%E5%AE%9D%E7%89%A9/"/>
    
  </entry>
  
  <entry>
    <title>用命令行激活windows</title>
    <link href="http://example.com/2024/08/14/%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BF%80%E6%B4%BBwindows/"/>
    <id>http://example.com/2024/08/14/%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BF%80%E6%B4%BBwindows/</id>
    <published>2024-08-14T01:45:06.000Z</published>
    <updated>2024-08-14T01:56:29.984Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p><p><a href="http://leiyu-code.github.io">leiyu-code.github.io</a></p><p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p><p>直接以管理员打开CMD或POWERSHELL:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、slmgr.vbs /upk</span><br><span class="line"><span class="number">2</span>、slmgr /ipk W269N-WFGWX-YVC9B-<span class="number">4</span>J6C9-T83GX</span><br><span class="line"><span class="number">3</span>、slmgr /skms zh.us.to</span><br><span class="line"><span class="number">4</span>、slmgr -ato</span><br></pre></td></tr></table></figure><span id="more"></span><p>要是不行，把第三行改成slmgr -skms <a href="http://kms.03k.org">kms.03k.org</a><br>slmgr.vbs /upk<br>slmgr /ipk M7XTQ-FN8P6-TTKYV-9D4CC-J462D<br>slmgr -skms <a href="http://kms.03k.org">kms.03k.org</a><br>slmgr -ato<br>slmgr.<br>slmgr.vbs /upk<br>slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX<br>slmgr<br>slmgr -skms <a href="http://kms.03k.org">kms.03k.org</a></p><p><a href="https://www.jianshu.com/p/4968e4f494d4">永久激活windows11 - 简书 (jianshu.com)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;[南月晨的blog](&lt;a href=&quot;https://leiyu-code.github.io/&quot;&gt;南月晨的博客 (leiyu-code.github.io)&lt;/a&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://leiyu-code.github.io&quot;&gt;leiyu-code.github.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.linuxcool.com/&quot;&gt;Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;直接以管理员打开CMD或POWERSHELL:&lt;/p&gt;
&lt;figure class=&quot;highlight cmd&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;、slmgr.vbs /upk&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;、slmgr /ipk W269N-WFGWX-YVC9B-&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;J6C9-T83GX&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;、slmgr /skms zh.us.to&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;、slmgr -ato&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Active" scheme="http://example.com/categories/Active/"/>
    
    
    <category term="windows" scheme="http://example.com/tags/windows/"/>
    
    <category term="windows11" scheme="http://example.com/tags/windows11/"/>
    
  </entry>
  
  <entry>
    <title>社区型免费蜜罐-hfish</title>
    <link href="http://example.com/2024/06/23/%E7%A4%BE%E5%8C%BA%E5%9E%8B%E5%85%8D%E8%B4%B9%E8%9C%9C%E7%BD%90-hfish/"/>
    <id>http://example.com/2024/06/23/%E7%A4%BE%E5%8C%BA%E5%9E%8B%E5%85%8D%E8%B4%B9%E8%9C%9C%E7%BD%90-hfish/</id>
    <published>2024-06-23T09:28:06.000Z</published>
    <updated>2024-06-23T09:01:57.385Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p><p><a href="http://leiyu-code.github.io">leiyu-code.github.io</a></p><p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p><h4 id="HFish"><a href="https://hfish.net/#/README?id=hfish%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5">HFish</a></h4><p>HFish是一款社区型免费蜜罐，侧重企业安全场景，从内网失陷检测、外网威胁感知、威胁情报生产三个场景出发，为用户提供可独立操作且实用的功能，通过安全、敏捷、可靠的中低交互蜜罐增加用户在失陷感知和威胁情报领域的能力。</p><p>HFish支持基本网络 服务、OA系统、CRM系统、NAS存储系统、Web服务器、运维平台、安全产品、无线AP、交换机/路由器、邮件系统、IoT设备等90多种蜜罐服务、支持用户制作自定义Web蜜罐、支持流量牵引到免费云蜜网、支持可开关的全端口扫描感知能力、支持可自定义的蜜饵配置、一键部署、跨平台多架构，支持Linux x32/x64/ARM、Windows x32/x64平台和多种国产操作系统、支持龙芯、海光、飞腾、鲲鹏、腾云、兆芯等国产CPU、极低的性能要求、邮件/syslog/webhook/企业微信/钉钉/飞书告警等多项特性，帮助用户降低运维成本，提升运营效率。</p><p>用户需要先部署管理端，再通过管理端内置蜜罐节点或部署新节点：</p><p><a href="https://hfish.net/#/2-2-linux">Linux管理端下载</a></p><p><a href="https://hfish.net/#/2-3-windows">Windows管理端下载</a></p><p><a href="https://hfish.net/#/2-1-docker">Docker镜像下载</a></p><span id="more"></span><p>如果有企业下载需求，您也可以前往<a href="https://hfish.net/#/docs">HFish文档区域</a>下载部署文档方案。</p><h4 id="为什么选择HFish"><a href="https://hfish.net/#/README?id=%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9hfish">为什么选择HFish</a></h4><blockquote><h5 id="免费、简单、安全的蜜罐产品"><a href="https://hfish.net/#/README?id=%E5%85%8D%E8%B4%B9%E3%80%81%E7%AE%80%E5%8D%95%E3%80%81%E5%AE%89%E5%85%A8%E7%9A%84%E8%9C%9C%E7%BD%90%E4%BA%A7%E5%93%81">免费、简单、安全的蜜罐产品</a></h5></blockquote><p>蜜罐通常被定义为具有轻量级检测能力、低误报率的检测产品，同时它也是企业生产本地威胁情报的优质来源之一。HFish可以帮助中小型企业用户在日常安全运营中进行避免告警洪水、低成本的增加威胁感知和情报生产能力。目前，社区的力量正在不断帮助HFish完善自身，共同探索欺骗防御的最佳实践。</p><blockquote><h5 id="安全、敏捷的威胁感知节点"><a href="https://hfish.net/#/README?id=%E5%AE%89%E5%85%A8%E3%80%81%E6%95%8F%E6%8D%B7%E7%9A%84%E5%A8%81%E8%83%81%E6%84%9F%E7%9F%A5%E8%8A%82%E7%82%B9">安全、敏捷的威胁感知节点</a></h5></blockquote><p>HFish被广泛应用于感知办公内网、生产环境、云内网及其他环境失陷主机横向移动、员工账号外泄、扫描和探测行为、私有情报生产甚至内部演练和安全意识培训，HFish的多种告警输出形式与态感、NDR、XDR或日志平台结合，极大拓展检测视野。</p><h4 id="HFish架构"><a href="https://hfish.net/#/README?id=hfish%E6%9E%B6%E6%9E%84">HFish架构</a></h4><p>HFish采用B/S架构，HFish由管理端（server）和节点端（client）组成，管理端用来生成和管理节点端，并接收、分析和展示节点端回传的数据，节点端接受管理端的控制并负责构建蜜罐服务。</p><p>在HFish中，<strong>管理端</strong>只用于<strong>数据的分析和展示</strong>，<strong>节点端</strong>进行<strong>虚拟蜜罐</strong>，最后由<strong>蜜罐来承受攻击</strong>。</p><p>HFish各模块关系图</p><p><img src="https://hfish.net/images/20210616174908.png" alt="image-20210611130621311"></p><h4 id="我们的故事"><a href="https://hfish.net/#/README?id=%E6%88%91%E4%BB%AC%E7%9A%84%E6%95%85%E4%BA%8B">我们的故事</a></h4><p>2019年的8月7日，我们发布了自己的第一款开源蜜罐HFish，在之后的16个月里，HFish在Github上获得2.6k个star，在Gitee上成为安全类目TOP5的GVP项目。</p><p>2021年2月9日，融合社区反馈和过去2年的思考，我们开启了全新概念的威胁捕捉和诱骗系统HFish v2版本，并宣布采用闭源共享方式向所有用户免费授权使用。</p><h4 id="联系我们"><a href="https://hfish.net/#/README?id=%E8%81%94%E7%B3%BB%E6%88%91%E4%BB%AC">联系我们</a></h4><p>HFish是北京微步在线科技有限公司旗下社区型免费蜜罐产品</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">联系地址：北京市海淀区苏州街49号盈智大厦4层</span><br><span class="line">联系电话：400-030-1051复制失败成功</span><br></pre></td></tr></table></figure><p><img src="http://img.threatbook.cn/hfish/image-20220729162931543.png" alt="image-20220729162931543"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;[南月晨的blog](&lt;a href=&quot;https://leiyu-code.github.io/&quot;&gt;南月晨的博客 (leiyu-code.github.io)&lt;/a&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://leiyu-code.github.io&quot;&gt;leiyu-code.github.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.linuxcool.com/&quot;&gt;Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;HFish&quot;&gt;&lt;a href=&quot;https://hfish.net/#/README?id=hfish%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5&quot;&gt;HFish&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;HFish是一款社区型免费蜜罐，侧重企业安全场景，从内网失陷检测、外网威胁感知、威胁情报生产三个场景出发，为用户提供可独立操作且实用的功能，通过安全、敏捷、可靠的中低交互蜜罐增加用户在失陷感知和威胁情报领域的能力。&lt;/p&gt;
&lt;p&gt;HFish支持基本网络 服务、OA系统、CRM系统、NAS存储系统、Web服务器、运维平台、安全产品、无线AP、交换机/路由器、邮件系统、IoT设备等90多种蜜罐服务、支持用户制作自定义Web蜜罐、支持流量牵引到免费云蜜网、支持可开关的全端口扫描感知能力、支持可自定义的蜜饵配置、一键部署、跨平台多架构，支持Linux x32/x64/ARM、Windows x32/x64平台和多种国产操作系统、支持龙芯、海光、飞腾、鲲鹏、腾云、兆芯等国产CPU、极低的性能要求、邮件/syslog/webhook/企业微信/钉钉/飞书告警等多项特性，帮助用户降低运维成本，提升运营效率。&lt;/p&gt;
&lt;p&gt;用户需要先部署管理端，再通过管理端内置蜜罐节点或部署新节点：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://hfish.net/#/2-2-linux&quot;&gt;Linux管理端下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://hfish.net/#/2-3-windows&quot;&gt;Windows管理端下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://hfish.net/#/2-1-docker&quot;&gt;Docker镜像下载&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="safe" scheme="http://example.com/categories/safe/"/>
    
    
    <category term="hfish" scheme="http://example.com/tags/hfish/"/>
    
  </entry>
  
  <entry>
    <title>windows命令-route</title>
    <link href="http://example.com/2024/06/23/windows%E5%91%BD%E4%BB%A4%E2%80%94route/"/>
    <id>http://example.com/2024/06/23/windows%E5%91%BD%E4%BB%A4%E2%80%94route/</id>
    <published>2024-06-23T07:32:06.000Z</published>
    <updated>2024-06-23T07:59:50.393Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p><p>leiyu-code.github.io</p><p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p><h4 id="route命令"><a href="#route命令" class="headerlink" title="route命令"></a><em><strong>route命令</strong></em></h4><p>  route命令用于显示和操作IP路由表。要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者同时位于两个网络的网关来实现。windows环境下route命令常用于多网卡终端，默认路由指向连接访问互联网的网卡，静态路由指向内网网卡。</p><span id="more"></span><h5 id="1、获取命令帮助"><a href="#1、获取命令帮助" class="headerlink" title="1、获取命令帮助"></a>1、获取命令帮助</h5><p>route –help或者route命令获取帮助 </p><p><a href="https://imgse.com/i/pkr05VI"><img src="https://s21.ax1x.com/2024/06/23/pkr05VI.png" alt="pkr05VI.png"></a></p><h5 id="2、查看路由表"><a href="#2、查看路由表" class="headerlink" title="2、查看路由表"></a>2、查看路由表</h5><p>route print命令查看主机路由表，可以使用route print -4查看ipv4 路由表。 </p><p><a href="https://imgse.com/i/pkr0hqA"><img src="https://s21.ax1x.com/2024/06/23/pkr0hqA.png" alt="pkr0hqA.png"></a></p><h5 id="3、显示某网段路由"><a href="#3、显示某网段路由" class="headerlink" title="3、显示某网段路由"></a>3、显示某网段路由</h5><p>route print 192.168.3*显示192.168.3开头的路由段 </p><p><a href="https://imgse.com/i/pkr0frd"><img src="https://s21.ax1x.com/2024/06/23/pkr0frd.png" alt="pkr0frd.png"></a></p><h5 id="4、添加一条静态路由"><a href="#4、添加一条静态路由" class="headerlink" title="4、添加一条静态路由"></a>4、添加一条静态路由</h5><p>route add添加一条路由，此操作需要使用administrator管理员权限。 </p><p><a href="https://imgse.com/i/pkr02xe"><img src="https://s21.ax1x.com/2024/06/23/pkr02xe.png" alt="pkr02xe.png"></a></p><h5 id="5、修改一条路由"><a href="#5、修改一条路由" class="headerlink" title="5、修改一条路由"></a>5、修改一条路由</h5><p>route change修改路由网关或者跃点数。 </p><p><a href="https://imgse.com/i/pkr0WKH"><img src="https://s21.ax1x.com/2024/06/23/pkr0WKH.png" alt="pkr0WKH.png"></a></p><h5 id="6、删除一条路由"><a href="#6、删除一条路由" class="headerlink" title="6、删除一条路由"></a>6、删除一条路由</h5><p>route delete删除一条路由 </p><p><a href="https://imgse.com/i/pkr0Iat"><img src="https://s21.ax1x.com/2024/06/23/pkr0Iat.png" alt="pkr0Iat.png"></a></p><h5 id="7、永久添加一条路由"><a href="#7、永久添加一条路由" class="headerlink" title="7、永久添加一条路由"></a>7、永久添加一条路由</h5><p>route add ipnet mask x.x.x.0 gateway -p添加永久路由 </p><p><a href="https://imgse.com/i/pkr0oIP"><img src="https://s21.ax1x.com/2024/06/23/pkr0oIP.png" alt="pkr0oIP.png"></a></p><p><em><strong>使用语法及参数说明</strong></em></p><h5 id="1、使用语法"><a href="#1、使用语法" class="headerlink" title="1、使用语法"></a>1、使用语法</h5><blockquote><p> 用法：ROUTE [-f] [-p] [-4|-6] command [destination] [MASK netmask] [gateway] [METRIC metric] [IF interface] </p></blockquote><h5 id="2、参数说明"><a href="#2、参数说明" class="headerlink" title="2、参数说明"></a>2、参数说明</h5><table><thead><tr><th align="left">参数</th><th align="left">参数说明</th></tr></thead><tbody><tr><td align="left">-f</td><td align="left">清除所有网关项的路由表。如果与某个命令结合使用，在运行该命令前，应清除路由表。</td></tr><tr><td align="left">-p</td><td align="left">与 ADD 命令结合使用时，将路由设置为在系统引导期间保持不变。默认情况下，重新启动系统时，不保存路由。忽略所有其他命令，这始终会影响相应的永久路由。Windows 95不支持此选项。</td></tr><tr><td align="left">-4</td><td align="left">强制使用 IPv4。</td></tr><tr><td align="left">-6</td><td align="left">强制使用 IPv6。</td></tr><tr><td align="left">command</td><td align="left">其中之一: PRINT 打印路由  ADD 添加路由  DELETE 删除路由  CHANGE 修改现有路由</td></tr><tr><td align="left">destination</td><td align="left">指定主机。</td></tr><tr><td align="left">MASK</td><td align="left">指定下一个参数为“网络掩码”值。</td></tr><tr><td align="left">netmask</td><td align="left">指定此路由项的子网掩码值。如果未指定，其默认设置为 255.255.255.255。</td></tr><tr><td align="left">gateway</td><td align="left">指定网关。</td></tr><tr><td align="left">interface</td><td align="left">指定路由的接口号码。</td></tr><tr><td align="left">METRIC</td><td align="left">指定跃点数，例如目标的成本。</td></tr></tbody></table><hr><p><em><strong>实例</strong></em></p><p>需求描述：<br>    1. Win10, 网卡1接外网，网卡2接内网，只能Ping通外网无法Ping通内网。<br>        如果禁用网卡1(外网)，即可Ping通网卡2（内网）</p><ol start="2"><li>备注：<br>① 这里的网卡对有线网卡或无线网卡都适用；<br>②Win10版本 64位1909;<br>③WIN7可以在“网络和共享中心”——“更改适配器设置”——“网络设置中界面中，按ALT键”调出隐藏菜单栏——在选项“高级-高级设置”中，可以手动调整网卡优先级。<br>But，Win10不可以，取消了，只能通过修改接口跃点数实现（不建议）。</li><li>解决方法：静态路由——只针对有限数量的IP<br>Eg. 网卡1网段192.168.20，网卡2网段10.19.20，只能Ping通网段1,需要和网段2的IP（11.20.203.5）建立通讯，那就在CMD命令中增加一个路由：<br>route -p add 11.20.203.5(目标IP) mask 255.255.255.0(子网掩码) 192.168.20.254（网关）<br>注意：以管理员运行CMD，运行完提示完成后，必须重启。</li></ol><p><a href="https://javaforall.cn/161116.html">https://javaforall.cn/161116.html</a></p><p>原文链接：<a href="https://javaforall.cn/">https://javaforall.cn</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;[南月晨的blog](&lt;a href=&quot;https://leiyu-code.github.io/&quot;&gt;南月晨的博客 (leiyu-code.github.io)&lt;/a&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;leiyu-code.github.io&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.linuxcool.com/&quot;&gt;Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;route命令&quot;&gt;&lt;a href=&quot;#route命令&quot; class=&quot;headerlink&quot; title=&quot;route命令&quot;&gt;&lt;/a&gt;&lt;em&gt;&lt;strong&gt;route命令&lt;/strong&gt;&lt;/em&gt;&lt;/h4&gt;&lt;p&gt;  route命令用于显示和操作IP路由表。要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者同时位于两个网络的网关来实现。windows环境下route命令常用于多网卡终端，默认路由指向连接访问互联网的网卡，静态路由指向内网网卡。&lt;/p&gt;</summary>
    
    
    
    <category term="windows" scheme="http://example.com/categories/windows/"/>
    
    
    <category term="cmd" scheme="http://example.com/tags/cmd/"/>
    
    <category term="route" scheme="http://example.com/tags/route/"/>
    
  </entry>
  
  <entry>
    <title>服务器安全批处理</title>
    <link href="http://example.com/2024/06/23/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E6%89%B9%E5%A4%84%E7%90%86/"/>
    <id>http://example.com/2024/06/23/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E6%89%B9%E5%A4%84%E7%90%86/</id>
    <published>2024-06-23T02:28:06.000Z</published>
    <updated>2024-06-23T02:38:16.193Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p><p><a href="http://leiyu-code.github.io">leiyu-code.github.io</a></p><p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p><p><em><strong>用法：</strong></em></p><p>桌面新建文本文件</p><p>将下列代码粘贴到文件文件，并且改文件名称后缀txt为bat，双击运行</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@<span class="built_in">ECHO</span> OFF </span><br><span class="line"><span class="built_in">CLS</span> </span><br><span class="line"><span class="built_in">TITLE</span> SERVER SAFE SETUP PRO </span><br><span class="line"><span class="built_in">COLOR</span> <span class="number">0</span>A </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe C:\ /p Administrators:f system:f &quot;network service&quot;:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe D:\ /p Administrators:f system:f servU:f &quot;network service&quot;:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe E:\ /p Administrators:f system:f servU:f &quot;network service&quot;:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe &quot;C:\Program Files&quot; /t /p Administrators:f system:f everyone:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe &quot;C:\Program Files\Common Files&quot; /t /g Administrators:f system:f everyone:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows /p Administrators:f system:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32 /p Administrators:f system:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe C:\WINDOWS\system32\inetsrv /p Administrators:f system:f everyone:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe &quot;C:\Documents and Settings&quot; /p Administrators:f system:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe &quot;C:\Documents and Settings\All Users&quot; /t /p Administrator:f system:f everyone:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\temp /p everyone:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe <span class="variable">%systemroot%</span>\system32\shell32.dll /p Administrators:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe <span class="variable">%systemroot%</span>\system32\wshom.ocx /p Administrators:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32\*.exe /p Administrators:f system:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe &quot;c:\Documents and Settings\All Users&quot; /e /g everyone:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe <span class="variable">%systemroot%</span>\system32\svchost.exe /e /g &quot;network service&quot;:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe <span class="variable">%systemroot%</span>\system32\msdtc.exe /e /g &quot;network service&quot;:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe <span class="variable">%windir%</span>\system32\mtxex.dll /e /g everyone:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32\<span class="built_in">cmd</span>.exe /p Administrator:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32\<span class="built_in">net</span>.exe /p Administrator:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32\net1.exe /p Administrator:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32\sc.exe /p Administrator:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32\<span class="built_in">at</span>.exe /p Administrator:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe <span class="variable">%windir%</span>\system32\dllhost.exe /e /g everyone:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32\netsh.exe /p Administrator:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32\<span class="built_in">net</span>.exe /p Administrator:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32\<span class="built_in">cacls</span>.exe /p Administrator:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32\cmdkey.exe /p Administrator:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32\ftp.exe /p Administrator:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32\tftp.exe /p Administrator:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32\reg.exe /p Administrator:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32\regedt32.exe /p Administrator:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32\regini.exe /p Administrator:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe <span class="variable">%windir%</span>\assembly /e /t /g &quot;network service&quot;:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe <span class="variable">%windir%</span>\Microsoft.<span class="built_in">NET</span> /e /t /g everyone:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe &quot;<span class="variable">%windir%</span>\Microsoft.<span class="built_in">NET</span>\Framework\v1.<span class="number">1</span>.<span class="number">4322</span>\Temporary ASP.<span class="built_in">NET</span> Files&quot; /e /t /g everyone:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe <span class="variable">%windir%</span>\system32\mscoree.dll /e /g everyone:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe <span class="variable">%windir%</span>\system32\ws03res.dll /e /g everyone:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe <span class="variable">%windir%</span>\system32\msxml*.dll /e /g everyone:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe C:\WINDOWS\system32\urlmon.dll /e /g everyone:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe C:\WINDOWS\system32\mlang.dll /e /g everyone:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe C:\WINDOWS\system32\TAPI32.dll /e /g everyone:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe C:\WINDOWS\system32\WININET.dll /e /g everyone:r </span><br><span class="line"><span class="built_in">cacls</span> c:\windows\assembly /e /t /p &quot;network service&quot;:r </span><br><span class="line"><span class="built_in">cacls</span> c:\windows\Microsoft.<span class="built_in">NET</span> /e /t /p &quot;network service&quot;:r </span><br><span class="line"><span class="built_in">cacls</span> &quot;C:\WINDOWS\Microsoft.<span class="built_in">NET</span>\Framework\v1.<span class="number">1</span>.<span class="number">4322</span>\Temporary ASP.<span class="built_in">NET</span> Files&quot; /e /t /p &quot;network service&quot;:f </span><br><span class="line"><span class="built_in">cacls</span> C:\WINDOWS\system32\mscoree.dll /e /g everyone:r </span><br><span class="line"><span class="built_in">cacls</span> C:\WINDOWS\system32\ws03res.dll /e /g everyone:r </span><br><span class="line"><span class="built_in">cacls</span> c:\WINDOWS /e /g &quot;network service&quot;:r </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">exist</span> c:\windows <span class="built_in">cacls</span> c:\windows /e /g &quot;network service&quot;:r </span><br><span class="line"><span class="built_in">cacls</span> c:\windows\Microsoft.<span class="built_in">NET</span> /e /t /p &quot;network service&quot;:r </span><br><span class="line"><span class="built_in">cacls</span> &quot;C:\WINDOWS\Microsoft.<span class="built_in">NET</span>\Framework\v1.<span class="number">1</span>.<span class="number">4322</span>\Temporary ASP.<span class="built_in">NET</span> Files&quot; /e /t /p &quot;network service&quot;:f </span><br><span class="line"><span class="built_in">cacls</span> &quot;C:\WINDOWS\Microsoft.<span class="built_in">NET</span>\Framework\v2.<span class="number">0</span>.<span class="number">50727</span>\Temporary ASP.<span class="built_in">NET</span> Files&quot; /e /t /p &quot;network service&quot;:f </span><br><span class="line"><span class="built_in">cacls</span> c:\windows\system32 /e /g &quot;network service&quot;:r </span><br><span class="line"><span class="built_in">cacls</span> c:\windows\system32\rasapi32.dll /e /g &quot;network service&quot;:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe C:\WINDOWS\system32\inetsrv\adsiis.dll /p Administrators:f autosystem:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe C:\WINDOWS\system32\inetsrv\iisadmpwd /p Administrators:f autosystem:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe C:\WINDOWS\system32\inetsrv\MetaBack /p Administrators:f autosystem:f </span><br><span class="line"><span class="built_in">cacls</span> C&quot;:\Program Files\Serv-U&quot; /e /g &quot;servu&quot;:f </span><br><span class="line"><span class="built_in">cacls</span> d:\wwwroot /e /g servU:f </span><br><span class="line"><span class="built_in">echo</span> 以上设置服务器目录权限 </span><br><span class="line"></span><br><span class="line"><span class="built_in">net</span> stop Browser </span><br><span class="line">sc config Browser <span class="built_in">start</span>= disabled </span><br><span class="line"><span class="built_in">net</span> stop lanmanserver </span><br><span class="line">sc config lanmanserver <span class="built_in">start</span>= disabled </span><br><span class="line"><span class="built_in">net</span> share c$ /delete </span><br><span class="line"><span class="built_in">net</span> share d$ /delete </span><br><span class="line"><span class="built_in">net</span> share e$ /delete </span><br><span class="line"><span class="built_in">net</span> share f$ /delete </span><br><span class="line"><span class="built_in">net</span> share admin$ /delete </span><br><span class="line"><span class="built_in">net</span> share ipc$ /delete </span><br><span class="line"><span class="built_in">echo</span> 以上删除默认共享，设置服务项 </span><br><span class="line"><span class="built_in">echo</span> .. delshare.reg ....... </span><br><span class="line"><span class="built_in">echo</span> Windows Registry Editor Version <span class="number">5</span>.<span class="number">00</span>&gt; c:\delshare.reg </span><br><span class="line"><span class="built_in">echo</span> [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\lanmanserver\parameters]&gt;&gt; c:\delshare.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;AutoShareWks&quot;=dword:<span class="number">00000000</span>&gt;&gt; c:\delshare.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;AutoShareServer&quot;=dword:<span class="number">00000000</span>&gt;&gt; c:\delshare.reg </span><br><span class="line"><span class="built_in">echo</span> .. delshare.reg ..... </span><br><span class="line">regedit /s c:\delshare.reg </span><br><span class="line"><span class="built_in">echo</span> .. delshare.reg .... </span><br><span class="line"><span class="built_in">del</span> c:\delshare.reg </span><br><span class="line"><span class="built_in">echo</span> . </span><br><span class="line"><span class="built_in">echo</span> ........ </span><br><span class="line"><span class="built_in">echo</span> . </span><br><span class="line"><span class="built_in">echo</span> ========================================================= </span><br><span class="line"><span class="built_in">echo</span> . </span><br><span class="line"><span class="built_in">echo</span> .....................dos.... </span><br><span class="line"><span class="built_in">echo</span> . </span><br><span class="line"><span class="built_in">echo</span> ......... </span><br><span class="line"><span class="built_in">echo</span> Windows Registry Editor Version <span class="number">5</span>.<span class="number">00</span>&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters]&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;EnableICMPRedirect&quot;=dword:<span class="number">00000000</span>&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;DeadGWDetectDefault&quot;=dword:<span class="number">00000001</span>&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;DontAddDefaultGatewayDefault&quot;=dword:<span class="number">00000000</span>&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;EnableSecurityFilters&quot;=dword:<span class="number">00000000</span>&quot;&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;AllowUnqualifiedQuery&quot;=dword:<span class="number">00000000</span>&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;PrioritizeRecordData&quot;=dword:<span class="number">00000001</span>&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;ReservedPorts&quot;=hex(<span class="number">7</span>):<span class="number">31</span>,<span class="number">00</span>,<span class="number">34</span>,<span class="number">00</span>,<span class="number">33</span>,<span class="number">00</span>,<span class="number">33</span>,<span class="number">00</span>,<span class="number">2</span>d,<span class="number">00</span>,<span class="number">31</span>,<span class="number">00</span>,<span class="number">34</span>,<span class="number">00</span>,<span class="number">33</span>,<span class="number">00</span>,<span class="number">34</span>,<span class="number">00</span>,\&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> <span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;SynAttackProtect&quot;=dword:<span class="number">00000002</span>&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;EnablePMTUDiscovery&quot;=dword:<span class="number">00000000</span>&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;NoNameReleaseOnDemand&quot;=dword:<span class="number">00000001</span>&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;EnableDeadGWDetect&quot;=dword:<span class="number">00000000</span>&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;KeepAliveTime&quot;=dword:<span class="number">00300000</span>&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;PerformRouterDiscovery&quot;=dword:<span class="number">00000000</span>&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;EnableICMPRedirects&quot;=dword:<span class="number">00000000</span>&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> . </span><br><span class="line"><span class="built_in">echo</span> ========================================================== </span><br><span class="line"><span class="built_in">echo</span> .. dosforwin.reg ..... </span><br><span class="line">regedit /s c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> .. dosforwin.reg .... </span><br><span class="line"><span class="built_in">del</span> c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> ============================================================== </span><br><span class="line"><span class="built_in">echo</span> . </span><br><span class="line"><span class="built_in">echo</span> =============================================================== </span><br><span class="line"><span class="built_in">echo</span> ..Remote Registry Service........... </span><br><span class="line"><span class="built_in">echo</span> ......... </span><br><span class="line"><span class="built_in">echo</span> . </span><br><span class="line"><span class="built_in">echo</span> Windows Registry Editor Version <span class="number">5</span>.<span class="number">00</span>&gt; c:\regedit.reg </span><br><span class="line"><span class="built_in">echo</span> [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\RemoteRegistry]&gt;&gt; c:\regedit.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;<span class="built_in">Start</span>&quot;=dword:<span class="number">00000004</span>&gt;&gt; c:\regedit.reg </span><br><span class="line"><span class="built_in">echo</span> . </span><br><span class="line"><span class="built_in">echo</span> .. regedit.reg ..... </span><br><span class="line">regedit /s c:\regedit.reg </span><br><span class="line"><span class="built_in">echo</span> . </span><br><span class="line"><span class="built_in">echo</span> ...... </span><br><span class="line"><span class="built_in">del</span> c:\regedit.reg </span><br><span class="line"><span class="built_in">echo</span> =============================================================== </span><br><span class="line"><span class="built_in">echo</span> ..Messenger....... </span><br><span class="line"><span class="built_in">echo</span> ......... </span><br><span class="line"><span class="built_in">echo</span> Windows Registry Editor Version <span class="number">5</span>.<span class="number">00</span>&gt; c:\message.reg </span><br><span class="line"><span class="built_in">echo</span> [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Messenger]&gt;&gt; c:\message.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;<span class="built_in">Start</span>&quot;=dword:<span class="number">00000004</span>&gt;&gt; c:\message.reg </span><br><span class="line"><span class="built_in">echo</span> . </span><br><span class="line"><span class="built_in">echo</span> .. message.reg ..... </span><br><span class="line">regedit /s c:\message.reg </span><br><span class="line"><span class="built_in">echo</span> . </span><br><span class="line"><span class="built_in">echo</span> .. message.reg </span><br><span class="line"><span class="built_in">del</span> c:\message.reg </span><br><span class="line"><span class="built_in">echo</span> =============================================================== </span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> =============================================================== </span><br><span class="line"><span class="built_in">echo</span> ..lanmanserver....... </span><br><span class="line"><span class="built_in">echo</span> ......... </span><br><span class="line"><span class="built_in">echo</span> Windows Registry Editor Version <span class="number">5</span>.<span class="number">00</span>&gt; c:\lanmanserver.reg </span><br><span class="line"><span class="built_in">echo</span> [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\lanmanserver]&gt;&gt; c:\lanmanserver.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;<span class="built_in">Start</span>&quot;=dword:<span class="number">00000004</span>&gt;&gt; c:\lanmanserver.reg </span><br><span class="line"><span class="built_in">echo</span> . </span><br><span class="line"><span class="built_in">echo</span> .. lanmanserver.reg ..... </span><br><span class="line">regedit /s c:\lanmanserver.reg </span><br><span class="line"><span class="built_in">echo</span> . </span><br><span class="line"><span class="built_in">echo</span> .. lanmanserver.reg </span><br><span class="line"><span class="built_in">del</span> c:\lanmanserver.reg </span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> ============================================================== </span><br><span class="line"><span class="built_in">echo</span> ...TCP/IP NetBIOS Helper Service </span><br><span class="line"><span class="built_in">echo</span> ......... </span><br><span class="line"><span class="built_in">echo</span> Windows Registry Editor Version <span class="number">5</span>.<span class="number">00</span>&gt; c:\netbios.reg </span><br><span class="line"><span class="built_in">echo</span> [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\LmHosts]&gt;&gt; c:\netbios.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;<span class="built_in">Start</span>&quot;=dword:<span class="number">00000004</span>&gt;&gt; c:\netbios.reg </span><br><span class="line"><span class="built_in">echo</span> . </span><br><span class="line"><span class="built_in">echo</span> .. netbios.reg ..... </span><br><span class="line">regedit /s c:\netbios.reg </span><br><span class="line"><span class="built_in">echo</span> . </span><br><span class="line"><span class="built_in">echo</span> .. netbios.reg </span><br><span class="line"><span class="built_in">del</span> c:\netbios.reg </span><br><span class="line">regedit /s forddos.reg </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;[南月晨的blog](&lt;a href=&quot;https://leiyu-code.github.io/&quot;&gt;南月晨的博客 (leiyu-code.github.io)&lt;/a&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://leiyu-code.</summary>
      
    
    
    
    <category term="server" scheme="http://example.com/categories/server/"/>
    
    
    <category term="safe" scheme="http://example.com/tags/safe/"/>
    
    <category term="bat" scheme="http://example.com/tags/bat/"/>
    
  </entry>
  
  <entry>
    <title>美食推荐——蒸鸡蛋糕</title>
    <link href="http://example.com/2024/06/21/%E7%BE%8E%E9%A3%9F%E6%8E%A8%E8%8D%90%E2%80%94%E2%80%94%E8%92%B8%E9%B8%A1%E8%9B%8B%E7%B3%95/"/>
    <id>http://example.com/2024/06/21/%E7%BE%8E%E9%A3%9F%E6%8E%A8%E8%8D%90%E2%80%94%E2%80%94%E8%92%B8%E9%B8%A1%E8%9B%8B%E7%B3%95/</id>
    <published>2024-06-21T12:28:06.000Z</published>
    <updated>2024-06-21T09:28:31.162Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p><p>leiyu-code.github.io</p><p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p><p><strong>问题：做蒸鸡蛋糕总是里边有孔洞</strong></p><p><a href="https://imgse.com/i/pkD2R10"><img src="https://s21.ax1x.com/2024/06/21/pkD2R10.png" alt="pkD2R10.png"></a></p><span id="more"></span><p>原料：鸡蛋、食盐、香油</p><p>制作步骤：</p><p>1、两个鸡蛋敲小碗里。</p><p>2、另一个小碗中加入与蛋液差不多量的清水。水对蛋液比例1：1到1：1.5之间均可。清水用温水好些，在水中加入食盐，搅拌均匀，使之充分溶解。食盐也可在后续搅蛋液的时候放，为了能更均匀所以先放清水里了。</p><p>3、把食盐水和蛋液混合，搅拌，至蛋液完全搅散。（这时候表面会有很多气泡，这样直接蒸的话里边的气泡就是孔洞的成因。）</p><p>4、现在<strong>进行消除气泡的工艺——过筛</strong>。用细筛网过一遍蛋液，气泡都留在筛网上了。过完筛的蛋液再去除表面少量的气泡，就可以了。</p><p>5、加入适量的香油。加香油蒸出来的鸡蛋糕是金黄的，很漂亮。没有香油加其他植物油也可，颜色上可能差些，但不耽误好吃。</p><p>6、上蒸锅，<strong>至关重要的第二道工艺来了——扣盘子。这样可以避免蒸的过程中蛋液起泡。</strong>（如果盛蛋液的容器口过大，用保鲜膜覆盖也可，效果是一样的。只是比扣盘子麻烦些，我试过。）</p><p>7、盖上锅盖，大火把水烧开。用中火，蒸12分钟即可。（蒸的过程中什么也不用管，例如开盖放气之类的，这些都已经被扣盘子的工艺解决了。）</p><p><a href="https://imgse.com/i/pkD22pq"><img src="https://s21.ax1x.com/2024/06/21/pkD22pq.png" alt="pkD22pq.png"></a></p><hr><p><strong>总结：</strong> <em><strong>过筛，是为了消气泡；</strong></em></p><p>​            <em><strong>扣盘子，是为了蒸制过程蛋液表面平整。</strong></em>这两个步骤很有用哦，其余就可自由发挥了，加些葱花、虾皮之类的也不错，全凭个人喜好～</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;[南月晨的blog](&lt;a href=&quot;https://leiyu-code.github.io/&quot;&gt;南月晨的博客 (leiyu-code.github.io)&lt;/a&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;leiyu-code.github.io&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.linuxcool.com/&quot;&gt;Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题：做蒸鸡蛋糕总是里边有孔洞&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://imgse.com/i/pkD2R10&quot;&gt;&lt;img src=&quot;https://s21.ax1x.com/2024/06/21/pkD2R10.png&quot; alt=&quot;pkD2R10.png&quot;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="food" scheme="http://example.com/categories/food/"/>
    
    
    <category term="eggcake" scheme="http://example.com/tags/eggcake/"/>
    
  </entry>
  
  <entry>
    <title>佳软推荐——最好用的PDF虚拟打印机CutePDF Writer</title>
    <link href="http://example.com/2024/06/21/%E4%BD%B3%E8%BD%AF%E6%8E%A8%E8%8D%90%E2%80%94%E2%80%94%E6%9C%80%E5%A5%BD%E7%94%A8%E7%9A%84PDF%E8%99%9A%E6%8B%9F%E6%89%93%E5%8D%B0%E6%9C%BACutePDF%20Writer/"/>
    <id>http://example.com/2024/06/21/%E4%BD%B3%E8%BD%AF%E6%8E%A8%E8%8D%90%E2%80%94%E2%80%94%E6%9C%80%E5%A5%BD%E7%94%A8%E7%9A%84PDF%E8%99%9A%E6%8B%9F%E6%89%93%E5%8D%B0%E6%9C%BACutePDF%20Writer/</id>
    <published>2024-06-21T11:28:06.000Z</published>
    <updated>2024-06-21T08:45:25.765Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p><p>leiyu-code.github.io</p><p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p><p>CutePDF Writer是 Acro Software公司出品的免费PDF虚拟打印机，支持 win98-win7，支持32位&#x2F;64位。<br><strong>软件优点：</strong>经典、稳定、持续但绝不频繁地升级；完美支持中文、字体美观。CutePDF Writer 是我使用时间跨度最长、纯使用时间最长的PDF虚拟打印机。<br>它也需要PS2PDF的转换器，当然，推荐的转换器依然是Ghostscript。并且，官方提供了一个专门制作的 GPLGS8.15 Converter，与 CutePDF Writer配合使用。相比自己下载的版本，它体积更小，并且兼容性更有保证。<br>完全免费，可以用于商业用途。（FREE for commercial and non-commercial use!）无水印。无弹出广告。</p><p><a href="https://imgse.com/i/pkDcl36"><img src="https://s21.ax1x.com/2024/06/21/pkDcl36.png" alt="pkDcl36.png"></a></p><span id="more"></span><p><em><strong>CutePDF Writer的安装：</strong></em></p><p>下载 <a href="http://download.cutepdf.com/download/CuteWriter.zip">zip安装包</a>（8MB），内含2个文件。<br>　　　- 先运行其中的 converter.exe （5MB），安装转换器。安装过程基本不需要任何干预。<br>　　　- 再运行其中的 CuteWriter.exe （3MB），安装PDF Writer。注意：安装过程<strong>有Ask Toobar推广广告，可以选择不安装</strong>（视频第50秒开始）。<br>　　　- 然后，就可以在任意程序的“打印”菜单中，选择CutePDF Writer，把文档打印为pdf了。</p><p><a href="https://imgse.com/i/pkDc3jO"><img src="https://s21.ax1x.com/2024/06/21/pkDc3jO.png" alt="pkDc3jO.png"></a></p><p><a href="https://imgse.com/i/pkDc1gK"><img src="https://s21.ax1x.com/2024/06/21/pkDc1gK.png" alt="pkDc1gK.png"></a></p><hr><p><strong>总结：最好用的pdf打印机CutePDF Writer，别的pdf打印机打出来乱码、格式不对的时候下来试试吧！</strong></p><p>​           <em><strong>WPS也自己带有pdf打印机，安装后就可以直接使用</strong></em></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;[南月晨的blog](&lt;a href=&quot;https://leiyu-code.github.io/&quot;&gt;南月晨的博客 (leiyu-code.github.io)&lt;/a&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;leiyu-code.github.io&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.linuxcool.com/&quot;&gt;Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CutePDF Writer是 Acro Software公司出品的免费PDF虚拟打印机，支持 win98-win7，支持32位&amp;#x2F;64位。&lt;br&gt;&lt;strong&gt;软件优点：&lt;/strong&gt;经典、稳定、持续但绝不频繁地升级；完美支持中文、字体美观。CutePDF Writer 是我使用时间跨度最长、纯使用时间最长的PDF虚拟打印机。&lt;br&gt;它也需要PS2PDF的转换器，当然，推荐的转换器依然是Ghostscript。并且，官方提供了一个专门制作的 GPLGS8.15 Converter，与 CutePDF Writer配合使用。相比自己下载的版本，它体积更小，并且兼容性更有保证。&lt;br&gt;完全免费，可以用于商业用途。（FREE for commercial and non-commercial use!）无水印。无弹出广告。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://imgse.com/i/pkDcl36&quot;&gt;&lt;img src=&quot;https://s21.ax1x.com/2024/06/21/pkDcl36.png&quot; alt=&quot;pkDcl36.png&quot;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="software" scheme="http://example.com/categories/software/"/>
    
    
    <category term="print" scheme="http://example.com/tags/print/"/>
    
    <category term="pdf" scheme="http://example.com/tags/pdf/"/>
    
  </entry>
  
  <entry>
    <title>com+错误代码8007042c-依赖服务或组无法启动</title>
    <link href="http://example.com/2024/06/21/com+%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%818007042c-%E4%BE%9D%E8%B5%96%E6%9C%8D%E5%8A%A1%E6%88%96%E7%BB%84%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8/"/>
    <id>http://example.com/2024/06/21/com+%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%818007042c-%E4%BE%9D%E8%B5%96%E6%9C%8D%E5%8A%A1%E6%88%96%E7%BB%84%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8/</id>
    <published>2024-06-21T06:39:06.000Z</published>
    <updated>2024-06-21T07:01:25.005Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p><p>leiyu-code.github.io</p><p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p><p><em><strong>com+错误代码8007042c-依赖服务或组无法启动</strong></em></p><p><a href="https://imgse.com/i/pkDwpDI"><img src="https://s21.ax1x.com/2024/06/21/pkDwpDI.png" alt="pkDwpDI.png"></a></p><span id="more"></span><p><em><strong>解决方法：</strong></em></p><ol><li><p>查看系统日志，发现与 COM+ System Application 服务相依的服务因下列错误system Event Notification Senice而无法启动:无法启动服务，原因可能是已被禁用或与其相关联的设备没有启动。</p></li><li><p>进入控制面板里的卸载或更改程序和功能，点击打开或关闭windows功能,勾选system Event Notification Senice，安装windows相关功能。</p><p><a href="https://imgse.com/i/pkDwPVP"><img src="https://s21.ax1x.com/2024/06/21/pkDwPVP.png" alt="pkDwPVP.png"></a></p><p><a href="https://imgse.com/i/pkDwSKA"><img src="https://s21.ax1x.com/2024/06/21/pkDwSKA.png" alt="pkDwSKA.png"></a></p><p><a href="https://imgse.com/i/pkDw9bt"><img src="https://s21.ax1x.com/2024/06/21/pkDw9bt.png" alt="pkDw9bt.png"></a></p></li><li><p>打开com+和dtc相关的服务。</p><p><a href="https://imgse.com/i/pkDBTDs"><img src="https://s21.ax1x.com/2024/06/21/pkDBTDs.png" alt="pkDBTDs.png"></a></p><p><a href="https://imgse.com/i/pkDBouj"><img src="https://s21.ax1x.com/2024/06/21/pkDBouj.png" alt="pkDBouj.png"></a></p></li></ol><hr><p><strong>总结：widows系统报错，先查看系统日志，应用程序日志，查看错误原因，无法启动服务就安装相应的windows功能，启动相应的服务，并将有关联的服务改成自动启动。</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;[南月晨的blog](&lt;a href=&quot;https://leiyu-code.github.io/&quot;&gt;南月晨的博客 (leiyu-code.github.io)&lt;/a&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;leiyu-code.github.io&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.linuxcool.com/&quot;&gt;Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;com+错误代码8007042c-依赖服务或组无法启动&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://imgse.com/i/pkDwpDI&quot;&gt;&lt;img src=&quot;https://s21.ax1x.com/2024/06/21/pkDwpDI.png&quot; alt=&quot;pkDwpDI.png&quot;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="workNote" scheme="http://example.com/categories/workNote/"/>
    
    
    <category term="windows" scheme="http://example.com/tags/windows/"/>
    
    <category term="wrong" scheme="http://example.com/tags/wrong/"/>
    
  </entry>
  
  <entry>
    <title>服务器安全配置基本设置</title>
    <link href="http://example.com/2024/06/21/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2024/06/21/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/</id>
    <published>2024-06-21T02:47:06.000Z</published>
    <updated>2024-06-23T03:12:49.952Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p><p>leiyu-code.github.io</p><p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p><p>对windows服务器进行以下的设置和相关策略的制定，可以有效的增加服务器的自身防御能力，防止黑客利用常见的攻击手段和方法对服务器进行入侵和破坏，降低数据被盗取的风险。</p><p><em><strong>gpedit.msc  组策略编辑器</strong></em></p><p><em><strong>regedit  注册表编辑器</strong></em></p><p><em><strong>services.msc  计算机服务</strong></em></p><p><em><strong>msconfig  系统配置</strong></em></p><p><em><strong>firewall.cpl  防火墙</strong></em></p><span id="more"></span><p><em><strong>计算机安全策略配置：</strong></em></p><p><strong>(一) 修改远程桌面端口</strong></p><p>将默认端口3389修改为XXX。</p><p><strong>(二) 帐户</strong></p><p>对系统管理员默认帐户administrator进行重命名，停用guest用户。</p><p><strong>(三) 开启windows防火墙</strong></p><p>  取消网络连接中的文件和打印共享。</p><p>  在例外里面添加远程桌面端口XXX。</p><p>  在防火墙高级设置时勾选Web服务和安全的Web服务。</p><p>  在防火墙开放FTP端口XX。</p><p>  开放短信发送平台端口：XXX</p><p><strong>(四) 禁用无关服务</strong></p><p>  Printspooler 打印服务</p><p>  Wirelessconfiguration 无线服务</p><p>  RoutingandRemoteAccess在局域网以及广域网环境中为企业提供路由服务。</p><p>  NTLMSecuritysupportprovide：telnet服务和MicrosoftSerch服务使用。</p><p>  Telnet允许远程用户登录到此计算机并运行程序。</p><p>  RemoteDesktopHelpSessionManager：远程协助服务。</p><p>  ErrorReportingService收集、存储和向Microsoft报告异常应用程序。</p><p>  RemoteRegistry 远程注册表操作。</p><p><strong>(五) 禁止IPC空连接</strong></p><p>打开注册表找到Local_Machine\System\CurrentControlSet\Control\LSA-RestrictAnonymous把这个值改成”1”即可。</p><p><strong>(六) 删除默认共享</strong></p><p>打开注册表找到HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters，新建AutoShareServer类型是REG_DWORD把值改为0。</p><p><strong>(七) 策略配置</strong></p><p>组策略配置:gpedit—&gt;计算机配置—&gt;windows设置—&gt;安全设置—&gt;本地策略。</p><p>在用户权利分配下，从通过网络访问此计算机中删除PowerUsers和BackupOperators;</p><p>启用不允许匿名访问SAM帐号和共享;</p><p>启用不允许为网络验证存储凭据或Passport;</p><p>从文件共享中删除允许匿名登录的DFS$和COMCFG;</p><p>启用交互登录：不显示上次的用户名;</p><p>启用在下一次密码变更时不存储LANMAN哈希值;</p><p>禁止IIS匿名用户在本地登录。</p><hr><p><strong>总结：</strong> 打开windows防火墙、windows更新，并进行简单的配置也能在最大的程度上防止黑客的入侵</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;[南月晨的blog](&lt;a href=&quot;https://leiyu-code.github.io/&quot;&gt;南月晨的博客 (leiyu-code.github.io)&lt;/a&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;leiyu-code.github.io&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.linuxcool.com/&quot;&gt;Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对windows服务器进行以下的设置和相关策略的制定，可以有效的增加服务器的自身防御能力，防止黑客利用常见的攻击手段和方法对服务器进行入侵和破坏，降低数据被盗取的风险。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;gpedit.msc  组策略编辑器&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;regedit  注册表编辑器&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;services.msc  计算机服务&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;msconfig  系统配置&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;firewall.cpl  防火墙&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="server" scheme="http://example.com/categories/server/"/>
    
    
    <category term="safe" scheme="http://example.com/tags/safe/"/>
    
  </entry>
  
  <entry>
    <title>斑马Zebra条码打印机软件和驱动须知</title>
    <link href="http://example.com/2024/06/20/%E6%96%91%E9%A9%ACZebra%E6%9D%A1%E7%A0%81%E6%89%93%E5%8D%B0%E6%9C%BA%E8%BD%AF%E4%BB%B6%E5%92%8C%E9%A9%B1%E5%8A%A8%E9%A1%BB%E7%9F%A5/"/>
    <id>http://example.com/2024/06/20/%E6%96%91%E9%A9%ACZebra%E6%9D%A1%E7%A0%81%E6%89%93%E5%8D%B0%E6%9C%BA%E8%BD%AF%E4%BB%B6%E5%92%8C%E9%A9%B1%E5%8A%A8%E9%A1%BB%E7%9F%A5/</id>
    <published>2024-06-20T08:28:06.000Z</published>
    <updated>2024-06-21T03:01:15.605Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p><p>leiyu-code.github.io</p><p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p><p><em><strong>条码打印机须知</strong></em></p><p>1、888T的打印方式是热敏&#x2F;热转印；</p><p>​      888D的打印方式是热敏</p><p>2、热敏打印和热转印是条码机的两种打印方式。</p><p>虽然每种方法都使用热敏打印头对打印表面加热。 </p><p>热转印是通过加热色带，在多种材料上打印出耐用、持久的图案。</p><p>热敏打印不使用色带，而是直接在标签材料上打印图案。</p><p>3、条码打印机使用的条码编辑软件要有相应的打印机驱动才能进入条码编辑软件</p><span id="more"></span><p><em><strong>热敏和热转印的区别：</strong></em></p><ol><li>技术原理</li></ol><p><strong>热敏打印：</strong>主要通过对打印头加热，并接触经过化学处理的热敏介质标签后打印出所需图案。热敏标签打印机在使用时不需要任何油墨、墨粉或碳带，使用成本相对较低。</p><p><strong>热转印打印：</strong>主要通过打印头对碳带加热，油墨转印在标签材料上形成图案。热转印标签打印机由于需要碳带，标签纸技术要求比热敏高，因此整体成本存在较大差距。</p><p><strong>02. 适配耗材</strong></p><p><strong>热敏打印：</strong>只能使用热敏纸</p><p><strong>热转印打印：</strong>可接受更多品种的介质，包括PP合成纸、PVC、PET等材质</p><p><strong>03. 保存时间</strong></p><p><strong>热敏打印标签：</strong>对热、光、化学溶剂和磨损敏感，在日常环境下长时间存放后，图案会随时间推移而褪色。市面上普通的热敏标签打印内容保存时间一般为几个月，精臣销售的热敏标签纸采用多层覆膜工艺，一般可保存1-2年不等（具体时长受实际使用环境因素影响决定）。</p><p><strong>热转印打印标签：</strong>能够提供其他打印技术无法匹敌的图案质量和耐久性，相较于热敏打印，保存时间更长久，一般为5年左右，具体时间受标签纸和碳带质量影响，精臣热转印标签采用高品质树脂基碳带，一般可保存8-10年时间。</p><p><strong>04. 使用场景</strong></p><p><strong>热敏打印：</strong>适用于家用、餐饮、商超零售、服装、物流等标签标识更新频率较快并且对条形码要求不高的行业。</p><p><strong>热转印打印：</strong>适用于制造业、汽车业、电力通信、医疗业、纺织业、化学工业、制药工业、零售分发业、运输业和物流、政府机构等多类行业。</p><p><em><strong>Zebra 888t条码打印机使用软件</strong></em></p><p>ZebraDesigner  V2</p><p><a href="https://imgse.com/i/pkDYyx1"><img src="https://s21.ax1x.com/2024/06/21/pkDYyx1.png" alt="pkDYyx1.png"></a></p><p><a href="https://imgse.com/i/pkDYcKx"><img src="https://s21.ax1x.com/2024/06/21/pkDYcKx.png" alt="pkDYcKx.png"></a></p><p><a href="https://imgse.com/i/pkDYs2R"><img src="https://s21.ax1x.com/2024/06/21/pkDYs2R.png" alt="pkDYs2R.png"></a></p><hr><p><strong>总结：打印条码需要选择带碳带的热转印条码打印机，比如Zebra 888t条码打印机</strong></p><p>​           <strong>条码打印机若是安不上驱动，检查打印数据线和打印口是否损坏，一般来讲，线插好后驱动安装完成后，条码打印机就可以打印测试页了</strong></p><p>​           <strong>条码打印机要是打印的不清晰，请先更换碳带，再选择相应的纸张，要么就与条码编辑软件里的字体设置有关系，需要更改字体</strong></p><p>​          <strong>斑马打印机选择的条码编辑软件为ZebraDesigner  V2，经测试可以正常使用。</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;[南月晨的blog](&lt;a href=&quot;https://leiyu-code.github.io/&quot;&gt;南月晨的博客 (leiyu-code.github.io)&lt;/a&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;leiyu-code.github.io&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.linuxcool.com/&quot;&gt;Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;条码打印机须知&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;1、888T的打印方式是热敏&amp;#x2F;热转印；&lt;/p&gt;
&lt;p&gt;​      888D的打印方式是热敏&lt;/p&gt;
&lt;p&gt;2、热敏打印和热转印是条码机的两种打印方式。&lt;/p&gt;
&lt;p&gt;虽然每种方法都使用热敏打印头对打印表面加热。 &lt;/p&gt;
&lt;p&gt;热转印是通过加热色带，在多种材料上打印出耐用、持久的图案。&lt;/p&gt;
&lt;p&gt;热敏打印不使用色带，而是直接在标签材料上打印图案。&lt;/p&gt;
&lt;p&gt;3、条码打印机使用的条码编辑软件要有相应的打印机驱动才能进入条码编辑软件&lt;/p&gt;</summary>
    
    
    
    <category term="workNote" scheme="http://example.com/categories/workNote/"/>
    
    
    <category term="software" scheme="http://example.com/tags/software/"/>
    
    <category term="print" scheme="http://example.com/tags/print/"/>
    
    <category term="zebra" scheme="http://example.com/tags/zebra/"/>
    
  </entry>
  
  <entry>
    <title>腾讯文档使用教程</title>
    <link href="http://example.com/2024/04/29/%E8%85%BE%E8%AE%AF%E6%96%87%E6%A1%A3%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://example.com/2024/04/29/%E8%85%BE%E8%AE%AF%E6%96%87%E6%A1%A3%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</id>
    <published>2024-04-29T02:30:06.000Z</published>
    <updated>2024-04-29T02:35:35.732Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p><p>leiyu-code.github.io</p><p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p><h1 id="腾讯文档使用教程"><a href="#腾讯文档使用教程" class="headerlink" title="腾讯文档使用教程"></a><strong>腾讯文档使用教程</strong></h1><h3 id="【图文教程】"><a href="#【图文教程】" class="headerlink" title="【图文教程】"></a><strong>【图文教程】</strong></h3><p>1、在线文档 (Word) 使用教程:</p><p><a href="https://docs.qq.com/doc/p/fc045c173c6cd5278d17893571b5ca1f2a907de1">https://docs.qq.com/doc/p/fc045c173c6cd5278d17893571b5ca1f2a907de1</a></p><p>2、在线表格 (Excel) 使用教程:</p><p><a href="https://docs.qq.com/doc/p/46053051e04c02507b9f889c3e7d5e7b342ab38e">https://docs.qq.com/doc/p/46053051e04c02507b9f889c3e7d5e7b342ab38e</a></p><p>3、在线幻灯片 (PPT) 使用教程：</p><p><a href="https://docs.qq.com/doc/p/7ec3015255751fe252077f1b1921124ec032142d">https://docs.qq.com/doc/p/7ec3015255751fe252077f1b1921124ec032142d</a></p><p>4、在线收集表使用教程:</p><p><a href="https://docs.qq.com/doc/p/9119455d5eadbb23a232efb4188feb7656fdd7e4">https://docs.qq.com/doc/p/9119455d5eadbb23a232efb4188feb7656fdd7e4</a></p><p>5、     智能表格使用教程:</p><p><a href="https://docs.qq.com/aio/DZmFVQ05WbUdOeXRI">https://docs.qq.com/aio/DZmFVQ05WbUdOeXRI</a></p><p>6、     智能文档使用教程：</p><p><a href="https://docs.qq.com/aio/DWXh1S2tCRnlhVEFL?p=18PtEOLdNUBVPBHaTmbfJT">https://docs.qq.com/aio/DWXh1S2tCRnlhVEFL</a></p><p>7、     思维导图（Mind）使用教程：</p><p><a href="https://docs.qq.com/doc/p/ba603297f82a62611bd7f25612655a048bd2f5c6?pub=1&dver=2.1.27141849">https://docs.qq.com/doc/p/ba603297f82a62611bd7f25612655a048bd2f5c6</a></p><p>8、     流程图（Flowchart）使用教程：</p><p><a href="https://docs.qq.com/doc/p/b0bad2bb71932d45900fa83105ce00bfe9dfc3a7">https://docs.qq.com/doc/p/b0bad2bb71932d45900fa83105ce00bfe9dfc3a7</a></p><h3 id="【视频教程】"><a href="#【视频教程】" class="headerlink" title="【视频教程】"></a><strong>【视频教程】</strong></h3><p>1、【视频教程】1分钟学会做项目规划</p><p><a href="https://v.qq.com/x/page/f30639oiqsl.html">https://v.qq.com/x/page/f30639oiqsl.html</a> </p><p>2、【视频教程】1分钟学会信息收集</p><p><a href="https://v.qq.com/x/page/i3063rsg6yq.html">https://v.qq.com/x/page/i3063rsg6yq.html</a></p><p>3、【视频教程】1分钟学会如何进行远程会议</p><p><a href="https://v.qq.com/x/page/n30637654dl.html">https://v.qq.com/x/page/n30637654dl.html</a> </p><p>4、【视频教程】1分钟学会如何追踪项目进度</p><p><a href="https://v.qq.com/x/page/c3063yywrdr.html">https://v.qq.com/x/page/c3063yywrdr.html</a> </p><p>5、【视频教程】1分钟学会做项目执行</p><p><a href="https://v.qq.com/x/page/v3063xxa8at.html">https://v.qq.com/x/page/v3063xxa8at.html</a> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;[南月晨的blog](&lt;a href=&quot;https://leiyu-code.github.io/&quot;&gt;南月晨的博客 (leiyu-code.github.io)&lt;/a&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;leiyu-code.github.io&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="Tencent" scheme="http://example.com/categories/Tencent/"/>
    
    
    <category term="software" scheme="http://example.com/tags/software/"/>
    
    <category term="TencentDocs" scheme="http://example.com/tags/TencentDocs/"/>
    
  </entry>
  
  <entry>
    <title>VMware Workstation重新安装报错的解决方法</title>
    <link href="http://example.com/2023/11/13/VMware%20Workstation%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85%E6%8A%A5%E9%94%99%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2023/11/13/VMware%20Workstation%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85%E6%8A%A5%E9%94%99%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</id>
    <published>2023-11-13T07:59:06.000Z</published>
    <updated>2024-04-29T02:36:09.084Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p><p>leiyu-code.github.io</p><p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p><p><strong>在重新安装VMware Workstation时会报错，错误的内容乱七八糟，了解了一下后，报错的原因如下：</strong></p><p><strong>1、软件安装临时目录里的反安装程序被删除，导致程序一直出现Vc++ runtime一直安装不了</strong></p><p><strong>2、卸载的时候软件目录里的文件未被清理干净</strong></p><p><strong>3、注册表文件未被清理干净</strong></p><p>解决方法：</p><p>1、卸载所有的C++运行库</p><p>2、重启后再重新安装运行库</p><p>3、重启后再重新安装运行库</p><p><em><strong>在安装过程中试了很多方法都不能成功地安装VM，最后使用了一款VM反安装工具后VM就能正常地安装了</strong></em></p><hr><p><strong>总结：软件安装不了最好先卸载所有的C++运行库，不行了再使用软件的专用清理工具清理下，就可以正常安装了</strong></p><span id="more"></span><p>VM清理工具在以下链接里，快去下来试试吧！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;[南月晨的blog](&lt;a href=&quot;https://leiyu-code.github.io/&quot;&gt;南月晨的博客 (leiyu-code.github.io)&lt;/a&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;leiyu-code.github.io&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.linuxcool.com/&quot;&gt;Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在重新安装VMware Workstation时会报错，错误的内容乱七八糟，了解了一下后，报错的原因如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、软件安装临时目录里的反安装程序被删除，导致程序一直出现Vc++ runtime一直安装不了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、卸载的时候软件目录里的文件未被清理干净&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、注册表文件未被清理干净&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;p&gt;1、卸载所有的C++运行库&lt;/p&gt;
&lt;p&gt;2、重启后再重新安装运行库&lt;/p&gt;
&lt;p&gt;3、重启后再重新安装运行库&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;在安装过程中试了很多方法都不能成功地安装VM，最后使用了一款VM反安装工具后VM就能正常地安装了&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;总结：软件安装不了最好先卸载所有的C++运行库，不行了再使用软件的专用清理工具清理下，就可以正常安装了&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Vm" scheme="http://example.com/categories/Vm/"/>
    
    
    <category term="vm" scheme="http://example.com/tags/vm/"/>
    
    <category term="software" scheme="http://example.com/tags/software/"/>
    
  </entry>
  
  <entry>
    <title>SQL语句学习手册实例</title>
    <link href="http://example.com/2023/07/10/SQL%E8%AF%AD%E5%8F%A5%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C%E5%AE%9E%E4%BE%8B/"/>
    <id>http://example.com/2023/07/10/SQL%E8%AF%AD%E5%8F%A5%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C%E5%AE%9E%E4%BE%8B/</id>
    <published>2023-07-10T08:20:06.000Z</published>
    <updated>2023-07-10T08:41:27.973Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p><p>leiyu-code.github.io</p><p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p><h2 id="SQL语句学习手册实例"><a href="#SQL语句学习手册实例" class="headerlink" title="SQL语句学习手册实例"></a>SQL语句学习手册实例</h2><p><strong>How to use sql &amp; examples</strong></p><p><em><strong>point:表</strong></em></p><p>​          <em><strong>视图</strong></em></p><p>​         <em><strong>索引</strong></em></p><p>​        <em><strong>表达式</strong></em></p><p>​        <em><strong>函数</strong></em></p><p>​        <em><strong>权限控制</strong></em></p><span id="more"></span><h3 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h3><p>例 1 对于表的教学管理数据库中的表 STUDENTS ，可以定义如下：<br>   CREATE TABLE STUDENTS<br>   (SNO      NUMERIC (6, 0) NOT NULL<br>   SNAME    CHAR (8) NOT NULL<br>   AGE      NUMERIC(3,0)<br>   SEX      CHAR(2)<br>   BPLACE CHAR(20)<br>   PRIMARY KEY(SNO))<br>例 2 对于表的教学管理数据库中的表 ENROLLS ，可以定义如下：<br>        CREATE TABLE ENROLLS<br>        (SNO      NUMERIC(6,0) NOT NULL<br>        CNO     CHAR(4) NOT NULL<br>        GRADE   INT<br>        PRIMARY KEY(SNO,CNO)<br>        FOREIGN KEY(SNO) REFERENCES STUDENTS(SNO)<br>        FOREIGN KEY(CNO) REFERENCES COURSES(CNO)<br>        CHECK ((GRADE IS NULL) OR (GRADE BETWEEN 0 AND 100)))<br>例 3 根据表的 STUDENTS 表，建立一个只包含学号、姓名、年龄的女学生表。<br>        CREATE TABLE GIRL<br>        AS SELECT SNO, SNAME, AGE<br>        FROM STUDENTS<br>        WHERE SEX&#x3D;’ 女 ‘; </p><p>例 4 删除教师表 TEACHER 。<br>        DROP TABLE TEACHER<br>例 5 在教师表中增加住址列。<br>       ALTER TABLE TEACHERS<br>       ADD (ADDR CHAR(50))<br>例 6 把 STUDENTS 表中的 BPLACE 列删除，并且把引用 BPLACE 列的所有视图和约束也一起删除。<br>        ALTER TABLE STUDENTS<br>        DROP BPLACE CASCADE<br>例 7 补充定义 ENROLLS 表的主关键字。<br>       ALTER TABLE ENROLLS<br>       ADD PRIMARY KEY (SNO,CNO) ； </p><h3 id="视图操作（虚表）"><a href="#视图操作（虚表）" class="headerlink" title="视图操作（虚表）"></a>视图操作（虚表）</h3><p>例 9 建立一个只包括教师号、姓名和年龄的视图 FACULTY 。 ( 在视图定义中不能包含 ORDER BY 子句 )<br>        CREATE VIEW FACULTY<br>        AS SELECT TNO, TNAME, AGE<br>        FROM TEACHERS<br>例 10 从学生表、课程表和选课表中产生一个视图 GRADE_TABLE ， 它包括学生姓名、课程名和成绩。<br>        CREATE VIEW GRADE_TABLE<br>        AS SELECT SNAME,CNAME,GRADE<br>        FROM STUDENTS,COURSES,ENROLLS<br>        WHERE STUDENTS.SNO ＝ ENROLLS.SNO AND<br>        COURSES.CNO&#x3D;ENROLLS.CNO<br>例 11 删除视图 GRADE_TABLE<br>        DROP VIEW GRADE_TABLE RESTRICT </p><h3 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h3><p>例 12 在学生表中按学号建立索引。<br>        CREATE  UNIQUE  INDEX  ST<br>        ON STUDENTS (SNO,ASC)<br>例 13 删除按学号所建立的索引。<br>        DROP INDEX ST </p><h3 id="数据库模式操作"><a href="#数据库模式操作" class="headerlink" title="数据库模式操作"></a>数据库模式操作</h3><p>例 14 创建一个简易教学数据库的数据库模式  TEACHING_DB ，属主为 ZHANG 。<br>        CREATE SCHEMA TEACHING_DB  AUTHRIZATION  ZHANG<br>例 15 删除简易教学数据库模式 TEACHING_DB 。（（ 1 ）选用 CASCADE ，即当删除数据库模式时，则本数据库模式和其下属的基本表、视图、索引等全部被删除。（ 2 ）选用 RESTRICT ，即本数据库模式下属的基本表、视图、索引等事先已清除，才能删除本数据库模式，否则拒绝删除。）<br>        DROP SCHEMA TEACHING_DB CASCADE </p><h3 id="单表操作"><a href="#单表操作" class="headerlink" title="单表操作"></a>单表操作</h3><p>例 16 找出 3 个学分的课程号和课程名。<br>         SELECT CNO, CNAME<br>         FROM 　 COURSES<br>         WHERE 　 CREDIT ＝ 3<br>例 17 查询年龄大于 22 岁的学生情况。<br>         SELECT *<br>         FROM   STUDENTS<br>         WHERE AGE ＞ 22<br>例 18   找出籍贯为河北的男生的姓名和年龄。<br>         SELECT SNAME, AGE<br>         FROM 　 STUDENTS<br>         WHERE 　 BPLACE ＝ ‘ 河北 ‘  AND SEX ＝ ‘ 男 ‘<br>例 19 找出年龄在 20 ～ 23 岁之间的学生的学号、姓名和年龄，并按年龄升序排序。 (ASC （升序）或 DESC （降序）声明排序的方式，缺省为升序。 )<br>         SELECT SNO, SNAME, AGE<br>         FROM   STUDENTS<br>         WHERE AGE BETWEEN 20 AND 23<br>         ORDER BY  AGE<br>例 20 找出年龄小于 23 岁、籍贯是湖南或湖北的学生的姓名和性别。（条件比较运算符＝、＜ 和逻辑运算符 AND （与），此外还可以使用的运算符有：＞（大于）、＞＝（大于等于）、＜＝（小于等于）、＜＞（不等于）、 NOT （非）、 OR （或）等。<br>谓词 LIKE 只能与字符串联用，常常是 “ ＜列名＞  LIKE pattern” 的格式。特殊字符 “_” 和 “%” 作为通配符。<br>谓词 IN 表示指定的属性应与后面的集合（括号中的值集或某个查询子句的结果）中的某个值相匹配，实际上是一系列的 OR （或）的缩写。谓词 NOT IN 表示指定的属性不与后面的集合中的某个值相匹配。<br>谓词 BETWEEN 是 “ 包含于 … 之中 ” 的意思。）<br>        SELECT SNAME, SEX<br>        FROM   STUDENTS<br>        WHERE AGE ＜ 23 AND BPLACE LIKE’ 湖％ ‘<br>        或<br>        SELECT SNAME, SEX<br>        FROM   STUDENTS<br>        WHERE AGE ＜ 23 AND BPLACE IN （ ‘ 湖南 ‘ ， ‘ 湖北 ‘ ）<br>例 22 找出学生表中籍贯是空值的学生的姓名和性别。（在 SQL 中不能使用条件：＜列名＞＝ NULL 。在 SQL 中只有一个特殊的查询条件允许查询 NULL 值：）<br>       SELECT SNAME, SEX<br>       FROM   STUDENTS<br>       WHERE BPLACE IS NULL </p><h3 id="多表操作"><a href="#多表操作" class="headerlink" title="多表操作"></a>多表操作</h3><p>例 23 找出成绩为 95 分的学生的姓名。（子查询）<br>        SELECT SNAME<br>        FROM 　 STUDENTS<br>        WHERE 　 SNO ＝<br>              (SELECT SNO<br>               FROM   ENROLLS<br>               WHERE GRADE ＝ 95)<br>例 24 找出成绩在 90 分以上的学生的姓名。<br>       SELECT SNAME<br>        FROM   STUDENTS<br>        WHERE SNO IN<br>                (SELECT SNO<br>                FROM ENROLLS<br>                WHERE GRADE ＞ 90)<br>        或<br>        SELECT SNAME<br>        FROM   STUDENTS<br>        WHERE SNO ＝ ANY<br>                (SELECT SNO<br>                FROM ENROLLS<br>                WHERE GRADE ＞ 90)<br>例 25 查询全部学生的学生名和所学课程号及成绩。（连接查询）<br>        SELECT SNAME, CNO, GRADE<br>        FROM   STUDENTS, ENROLLS<br>        WHERE STUDENTS.SNO ＝ ENROLLS.SNO<br>例 26 找出籍贯为山西或河北，成绩为 90 分以上的学生的姓名、籍贯和成绩。（当构造多表连接查询命令时，必须遵循两条规则。第一，连接条件数正好比表数少 1 （若有三个表，就有两个连接条件 ) ；第二，若一个表中的主关键字是由多个列组成，则对此主关键字中的每一个列都要有一个连接条件（也有少数例外情况））<br>        SELECT SNAME, BPLACE, GRADE<br>        FROM   STUDENTS, ENROLLS<br>        WHERE BPLACE IN (‘ 山西 ’ ， ‘ 河北 ’) AND GRADE ＞＝ 90 AND 　 STUDENTS.SNO&#x3D;ENROLLS.SNO<br>例 28 查出课程成绩在 80 分以上的女学生的姓名、课程名和成绩。（ FROM 子句中的子查询）<br>        SELECT SNAME,CNAME, GRADE<br>        FROM   (SELECT SNAME, CNAME , GRADE<br>                        FROM STUDENTS, ENROLLS,COURSES<br>                        WHERE SEX ＝ ‘ 女 ‘)<br>        AS TEMP (SNAME, CNAME,GRADE)<br>        WHERE GRADE ＞ 80 </p><h3 id="表达式与函数的使用"><a href="#表达式与函数的使用" class="headerlink" title="表达式与函数的使用"></a>表达式与函数的使用</h3><p>例 29 查询各课程的学时数。（算术表达式由算术运算符＋、－、 * 、／与列名或数值常量所组成。）<br>        SELECT CNAME,COURSE_TIME ＝ CREDIT<em>16<br>        FROM   COURSES<br>例 30 找出教师的最小年龄。（内部函数： SQL 标准中只使用 COUNT 、 SUM 、 AVG 、 MAX 、 MIN 函数，称之为聚集函数（ Set Function ）。 COUNT 函数的结果是该列统计值的总数目， SUM 函数求该列统计值之和， AVG 函数求该列统计值之平均值， MAX 函数求该列最大值， MIN 函数求该列最小值。）<br>        SELECT MIN(AGE)<br>        FROM   TEACHERS<br>例 31 统计年龄小于等于 22 岁的学生人数。（统计）<br>        SELECT COUNT(</em>)<br>        FROM   STUDENTS<br>        WHERE AGE &lt; ＝ 22<br>例 32 找出学生的平均成绩和所学课程门数。<br>        SELECT SNO, AVG(GRADE), COURSES ＝ COUNT(*)<br>        FROM   ENROLLS<br>        GROUP BY SNO </p><p>例 34 找出年龄超过平均年龄的学生姓名。<br>SELECT SNAME<br>FROM STUDENTS<br>WHERE AGE ＞<br>      (SELECT AVG(AGE)<br>        FROM   STUDENTS) </p><p>例 35 找出各课程的平均成绩，按课程号分组，且只选择学生超过 3 人的课程的成绩。（ GROUP BY 与 HAVING<br>        GROUP BY 子句把一个表按某一指定列（或一些列）上的值相等的原则分组，然后再对每组数据进行规定的操作。<br>        GROUP BY 子句总是跟在 WHERE 子句后面，当 WHERE 子句缺省时，它跟在 FROM 子句后面。<br>        HAVING 子句常用于在计算出聚集之后对行的查询进行控制。）<br>         SELECT CNO, AVG(GRADE), STUDENTS ＝ COUNT(<em>)<br>         FROM ENROLLS<br>         GROUP BY CNO<br>         HAVING COUNT(</em>) &gt;&#x3D; 3 </p><h3 id="相关子查询"><a href="#相关子查询" class="headerlink" title="相关子查询"></a>相关子查询</h3><p>例 37 查询没有选任何课程的学生的学号和姓名。（当一个子查询涉及到一个来自外部查询的列时，称为相关子查询（ Correlated Subquery) 。相关子查询要用到存在测试谓词 EXISTS 和 NOT EXISTS ，以及 ALL 、 ANY （ SOME ）等。）<br>        SELECT SNO, SNAME<br>        FROM   STUDENTS<br>        WHERE NOT EXISTS<br>              (SELECT *<br>              FROM ENROLLS<br>              WHERE ENROLLS.SNO&#x3D;STUDENTS.SNO)<br>例 38   查询哪些课程只有男生选读。<br>        SELECT DISTINCT CNAME<br>        FROM   COURSES C<br>        WHERE ‘ 男 ‘ ＝ ALL<br>               (SELECT SEX<br>                FROM ENROLLS ， STUDENTS<br>                WHERE ENROLLS.SNO&#x3D;STUDENTS.SNO AND<br>                      ENROLLS.CNO&#x3D;C.CNO)<br>例 39 要求给出一张学生、籍贯列表，该表中的学生的籍贯省份，也是其他一些学生的籍贯省份。<br>        SELECT SNAME, BPLACE<br>        FROM   STUDENTS A<br>        WHERE EXISTS<br>               (SELECT *<br>                 FROM STUDENTS B<br>                 WHERE A.BPLACE&#x3D;B.BPLACE AND<br>                       A.SNO &lt; &gt; B.SNO) </p><p>例 40 找出选修了全部课程的学生的姓名。<br>        本查询可以改为：查询这样一些学生，没有一门课程是他不选修的。<br>        SELECT SNAME<br>        FROM   STUDENTS<br>        WHERE NOT EXISTS<br>               (SELECT *<br>                FROM COURSES<br>                WHERE NOT EXISTS<br>                        (SELECT *<br>                         FROM ENROLLS<br>                         WHERE ENROLLS.SNO ＝ STUDENTS.SNO<br>                             AND ENROLLS.CNO ＝ COURSES.CNO)) </p><h3 id="关系代数运算"><a href="#关系代数运算" class="headerlink" title="关系代数运算"></a>关系代数运算</h3><p>例 41 设有某商场工作人员的两张表：营业员表 SP_SUBORD 和营销经理表 SP_MGR ，其关系数据模式如下：<br>        SP_SUBORD (SALPERS_ID, SALPERS_NAME, MANAGER_ID, OFFICE)<br>        SP_MGR (SALPERS_ID, SALPERS_NAME, MANAGER_ID, OFFICE)<br>        其中，属性 SALPERS_ID 为工作人员的编号 , SALPERS_NAME 为工作人员的姓名 , MANAGER_ID 为所在部门经理的编号 , OFFICE 为工作地点。<br>若查询全部商场工作人员，可以用下面的 SQL 语句：<br>        (SELECT * FROM SP_SUBORD)<br>        UNION<br>        (SELECT * FROM SP_MGR)<br>        或等价地用下面的 SQL 语句：<br>        SELECT *<br>        FROM (TABLE SP_SUBORD UNION TABLE SP_MGR)<br>（ 2 ） INTERSECT<br>         (SELECT * FROM SP_SUBORD)<br>         INTERSECT<br>         (SELECT * FROM SP_MGR)<br>        或等价地用下面的 SQL 语句：<br>        SELECT *<br>        FROM (TABLE SP_SUBORD INTERSECT TABLE SP_MGR)<br>        或用带 ALL 的 SQL 语句：<br>        (SELECT * FROM SP_SUBORD)<br>       INTERSECT ALL<br>        (SELECT * FROM SP_MGR)<br>        或<br>        SELECT *<br>        FROM (TABLE SP_SUBORD INTERSECT ALL TABLE SP_MGR)<br>（ 3 ） EXCEPT<br>        (SELECT * FROM SP_MGR)<br>        EXCEPT<br>        (SELECT * FROM SP_SUBORD)<br>        或等价地用下面的 SQL 语句：<br>        SELECT *<br>        FROM (TABLE SP_MGR EXCEPT TABLE SP_ SUBORD)<br>        或用带 ALL 的 SQL 语句：<br>        (SELECT * FROM SP_MGR)<br>        EXCEPT ALL<br>        (SELECT * FROM SP_SUBORD)<br>例 42 查询籍贯为四川、课程成绩在 80 分以上的学生信息及其成绩。（自然连接）<br>        (SELECT * FROM STUDENTS<br>         WHERE BPLACE&#x3D;‘ 四川 ’)<br>        NATURAL JOIN<br>        (SELECT * FROM ENROLLS<br>         WHERE GRADE &gt;&#x3D;80)<br>例3.43          列出全部教师的姓名及其任课的课程号、班级。<br>（外连接与外部并外连接允许在结果表中保留非匹配元组，空缺部分填以 NULL 。外连接的作用是在做连接操作时避免丢失信息。<br>        外连接有 3 类：<br>（ 1 ）左外连接（ Left Outer Join ）。连接运算谓词为 LEFT [OUTER] JOIN ，其结果表中保留左关系的所有元组。<br>（ 2 ）右外连接（ Right Outer Join ）。连接运算谓词为 RIGHT [OUTER] JOIN ，其结果表中保留右关系的所有元组。<br>（ 3 ）全外连接（ Full Outer Join ）。连接运算谓词为 FULL [OUTER] JOIN ，其结果表中保留左右两关系的所有元组。）<br>          SELECT TNAME, CNO, CLASS<br>          FROM TEACHERS LEFT OUTER JOIN TEACHING USING (TNO) </p><h3 id="SQL-的数据操作"><a href="#SQL-的数据操作" class="headerlink" title="SQL 的数据操作"></a>SQL 的数据操作</h3><p>例 44 把教师李映雪的记录加入到教师表 TEACHERS 中。（插入）<br>        INSERT INTO TEACHERS<br>        VALUES(1476 ， ‘ 李映雪 ‘ ， 44 ， ‘ 副教授 ‘)<br>例 45 成绩优秀的学生将留下当教师。<br>        INSERT INTO TEACHERS (TNO ， TNAME)<br>        SELECT DISTINCT SNO ， SNAME<br>        FROM   STUDENTS ， ENROLLS<br>        WHERE STUDENTS.SNO ＝ ENROLLS.SNO AND GRADE ＞＝ 90<br>例 47 把所有学生的年龄增加一岁。（修改）<br>        UPDATE STUDENTS<br>        SET AGE ＝ AGE+1<br>例 48 学生张春明在数据库课考试中作弊，该课成绩应作零分计。<br>        UPDATE ENROLLS<br>        SET GRADE ＝ 0<br>        WHERE CNO ＝ ‘C1’ AND<br>             ‘ 张春明 ‘ ＝<br>             (SELECT SNAME<br>             FROM STUDENTS<br>             WHERE STUDENTS.SNO&#x3D;ENROLLS.SNO)<br>例 49 从教师表中删除年龄已到 60 岁的退休教师的数据。（删除）<br>        DELETE FROM TEACHERS<br>        WHERE AGE ＞＝ 60 </p><h3 id="SQL-的数据权限控制"><a href="#SQL-的数据权限控制" class="headerlink" title="SQL 的数据权限控制"></a>SQL 的数据权限控制</h3><p>例 50 授予 LILI 有对表 STUDENTS 的查询权。（表／视图特权的授予<br>        一个 SQL 特权允许一个被授权者在给定的数据库对象上进行特定的操作。授权操作的数据库对象包括：表 &#x2F; 视图、列、域等。授权的操作包括： INSERT 、 UPDATE 、 DELETE 、 SELECT 、 REFERENCES 、 TRIGGER 、 UNDER 、 USAGE 、 EXECUTE 等。其中 INSERT 、 UPDATE 、 DELETE 、 SELECT 、 REFERENCES 、 TRIGGER 有对表做相应操作的权限，故称为表特权。）<br>        GRANT SELECT ON STUDENTS<br>        TO LILI<br>        WITH GRANT OPTION<br>例 51 取消 LILI 的存取 STUDENTS 表的特权。<br>        REVOKE ALL<br>        ON STUDENTS<br>        FROM LILI CASCADE </p><p>不断补充中：</p><ol><li>模糊查找:<br>它判断列值是否与指定的字符串格式相匹配。可用于char、varchar、text、ntext、datetime和smalldatetime等类型查询。<br>　　可使用以下通配字符：<br>　　百分号%：可匹配任意类型和长度的字符，如果是中文，请使用两个百分号即%%。<br>　　下划线_：匹配单个任意字符，它常用来限制表达式的字符长度。<br>　　方括号[]：指定一个字符、字符串或范围，要求所匹配对象为它们中的任一个。[^]：其取值也[] 相同，但它要求所匹配对象为指定字符以外的任一个字符。<br>　　 例如：<br>　　限制以Publishing结尾，使用LIKE ‘%Publishing’<br>　　限制以A开头：LIKE ‘[A]%’<br>　　限制以A开头外：LIKE ‘[^A]%’</li></ol><p>2.更改表格　<br>         ALTER TABLE table_name<br>        ADD COLUMN column_name DATATYPE<br>        说明：增加一个栏位（没有删除某个栏位的语法。)<br>        ALTER TABLE table_name<br>        ADD PRIMARY KEY (column_name)<br>        说明：更改表得的定义把某个栏位设为主键。<br>        ALTER TABLE table_name<br>        DROP PRIMARY KEY (column_name)<br>        说明：把主键的定义删除。<br>3.group by<br>在select 语句中可以使用group by 子句将行划分成较小的组，然后，使用聚组函数返回每一个组的汇总信息，另外，可以使用having子句限制返回的结果集。group by 子句可以将查询结果分组，并返回行的汇总信息Oracle 按照group by 子句中指定的表达式的值分组查询结果。<br>在带有group by 子句的查询语句中，在select 列表中指定的列要么是group by 子句中指定的列，要么包含聚组函数<br>select max(sal),job emp group by job;<br>(注意max(sal),job的job并非一定要出现，但有意义)<br>查询语句的select 和group by ,having 子句是聚组函数唯一出现的地方，在where 子句中不能使用聚组函数。<br>select deptno,sum(sal) from emp where sal&gt;1200 group by deptno having sum(sal)&gt;8500 order by deptno;<br>当在gropu by 子句中使用having 子句时，查询结果中只返回满足having条件的组。在一个sql语句中可以有where子句和having子句。having 与where 子句类似，均用于设置限定条件</p><p>where 子句的作用是在对查询结果进行分组前，将不符合where条件的行去掉，即在分组之前过滤数据，条件中不能包含聚组函数，使用where条件显示特定的行。<br>having 子句的作用是筛选满足条件的组，即在分组之后过滤数据，条件中经常包含聚组函数，使用having 条件显示特定的组，也可以使用多个分组标准进行分组。<br>查询每个部门的每种职位的雇员数<br>select deptno,job,count(*) from emp group by deptno,job;<br>4.外连接与内连接<br>有时候，即使在连接的表中没有相应的行，用户可能想从一张表中看数据，Oracle提供了外连接实现该功能。<br>内连接是指连接查询只显示完全满足连接条件的记录，即等值连接，外连接的查询结果是内连接查询结果的扩展。外连接不仅返回满足连接条件的所有记录而且也返回了一个表中那些在另一个表中没有匹配行的记录。外连接的操作符是“+”。“+”号放在连接条件中信息不完全的那一边（即没有相应行的那一边）。运算符“+”影响NULL行的建立。建一行或多行NULL来匹配连接的表中信息完全的行。<br>外连接运算符“+”只能出现在where子句中表达式的一边。<br>假如在多张表之间有多个连接条件，外连接运算符不能使用or,in逻辑运算符与其它条件组合。</p><p>假如emp表中deptno&#x3D;10的ename为空值，dept表中deptno&#x3D;20的loc为空值：<br>1.<br>select<br>ename,dept.deptno,loc<br>from<br>emp,dept<br>where<br>emp.depno(+)&#x3D;dept.deptno;<br>如果在dept.deptno中有的数值在emp.deptno中没有值，则在做外连接时，<br>结果中ename会产生一个空值。(emp.deptno&#x3D;10)<br>2.<br>select<br>ename,dept.deptno,loc<br>from<br>emp,dept<br>where<br>emp.depno&#x3D;dept.deptno(+);<br>如果在emp.deptno中有的数值在dept.deptno中没有值，则在做外连接时，<br>结果中loc会产生一个空值。。(dept.deptno&#x3D;20)</p><p>5.自连接<br>自连接是指同一张表的不同行间的连接。该连接不受其他表的影响。用自连接可以比较同一张表中不同行的某一列的值。因为自连接查询仅涉及到某一张表与其自身的连接。所以在from子句中该表名出现两次，分别用两个不同的别名表示，两个别名当作两张不同的表进行处理，与其它的表连接一样，别名之间也使用一个或多个相关的列连接。为了区分同一张表的不同行的列，在名前永别名加以限制。<br>select<br>worker.ename,<br>manager.ename manager<br>from<br>emp worker,<br>emp manager<br>where<br>work.mgr&#x3D;manager.empno;<br>6.集合运算<br>基合运算符可以用于从多张表中选择数据。<br>①UNION运算<br>用于求两个结果集合的并集（两个结果集合的所有记录），并自动去掉重复行。<br>select ename,sal from account where sal&gt;2000<br>union<br>select ename,sal from research where sal&gt;2000<br>union<br>select ename,sal from sales where sal&gt;2000;<br>注：ename,sal 是必须一致的。 </p><p>②UNION ALL运算<br>用于求两个结果集合的并集（两个结果集中的所有记录），并且不去掉重复行。<br>select ename,sal from account where sal&gt;2000<br>union<br>select ename,sal from research where sal&gt;2000<br>union<br>select ename,sal from sales where sal&gt;2000;<br>③INTERSECT运算<br>intersect运算返回查询结果中相同的部分。</p><p>各部门中有哪些相同的职位？<br>select Job from account<br>intersect<br>select Job from research<br>intersect<br>select Job from sales;</p><p>④MINUS运算<br>minus返回两个结果集的差集。（在第一个结果集中存在的，而在第二个结果集中不存在的行。）<br>有那些职位是财务部中有，而在销售部门中没有？<br>select Job from account<br>minus<br>select Job from sales;</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;[南月晨的blog](&lt;a href=&quot;https://leiyu-code.github.io/&quot;&gt;南月晨的博客 (leiyu-code.github.io)&lt;/a&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;leiyu-code.github.io&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.linuxcool.com/&quot;&gt;Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;SQL语句学习手册实例&quot;&gt;&lt;a href=&quot;#SQL语句学习手册实例&quot; class=&quot;headerlink&quot; title=&quot;SQL语句学习手册实例&quot;&gt;&lt;/a&gt;SQL语句学习手册实例&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;How to use sql &amp;amp; examples&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;point:表&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;​          &lt;em&gt;&lt;strong&gt;视图&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;​         &lt;em&gt;&lt;strong&gt;索引&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;​        &lt;em&gt;&lt;strong&gt;表达式&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;​        &lt;em&gt;&lt;strong&gt;函数&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;​        &lt;em&gt;&lt;strong&gt;权限控制&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Datebase" scheme="http://example.com/categories/Datebase/"/>
    
    
    <category term="sql" scheme="http://example.com/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>SQL语句大全</title>
    <link href="http://example.com/2023/07/10/SQL%E8%AF%AD%E5%8F%A5%E5%A4%A7%E5%85%A8/"/>
    <id>http://example.com/2023/07/10/SQL%E8%AF%AD%E5%8F%A5%E5%A4%A7%E5%85%A8/</id>
    <published>2023-07-10T03:06:06.000Z</published>
    <updated>2023-07-10T03:24:10.435Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p><p>leiyu-code.github.io</p><p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p><h1 id="SQL语句大全"><a href="#SQL语句大全" class="headerlink" title="SQL语句大全"></a>SQL语句大全</h1><h3 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h3><p>1、说明：创建数据库 CREATE DATABASE database-name </p><p>2、说明：删除数据库 drop database dbname </p><p>3、说明：备份sql server — 创建 备份数据的 device USE master EXEC sp_addumpdevice ‘disk’, ‘testBack’, ‘c:\mssql7backup\MyNwind_1.dat’ — 开始 备份 BACKUP DATABASE pubs TO testBack </p><p>4、说明：创建新表 create table tabname(col1 type1 [not null] [primary key],col2 type2 [not null],..)</p><p>根据已有的表创建新表： A：create table tab_new like tab_old (使用旧表创建新表) B：create table tab_new as select col1,col2… from tab_old definition only </p><p>5、说明：删除新表 drop table tabname </p><p>6、说明：增加一个列 Alter table tabname add column col type 注：列增加后将不能删除。DB2中列加上后数据类型也不能改变，唯一能改变的是增加varchar类型的长度。 </p><p>7、说明：添加主键： Alter table tabname add primary key(col) 说明：删除主键： Alter table tabname drop primary key(col) </p><p>8、说明：创建索引：create [unique] index idxname on tabname(col….) 删除索引：drop index idxname 注：索引是不可更改的，想更改必须删除重新建。 </p><p>9、说明：创建视图：create view viewname as select statement 删除视图：drop view viewname </p><span id="more"></span><p>10、说明：几个简单的基本的sql语句 </p><p>选择：select * from table1 where 范围 </p><p>插入：insert into table1(field1,field2) values(value1,value2) </p><p>删除：delete from table1 where </p><p>范围 更新：update table1 set field1&#x3D;value1 where </p><p>范围 查找：select * from table1 where field1 like ’%value1%’ —like的语法很精妙，查资料! </p><p>排序：select * from table1 order by field1,field2 [desc] </p><p>总数：select count as totalcount from table1 </p><p>求和：select sum(field1) as sumvalue from table1 </p><p>平均：select avg(field1) as avgvalue from table1 </p><p>最大：select max(field1) as maxvalue from table1 </p><p>最小：select min(field1) as minvalue from table1 </p><p>11、说明：几个高级查询运算词 </p><p>A： UNION 运算符 UNION 运算符通过组合其他两个结果表（例如 TABLE1 和 TABLE2）并消去表中任何重复行而派生出一个结果表。当 ALL 随 UNION 一起使用时（即 UNION ALL），不消除重复行。两种情况下，派生表的每一行不是来自 TABLE1 就是来自 TABLE2。 </p><p>B： EXCEPT 运算符 EXCEPT 运算符通过包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行而派生出一个结果表。当 ALL 随 EXCEPT 一起使用时 (EXCEPT ALL)，不消除重复行。 </p><p>C： INTERSECT 运算符 INTERSECT 运算符通过只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果表。当 ALL 随 INTERSECT 一起使用时 (INTERSECT ALL)，不消除重复行。 注：使用运算词的几个查询结果行必须是一致的。 </p><p>12、说明：使用外连接 </p><p>A、left （outer） join： 左外连接（左连接）：结果集几包括连接表的匹配行，也包括左连接表的所有行。 SQL: select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a &#x3D; b.c </p><p>B：right （outer） join: 右外连接(右连接)：结果集既包括连接表的匹配连接行，也包括右连接表的所有行。 </p><p>C：full&#x2F;cross （outer） join： 全外连接：不仅包括符号连接表的匹配行，还包括两个连接表中的所有记录。 </p><p>12、分组:Group by: 一张表，一旦分组 完成后，查询后只能得到组相关的信息。 </p><p>组相关的信息：（统计信息） count,sum,max,min,avg  分组的标准) 在SQLServer中分组时：不能以text,ntext,image类型的字段作为分组依据 在selecte统计函数中的字段，不能和普通的字段放在一起；</p><p>13、对数据库进行操作： </p><p>分离数据库： sp_detach_db; </p><p>附加数据库：sp_attach_db 后接表明，附加需要完整的路径名 </p><p>14.如何修改数据库的名称: sp_renamedb ‘old_name’, ‘new_name’</p><hr><h3 id="二、提升"><a href="#二、提升" class="headerlink" title="二、提升"></a>二、提升</h3><p>1、说明：复制表(只复制结构,源表名：a 新表名：b) (Access可用) 法一：select * into b from a where 1&lt;&gt;1（仅用于SQlServer） 法二：select top 0 * into b from a 2、说明：拷贝表(拷贝数据,源表名：a 目标表名：b) (Access可用) insert into b(a, b, c) select d,e,f from b;</p><p>3、说明：跨数据库之间表的拷贝(具体数据使用绝对路径) (Access可用) insert into b(a, b, c) select d,e,f from b in ‘具体数据库’ where 条件 例子：..from b in ‘“&amp;Server.MapPath(“.”)&amp;”\data.mdb” &amp;”‘ where..</p><p>4、说明：子查询(表名1：a 表名2：b) select a,b,c from a where a IN (select d from b ) 或者: select a,b,c from a where a IN (1,2,3)</p><p>5、说明：显示文章、提交人和最后回复时间 select a.title,a.username,b.adddate from table a,(select max(adddate) adddate from table where table.title&#x3D;a.title) b</p><p>6、说明：外连接查询(表名1：a 表名2：b) select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a &#x3D; b.c</p><p>7、说明：在线视图查询(表名1：a ) select * from (SELECT a,b,c FROM a) T where t.a &gt; 1;</p><p>8、说明：between的用法,between限制查询数据范围时包括了边界值,not between不包括 select * from table1 where time between time1 and time2 select a,b,c, from table1 where a not between 数值1 and 数值2</p><p>9、说明：in 的使用方法 select * from table1 where a [not] in (‘值1’,’值2’,’值4’,’值6’)</p><p>10、说明：两张关联表，删除主表中已经在副表中没有的信息 delete from table1 where not exists ( select * from table2 where table1.field1&#x3D;table2.field1 )</p><p>11、说明：四表联查问题： select * from a left inner join b on a.a&#x3D;b.b right inner join c on a.a&#x3D;c.c inner join d on a.a&#x3D;d.d where …..</p><p>12、说明：日程安排提前五分钟提醒 SQL: select * from 日程安排 where datediff(‘minute’,f开始时间,getdate())&gt;5</p><p>13、说明：一条sql 语句搞定数据库分页 select top 10 b.* from (select top 20 主键字段,排序字段 from 表名 order by 排序字段 desc) a,表名 b where b.主键字段 &#x3D; a.主键字段 order by a.排序字段 具体实现： 关于数据库分页：</p><p>declare @start int,@end int</p><p>@sql nvarchar(600)</p><p>set @sql&#x3D;’select top’+str(@end-@start+1)+’+from T where rid not in(select top’+str(@str-1)+’Rid from T where Rid&gt;-1)’</p><p>exec sp_executesql @sql</p><p>注意：在top后不能直接跟一个变量，所以在实际应用中只有这样的进行特殊的处理。Rid为一个标识列，如果top后还有具体的字段，这样做是非常有好处的。因为这样可以避免 top的字段如果是逻辑索引的，查询的结果后实际表中的不一致（逻辑索引中的数据有可能和数据表中的不一致，而查询时如果处在索引则首先查询索引）</p><p>14、说明：前10条记录 select top 10 * form table1 where 范围</p><p>15、说明：选择在每一组b值相同的数据中对应的a最大的记录的所有信息(类似这样的用法可以用于论坛每月排行榜,每月热销产品分析,按科目成绩排名,等等.) select a,b,c from tablename ta where a&#x3D;(select max(a) from tablename tb where tb.b&#x3D;ta.b)</p><p>16、说明：包括所有在 TableA 中但不在 TableB和TableC 中的行并消除所有重复行而派生出一个结果表 (select a from tableA ) except (select a from tableB) except (select a from tableC)</p><p>17、说明：随机取出10条数据 select top 10 * from tablename order by newid()</p><p>18、说明：随机选择记录 select newid()</p><p>19、说明：删除重复记录 </p><p>1),delete from tablename where id not in (select max(id) from tablename group by col1,col2,…) </p><p>2),select distinct * into temp from tablename delete from tablename insert into tablename select * from temp 评价： 这种操作牵连大量的数据的移动，这种做法不适合大容量但数据操作 </p><p>3),例如：在一个外部表中导入数据，由于某些原因第一次只导入了一部分，但很难判断具体位置，这样只有在下一次全部导入，这样也就产生好多重复的字段，怎样删除重复字段</p><p>alter table tablename –添加一个自增列 add column_b int identity(1,1) delete from tablename where column_b not in( select max(column_b) from tablename group by column1,column2,…) alter table tablename drop column column_b</p><p>20、说明：列出数据库里所有的表名 select name from sysobjects where type&#x3D;’U’ &#x2F;&#x2F; U代表用户</p><p>21、说明：列出表里的所有的列名 select name from syscolumns where id&#x3D;object_id(‘TableName’)</p><p>22、说明：列示type、vender、pcs字段，以type字段排列，case可以方便地实现多重选择，类似select 中的case。 select type,sum(case vender when ‘A’ then pcs else 0 end),sum(case vender when ‘C’ then pcs else 0 end),sum(case vender when ‘B’ then pcs else 0 end) FROM tablename group by type 显示结果： type vender pcs 电脑 A 1 电脑 A 1 光盘 B 2 光盘 A 2 手机 B 3 手机 C 3</p><p>23、说明：初始化表table1</p><p>TRUNCATE TABLE table1</p><p>24、说明：选择从10到15的记录 select top 5 * from (select top 15 * from table order by id asc) table_别名 order by id desc</p><hr><h3 id="三、技巧"><a href="#三、技巧" class="headerlink" title="三、技巧"></a>三、技巧</h3><p>1、1&#x3D;1，1&#x3D;2的使用，在SQL语句组合时用的较多</p><p>“where 1&#x3D;1” 是表示选择全部    “where 1&#x3D;2”全部不选， 如： if @strWhere !&#x3D;’’ begin set @strSQL &#x3D; ‘select count(<em>) as Total from [‘ + @tblName + ‘] where ‘ + @strWhere end else begin set @strSQL &#x3D; ‘select count(</em>) as Total from [‘ + @tblName + ‘]’ end</p><p>我们可以直接写成</p><p>错误！未找到目录项。 set @strSQL &#x3D; ‘select count(*) as Total from [‘ + @tblName + ‘] where 1&#x3D;1 安定 ‘+ @strWhere 2、收缩数据库 –重建索引 DBCC REINDEX DBCC INDEXDEFRAG –收缩数据和日志 DBCC SHRINKDB DBCC SHRINKFILE</p><p>3、压缩数据库 dbcc shrinkdatabase(dbname)</p><p>4、转移数据库给新用户以已存在用户权限 exec sp_change_users_login ‘update_one’,’newname’,’oldname’ go</p><p>5、检查备份集 RESTORE VERIFYONLY from disk&#x3D;’E:\dvbbs.bak’</p><p>6、修复数据库 ALTER DATABASE [dvbbs] SET SINGLE_USER GO DBCC CHECKDB(‘dvbbs’,repair_allow_data_loss) WITH TABLOCK GO ALTER DATABASE [dvbbs] SET MULTI_USER GO</p><p>7、日志清除 SET NOCOUNT ON DECLARE @LogicalFileName sysname, @MaxMinutes INT, @NewSize INT</p><p>USE tablename – 要操作的数据库名 SELECT  @LogicalFileName &#x3D; ‘tablename_log’, – 日志文件名 @MaxMinutes &#x3D; 10, – Limit on time allowed to wrap log. @NewSize &#x3D; 1  – 你想设定的日志文件的大小(M)</p><p>Setup &#x2F; initialize DECLARE @OriginalSize int SELECT @OriginalSize &#x3D; size FROM sysfiles WHERE name &#x3D; @LogicalFileName SELECT ‘Original Size of ‘ + db_name() + ‘ LOG is ‘ + CONVERT(VARCHAR(30),@OriginalSize) + ‘ 8K pages or ‘ + CONVERT(VARCHAR(30),(@OriginalSize*8&#x2F;1024)) + ‘MB’ FROM sysfiles WHERE name &#x3D; @LogicalFileName CREATE TABLE DummyTrans (DummyColumn char (8000) not null)</p><p>DECLARE @Counter    INT, @StartTime DATETIME, @TruncLog   VARCHAR(255) SELECT @StartTime &#x3D; GETDATE(), @TruncLog &#x3D; ‘BACKUP LOG ‘ + db_name() + ‘ WITH TRUNCATE_ONLY’</p><p>DBCC SHRINKFILE (@LogicalFileName, @NewSize) EXEC (@TruncLog) – Wrap the log if necessary. WHILE @MaxMinutes &gt; DATEDIFF (mi, @StartTime, GETDATE()) – time has not expired AND @OriginalSize &#x3D; (SELECT size FROM sysfiles WHERE name &#x3D; @LogicalFileName)</p><p>AND (@OriginalSize * 8 &#x2F;1024) &gt; @NewSize</p><p>BEGIN – Outer loop. SELECT @Counter &#x3D; 0 WHILE   ((@Counter &lt; @OriginalSize &#x2F; 16) AND (@Counter &lt; 50000)) BEGIN – update INSERT DummyTrans VALUES (‘Fill Log’) DELETE DummyTrans SELECT @Counter &#x3D; @Counter + 1 END EXEC (@TruncLog)</p><p>END SELECT ‘Final Size of ‘ + db_name() + ‘ LOG is ‘ + CONVERT(VARCHAR(30),size) + ‘ 8K pages or ‘ + CONVERT(VARCHAR(30),(size*8&#x2F;1024)) + ‘MB’ FROM sysfiles WHERE name &#x3D; @LogicalFileName DROP TABLE DummyTrans SET NOCOUNT OFF</p><p>8、说明：更改某个表 exec sp_changeobjectowner ‘tablename’,’dbo’</p><p>9、存储更改全部表</p><p>CREATE PROCEDURE dbo.User_ChangeObjectOwnerBatch @OldOwner as NVARCHAR(128), @NewOwner as NVARCHAR(128) AS</p><p>DECLARE @Name    as NVARCHAR(128) DECLARE @Owner   as NVARCHAR(128) DECLARE @OwnerName   as NVARCHAR(128)</p><p>DECLARE curObject CURSOR FOR select ‘Name’    &#x3D; name, ‘Owner’    &#x3D; user_name(uid) from sysobjects where user_name(uid)&#x3D;@OldOwner order by name</p><p>OPEN   curObject FETCH NEXT FROM curObject INTO @Name, @Owner WHILE(@@FETCH_STATUS&#x3D;0) BEGIN</p><p>if @Owner&#x3D;@OldOwner begin set @OwnerName &#x3D; @OldOwner + ‘.’ + rtrim(@Name) exec sp_changeobjectowner @OwnerName, @NewOwner end – select @name,@NewOwner,@OldOwner</p><p>FETCH NEXT FROM curObject INTO @Name, @Owner END</p><p>close curObject deallocate curObject GO</p><p>10、SQL SERVER中直接循环写入数据 declare @i int set @i&#x3D;1 while @i&lt;30 begin insert into test (userid) values(@i) set @i&#x3D;@i+1 end</p><p> 案例： 有如下表，要求表中所有没有及格的成绩，在每次增长0.1的基础上，使他们刚好及格：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Name     score</span><br><span class="line"></span><br><span class="line">Zhangshan   80</span><br><span class="line"></span><br><span class="line">Lishi       59</span><br><span class="line"></span><br><span class="line">Wangwu      50</span><br><span class="line"></span><br><span class="line">Songquan    69</span><br></pre></td></tr></table></figure><p>while((select min(score) from tb_table)&lt;60)</p><p>begin</p><p>update tb_table set score &#x3D;score*1.01</p><p>where score&lt;60</p><p>if (select min(score) from tb_table)&gt;60</p><p>break</p><p>else</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">continue</span><br></pre></td></tr></table></figure><p>end</p><hr><h3 id="数据开发-经典"><a href="#数据开发-经典" class="headerlink" title="数据开发-经典"></a>数据开发-经典</h3><p>1.按姓氏笔画排序: Select * From TableName Order By CustomerName Collate Chinese_PRC_Stroke_ci_as &#x2F;&#x2F;从少到多</p><p>2.数据库加密: select encrypt(‘原始密码’) select pwdencrypt(‘原始密码’) select pwdcompare(‘原始密码’,’加密后密码’) &#x3D; 1–相同；否则不相同 encrypt(‘原始密码’) select pwdencrypt(‘原始密码’) select pwdcompare(‘原始密码’,’加密后密码’) &#x3D; 1–相同；否则不相同</p><p>3.取回表中字段: declare @list varchar(1000), @sql nvarchar(1000) select @list&#x3D;@list+’,’+<a href="http://b.name/">b.name</a> from sysobjects a,syscolumns b where <a href="http://a.id%[3Db.id/](http://3Db.id/)"><a href="http://a.id=b.id/">a.id&#x3D;b.id</a></a> and a.name&#x3D;’表A’ set @sql&#x3D;’select ‘+right(@list,len(@list)-1)+’ from 表A’ exec (@sql)</p><p>4.查看硬盘分区: EXEC master..xp_fixeddrives</p><p>5.比较A,B表是否相等: if (select checksum_agg(binary_checksum(*)) from A)</p><p>(select checksum_agg(binary_checksum(*)) from B) print ‘相等’ else print ‘不相等’</p><p>6.杀掉所有的事件探察器进程: DECLARE hcforeach CURSOR GLOBAL FOR SELECT ‘kill ‘+RTRIM(spid) FROM master.dbo.sysprocesses WHERE program_name IN(‘SQL profiler’,N’SQL 事件探查器’) EXEC sp_msforeach_worker ‘?’</p><p>7.记录搜索: 开头到N条记录 Select Top N * From 表</p><p>N到M条记录(要有主索引ID) Select Top M-N * From 表 Where ID in (Select Top M ID From 表) Order by ID Desc</p><p>N到结尾记录 Select Top N * From 表 Order by ID Desc</p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>例如1：一张表有一万多条记录，表的第一个字段 RecID 是自增长字段， 写一个SQL语句， 找出表的第31到第40个记录。</p><p>select top 10 recid from A where recid not in(select top 30 recid from A)</p><p>分析：如果这样写会产生某些问题，如果recid在表中存在逻辑索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select top 10 recid from A where……是从索引中查找，而后面的select top 30 recid from A则在数据表中查找，这样由于索引中的顺序有可能和数据表中的不一致，这样就导致查询到的不是本来的欲得到的数据。</span><br></pre></td></tr></table></figure><p>解决方案</p><p>1， 用order by select top 30 recid from A order by ricid 如果该字段不是自增长，就会出现问题</p><p>2， 在那个子查询中也加条件：select top 30 recid from A where recid&gt;-1</p><p>例2：查询表中的最后以条记录，并不知道这个表共有多少数据,以及表结构。 set @s &#x3D; ‘select top 1 * from T   where pid not in (select top ‘ + str(@count-1) + ‘ pid from  T)’</p><p>print @s      exec sp_executesql @s</p><p>9：获取当前数据库中的所有用户表 select Name from sysobjects where xtype&#x3D;’u’ and status&gt;&#x3D;0</p><p>10：获取某一个表的所有字段 select name from syscolumns where id&#x3D;object_id(‘表名’)</p><p>select name from syscolumns where id in (select id from sysobjects where type &#x3D; ‘u’ and name &#x3D; ‘表名’)</p><p>两种方式的效果相同</p><p>11：查看与某一个表相关的视图、存储过程、函数 select a.* from sysobjects a, syscomments b where <a href="http://a.id/">a.id</a> &#x3D; <a href="http://b.id/">b.id</a> and b.text like ‘%表名%’</p><p>12：查看当前数据库中所有存储过程 select name as 存储过程名称 from sysobjects where xtype&#x3D;’P’</p><p>13：查询用户创建的所有数据库 select * from master..sysdatabases D where sid not in(select sid from master..syslogins where name&#x3D;’sa’) 或者 select dbid, name AS DB_NAME from master..sysdatabases where sid &lt;&gt; 0x01</p><p>14：查询某一个表的字段和数据类型 select column_name,data_type from information_schema.columns where table_name &#x3D; ‘表名’</p><p>15：不同服务器数据库之间的数据操作</p><ul><li>-创建链接服务器</li></ul><p>exec sp_addlinkedserver   ‘ITSV ‘, ‘ ‘, ‘SQLOLEDB ‘, ‘远程服务器名或ip地址 ‘</p><p>exec sp_addlinkedsrvlogin ‘ITSV ‘, ‘false ‘,null, ‘用户名 ‘, ‘密码 ‘</p><ul><li>-查询示例</li></ul><p>select * from ITSV.数据库名.dbo.表名</p><ul><li>-导入示例</li></ul><p>select * into 表 from ITSV.数据库名.dbo.表名</p><ul><li>-以后不再使用时删除链接服务器</li></ul><p>exec sp_dropserver ‘ITSV ‘, ‘droplogins ‘</p><ul><li>-连接远程&#x2F;局域网数据(openrowset&#x2F;openquery&#x2F;opendatasource)</li><li>-1、openrowset</li><li>-查询示例</li></ul><p>select * from openrowset( ‘SQLOLEDB ‘, ‘sql服务器名 ‘; ‘用户名 ‘; ‘密码 ‘,数据库名.dbo.表名)</p><ul><li>-生成本地表</li></ul><p>select * into 表 from openrowset( ‘SQLOLEDB ‘, ‘sql服务器名 ‘; ‘用户名 ‘; ‘密码 ‘,数据库名.dbo.表名)</p><ul><li>-把本地表导入远程表</li></ul><p>insert openrowset( ‘SQLOLEDB ‘, ‘sql服务器名 ‘; ‘用户名 ‘; ‘密码 ‘,数据库名.dbo.表名)</p><p>select *from 本地表</p><ul><li>-更新本地表</li></ul><p>update b</p><p>set b.列A&#x3D;a.列A</p><p>from openrowset( ‘SQLOLEDB ‘, ‘sql服务器名 ‘; ‘用户名 ‘; ‘密码 ‘,数据库名.dbo.表名)as a inner join 本地表 b</p><p>on a.column1&#x3D;b.column1</p><ul><li>-openquery用法需要创建一个连接</li><li>-首先创建一个连接创建链接服务器</li></ul><p>exec sp_addlinkedserver   ‘ITSV ‘, ‘ ‘, ‘SQLOLEDB ‘, ‘远程服务器名或ip地址 ‘</p><ul><li>-查询</li></ul><p>select *</p><p>FROM openquery(ITSV, ‘SELECT * FROM 数据库.dbo.表名 ‘)</p><ul><li>-把本地表导入远程表</li></ul><p>insert openquery(ITSV, ‘SELECT * FROM 数据库.dbo.表名 ‘)</p><p>select * from 本地表</p><ul><li>-更新本地表</li></ul><p>update b</p><p>set b.列B&#x3D;a.列B</p><p>FROM openquery(ITSV, ‘SELECT * FROM 数据库.dbo.表名 ‘) as a</p><p>inner join 本地表 b on a.列A&#x3D;b.列A</p><ul><li>-3、opendatasource&#x2F;openrowset</li></ul><p>SELECT   *</p><p>FROM   opendatasource( ‘SQLOLEDB ‘, ‘Data Source&#x3D;ip&#x2F;ServerName;User ID&#x3D;登陆名;Password&#x3D;密码 ‘ ).test.dbo.roy_ta</p><ul><li>-把本地表导入远程表</li></ul><p>insert opendatasource( ‘SQLOLEDB ‘, ‘Data Source&#x3D;ip&#x2F;ServerName;User ID&#x3D;登陆名;Password&#x3D;密码 ‘).数据库.dbo.表名</p><p>select * from 本地表</p><hr><h3 id="SQL-Server基本函数"><a href="#SQL-Server基本函数" class="headerlink" title="SQL Server基本函数"></a>SQL Server基本函数</h3><p>1.字符串函数 长度与分析用</p><p>1,datalength(Char_expr) 返回字符串包含字符数,但不包含后面的空格 2,substring(expression,start,length) 取子串，字符串的下标是从“1”，start为起始位置，length为字符串长度，实际应用中以len(expression)取得其长度 3,right(char_expr,int_expr) 返回字符串右边第int_expr个字符，还用left于之相反 4,isnull( check_expression , replacement_value )如果check_expression為空，則返回replacement_value的值，不為空，就返回check_expression字符操作类</p><p>5,Sp_addtype 自定義數據類型 例如：EXEC sp_addtype birthday, datetime, ‘NULL’</p><p>6,set nocount {on|off} 使返回的结果中不包含有关受 Transact-SQL 语句影响的行数的信息。如果存储过程中包含的一些语句并不返回许多实际的数据，则该设置由于大量减少了网络流量，因此可显著提高性能。SET NOCOUNT 设置是在执行或运行时设置，而不是在分析时设置。 SET NOCOUNT 为 ON 时，不返回计数（表示受 Transact-SQL 语句影响的行数）。</p><p>SET NOCOUNT 为 OFF 时，返回计数</p><h3 id="常识"><a href="#常识" class="headerlink" title="常识"></a>常识</h3><p>在SQL查询中：from后最多可以跟多少张表或视图：256 在SQL语句中出现 Order by,查询时，先排序，后取 在SQL中，一个字段的最大容量是8000，而对于nvarchar(4000),由于nvarchar是Unicode码。</p><p>SQLServer2000同步复制技术实现步骤 </p><h4 id="一、-预备工作"><a href="#一、-预备工作" class="headerlink" title="一、 预备工作"></a>一、 预备工作</h4><p>1.发布服务器,订阅服务器都创建一个同名的windows用户,并设置相同的密码,做为发布快照文件夹的有效访问用户 –管理工具 –计算机管理 –用户和组 –右键用户 –新建用户 –建立一个隶属于administrator组的登陆windows的用户（SynUser） </p><p>2.在发布服务器上,新建一个共享目录,做为发布的快照文件的存放目录,操作: 我的电脑–D:\ 新建一个目录,名为: PUB –右键这个新建的目录 –属性–共享 –选择”共享该文件夹” –通过”权限”按纽来设置具体的用户权限,保证第一步中创建的用户(SynUser) 具有对该文件夹的所有权限</p><p>确定 </p><p>3.设置SQL代理(SQLSERVERAGENT)服务的启动用户(发布&#x2F;订阅服务器均做此设置) 开始–程序–管理工具–服务 –右键SQLSERVERAGENT –属性–登陆–选择”此账户” –输入或者选择第一步中创建的windows登录用户名（SynUser） –”密码”中输入该用户的密码 </p><p>4.设置SQL Server身份验证模式,解决连接时的权限问题(发布&#x2F;订阅服务器均做此设置) 企业管理器 –右键SQL实例–属性 –安全性–身份验证 –选择”SQL Server 和 Windows” –确定 </p><p>5.在发布服务器和订阅服务器上互相注册 企业管理器 –右键SQL Server组 –新建SQL Server注册… –下一步–可用的服务器中,输入你要注册的远程服务器名 –添加 –下一步–连接使用,选择第二个”SQL Server身份验证” –下一步–输入用户名和密码（SynUser） –下一步–选择SQL Server组,也可以创建一个新组 –下一步–完成 </p><p>6.对于只能用IP,不能用计算机名的,为其注册服务器别名（此步在实施中没用到） (在连接端配置,比如,在订阅服务器上配置的话,服务器名称中输入的是发布服务器的IP) 开始–程序–Microsoft SQL Server–客户端网络实用工具 –别名–添加 –网络库选择”tcp&#x2F;ip”–服务器别名输入SQL服务器名 –连接参数–服务器名称中输入SQL服务器ip地址 –如果你修改了SQL的端口,取消选择”动态决定端口”,并输入对应的端口号 </p><h4 id="二、-正式配置"><a href="#二、-正式配置" class="headerlink" title="二、 正式配置"></a>二、 正式配置</h4><p>1、配置发布服务器 打开企业管理器，在发布服务器（B、C、D）上执行以下步骤: </p><p>(1) 从[工具]下拉菜单的[复制]子菜单中选择[配置发布、订阅服务器和分发]出现配置发布和分发向导</p><p>(2) [下一步] 选择分发服务器 可以选择把发布服务器自己作为分发服务器或者其他sql的服务器（选择自己） </p><p>(3) [下一步] 设置快照文件夹 采用默认<a href="http://www.cnblogs.com/yshj/admin/file://servername/Pub">http://www.cnblogs.com/yshj/admin/file://servername/Pub</a> </p><p>(4) [下一步] 自定义配置 可以选择:是,让我设置分发数据库属性启用发布服务器或设置发布设置 否,使用下列默认设置（推荐） </p><p>(5) [下一步] 设置分发数据库名称和位置 采用默认值 </p><p>(6) [下一步] 启用发布服务器 选择作为发布的服务器 </p><p>(7) [下一步] 选择需要发布的数据库和发布类型 </p><p>(8) [下一步] 选择注册订阅服务器 </p><p>(9) [下一步] 完成配置 </p><p>2、创建出版物 发布服务器B、C、D上 </p><p>(1)从[工具]菜单的[复制]子菜单中选择[创建和管理发布]命令</p><p> (2)选择要创建出版物的数据库，然后单击[创建发布]</p><p> (3)在[创建发布向导]的提示对话框中单击[下一步]系统就会弹出一个对话框。对话框上的内容是复制的三个类型。我们现在选第一个也就是默认的快照发布(其他两个大家可以去看看帮助) </p><p>(4)单击[下一步]系统要求指定可以订阅该发布的数据库服务器类型, SQLSERVER允许在不同的数据库如 orACLE或ACCESS之间进行数据复制。 但是在这里我们选择运行”SQL SERVER 2000”的数据库服务器 </p><p>(5)单击[下一步]系统就弹出一个定义文章的对话框也就是选择要出版的表 注意: 如果前面选择了事务发布 则再这一步中只能选择带有主键的表 </p><p>(6)选择发布名称和描述 </p><p>(7)自定义发布属性 向导提供的选择: 是 我将自定义数据筛选,启用匿名订阅和或其他自定义属性 否 根据指定方式创建发布 （建议采用自定义的方式） </p><p>(8)[下一步] 选择筛选发布的方式 </p><p>(9)[下一步] 可以选择是否允许匿名订阅 </p><p>1)如果选择署名订阅,则需要在发布服务器上添加订阅服务器 方法: [工具]-&gt;[复制]-&gt;[配置发布、订阅服务器和分发的属性]-&gt;[订阅服务器] 中添加 否则在订阅服务器上请求订阅时会出现的提示:改发布不允许匿名订阅 如果仍然需要匿名订阅则用以下解决办法 [企业管理器]-&gt;[复制]-&gt;[发布内容]-&gt;[属性]-&gt;[订阅选项] 选择允许匿名请求订阅 </p><p>2)如果选择匿名订阅,则配置订阅服务器时不会出现以上提示 </p><p>(10)[下一步] 设置快照 代理程序调度 </p><p>(11)[下一步] 完成配置 当完成出版物的创建后创建出版物的数据库也就变成了一个共享数据库 有数据 srv1.库名..author有字段:id,name,phone, srv2.库名..author有字段:id,name,telphone,adress</p><p>要求： srv1.库名..author增加记录则srv1.库名..author记录增加 srv1.库名..author的phone字段更新，则srv1.库名..author对应字段telphone更新 –*&#x2F;</p><ul><li>-大致的处理步骤 –1.在 srv1 上创建连接服务器,以便在 srv1 中操作 srv2,实现同步 exec sp_addlinkedserver ‘srv2’,’’,’SQLOLEDB’,’srv2的sql实例名或ip’ exec sp_addlinkedsrvlogin ‘srv2’,’false’,null,’用户名’,’密码’ go –2.在 srv1 和 srv2 这两台电脑中,启动 msdtc(分布式事务处理服务),并且设置为自动启动 。我的电脑–控制面板–管理工具–服务–右键 Distributed Transaction Coordinator–属性–启动–并将启动类型设置为自动启动 go</li><li>-然后创建一个作业定时调用上面的同步处理存储过程就行了</li></ul><p>企业管理器 –管理 –SQL Server代理 –右键作业 –新建作业 –”常规”项中输入作业名称 –”步骤”项 –新建 –”步骤名”中输入步骤名 –”类型”中选择”Transact-SQL 脚本(TSQL)” –”数据库”选择执行命令的数据库 –”命令”中输入要执行的语句: exec p_process –确定 –”调度”项 –新建调度 –”名称”中输入调度名称 –”调度类型”中选择你的作业执行安排 –如果选择”反复出现” –点”更改”来设置你的时间安排</p><p>然后将SQL Agent服务启动,并设置为自动启动,否则你的作业不会被执行</p><p>设置方法: 我的电脑–控制面板–管理工具–服务–右键 SQLSERVERAGENT–属性–启动类型–选择”自动启动”–确定.</p><ul><li>-3.实现同步处理的方法2,定时同步</li><li>-在srv1中创建如下的同步处理存储过程 create proc p_process as –更新修改过的数据 update b set <a href="http://name%[3Di.name/](http://3Di.name/)"><a href="http://name=i.name/">name&#x3D;i.name</a></a>,telphone&#x3D;i.telphone from srv2.库名.dbo.author b,author i where <a href="http://b.id%[3Di.id/](http://3Di.id/)"><a href="http://b.id=i.id/">b.id&#x3D;i.id</a></a> and (<a href="http://b.name/">b.name</a> &lt;&gt; <a href="http://i.name/">i.name</a> or b.telphone &lt;&gt; i.telphone)</li><li>-插入新增的数据 insert srv2.库名.dbo.author(id,name,telphone) select id,name,telphone from author i where not exists( select * from srv2.库名.dbo.author where <a href="http://id%[3Di.id/](http://3Di.id/)"><a href="http://id=i.id/">id&#x3D;i.id</a></a>)</li><li>-删除已经删除的数据(如果需要的话) delete b from srv2.库名.dbo.author b where not exists( select * from author where <a href="http://id%[3Db.id/](http://3Db.id/)"><a href="http://id=b.id/">id&#x3D;b.id</a></a>) go</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;[南月晨的blog](&lt;a href=&quot;https://leiyu-code.github.io/&quot;&gt;南月晨的博客 (leiyu-code.github.io)&lt;/a&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;leiyu-code.github.io&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.linuxcool.com/&quot;&gt;Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;SQL语句大全&quot;&gt;&lt;a href=&quot;#SQL语句大全&quot; class=&quot;headerlink&quot; title=&quot;SQL语句大全&quot;&gt;&lt;/a&gt;SQL语句大全&lt;/h1&gt;&lt;h3 id=&quot;一、基础&quot;&gt;&lt;a href=&quot;#一、基础&quot; class=&quot;headerlink&quot; title=&quot;一、基础&quot;&gt;&lt;/a&gt;一、基础&lt;/h3&gt;&lt;p&gt;1、说明：创建数据库 CREATE DATABASE database-name &lt;/p&gt;
&lt;p&gt;2、说明：删除数据库 drop database dbname &lt;/p&gt;
&lt;p&gt;3、说明：备份sql server — 创建 备份数据的 device USE master EXEC sp_addumpdevice ‘disk’, ‘testBack’, ‘c:\mssql7backup\MyNwind_1.dat’ — 开始 备份 BACKUP DATABASE pubs TO testBack &lt;/p&gt;
&lt;p&gt;4、说明：创建新表 create table tabname(col1 type1 [not null] [primary key],col2 type2 [not null],..)&lt;/p&gt;
&lt;p&gt;根据已有的表创建新表： A：create table tab_new like tab_old (使用旧表创建新表) B：create table tab_new as select col1,col2… from tab_old definition only &lt;/p&gt;
&lt;p&gt;5、说明：删除新表 drop table tabname &lt;/p&gt;
&lt;p&gt;6、说明：增加一个列 Alter table tabname add column col type 注：列增加后将不能删除。DB2中列加上后数据类型也不能改变，唯一能改变的是增加varchar类型的长度。 &lt;/p&gt;
&lt;p&gt;7、说明：添加主键： Alter table tabname add primary key(col) 说明：删除主键： Alter table tabname drop primary key(col) &lt;/p&gt;
&lt;p&gt;8、说明：创建索引：create [unique] index idxname on tabname(col….) 删除索引：drop index idxname 注：索引是不可更改的，想更改必须删除重新建。 &lt;/p&gt;
&lt;p&gt;9、说明：创建视图：create view viewname as select statement 删除视图：drop view viewname &lt;/p&gt;</summary>
    
    
    
    <category term="database" scheme="http://example.com/categories/database/"/>
    
    
    <category term="sql" scheme="http://example.com/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>vlookup进阶_跨文件查询</title>
    <link href="http://example.com/2023/06/15/vlookup%E8%BF%9B%E9%98%B6_%E8%B7%A8%E6%96%87%E4%BB%B6%E5%8C%B9%E9%85%8D/"/>
    <id>http://example.com/2023/06/15/vlookup%E8%BF%9B%E9%98%B6_%E8%B7%A8%E6%96%87%E4%BB%B6%E5%8C%B9%E9%85%8D/</id>
    <published>2023-06-15T07:00:06.000Z</published>
    <updated>2023-06-15T06:41:21.483Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p><p>leiyu-code.github.io</p><p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p><h2 id="vlookup进阶-跨文件查询"><a href="#vlookup进阶-跨文件查询" class="headerlink" title="vlookup进阶_跨文件查询"></a>vlookup进阶_跨文件查询</h2><p><strong>How use vlookup function find data from other excel file</strong></p><p>​          <em><strong>将两个excel文件放在同一个文件夹里</strong></em></p><p>​         <em><strong>为了以后匹配出来的数据的正确性，最好不要在完成数据匹配后再挪动原始文件</strong></em></p><p>​         <em><strong>在这里，vlookup函数的匹配范围是匹配文件的绝对路径</strong></em></p><p>​        例：</p><p>&#x3D;VLOOKUP(B5,’C:\Users\Administrator\Desktop[vlookup基础实验表详细情况.xlsx]Sheet1’!$A$1:$C$10,3,FALSE)</p><span id="more"></span><p>将文件放在同一个文件夹，并在以后保持不动</p><p><a href="https://imgse.com/i/pCuO3zF"><img src="https://s1.ax1x.com/2023/06/15/pCuO3zF.png" alt="pCuO3zF.png"></a></p><p>选择匹配范围的时候，选择要匹配的文件相应的范围</p><p><a href="https://imgse.com/i/pCuO1RU"><img src="https://s1.ax1x.com/2023/06/15/pCuO1RU.png" alt="pCuO1RU.png"></a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;[南月晨的blog](&lt;a href=&quot;https://leiyu-code.github.io/&quot;&gt;南月晨的博客 (leiyu-code.github.io)&lt;/a&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;leiyu-code.github.io&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.linuxcool.com/&quot;&gt;Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;vlookup进阶-跨文件查询&quot;&gt;&lt;a href=&quot;#vlookup进阶-跨文件查询&quot; class=&quot;headerlink&quot; title=&quot;vlookup进阶_跨文件查询&quot;&gt;&lt;/a&gt;vlookup进阶_跨文件查询&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;How use vlookup function find data from other excel file&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​          &lt;em&gt;&lt;strong&gt;将两个excel文件放在同一个文件夹里&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;​         &lt;em&gt;&lt;strong&gt;为了以后匹配出来的数据的正确性，最好不要在完成数据匹配后再挪动原始文件&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;​         &lt;em&gt;&lt;strong&gt;在这里，vlookup函数的匹配范围是匹配文件的绝对路径&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;​        例：&lt;/p&gt;
&lt;p&gt;&amp;#x3D;VLOOKUP(B5,’C:\Users\Administrator\Desktop[vlookup基础实验表详细情况.xlsx]Sheet1’!$A$1:$C$10,3,FALSE)&lt;/p&gt;</summary>
    
    
    
    <category term="excel" scheme="http://example.com/categories/excel/"/>
    
    
    <category term="function" scheme="http://example.com/tags/function/"/>
    
    <category term="vlookup" scheme="http://example.com/tags/vlookup/"/>
    
  </entry>
  
  <entry>
    <title>Excel小技巧_按数值自动填充颜色</title>
    <link href="http://example.com/2023/06/15/Excel%E5%B0%8F%E6%8A%80%E5%B7%A7_%E6%8C%89%E6%95%B0%E5%80%BC%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85%E9%A2%9C%E8%89%B2/"/>
    <id>http://example.com/2023/06/15/Excel%E5%B0%8F%E6%8A%80%E5%B7%A7_%E6%8C%89%E6%95%B0%E5%80%BC%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85%E9%A2%9C%E8%89%B2/</id>
    <published>2023-06-15T02:33:06.000Z</published>
    <updated>2023-06-15T03:29:05.551Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p><p>leiyu-code.github.io</p><p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p><h2 id="Excel小技巧-按数值自动填充颜色"><a href="#Excel小技巧-按数值自动填充颜色" class="headerlink" title="Excel小技巧_按数值自动填充颜色"></a>Excel小技巧_按数值自动填充颜色</h2><p><strong>Excel Tips : Fill the color according to the number</strong></p><p><em><strong>Tips Code:    [蓝色][&gt;&#x3D;60];[红色][&lt;60]</strong></em></p><span id="more"></span><p>假定需用红色字体显示60以下分数，蓝色字体显示60以上分数。</p><p>点击填充颜色的表格，右键单击设置单元格格式或者</p><p>按Ctrl+1，设置单元格格式→自定义，类型输入框中输入：</p><p>[蓝色][&gt;&#x3D;60];[红色][&lt;60]</p><p><a href="https://imgse.com/i/pCusVRU"><img src="https://s1.ax1x.com/2023/06/15/pCusVRU.png" alt="pCusVRU.png"></a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;[南月晨的blog](&lt;a href=&quot;https://leiyu-code.github.io/&quot;&gt;南月晨的博客 (leiyu-code.github.io)&lt;/a&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;leiyu-code.github.io&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.linuxcool.com/&quot;&gt;Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Excel小技巧-按数值自动填充颜色&quot;&gt;&lt;a href=&quot;#Excel小技巧-按数值自动填充颜色&quot; class=&quot;headerlink&quot; title=&quot;Excel小技巧_按数值自动填充颜色&quot;&gt;&lt;/a&gt;Excel小技巧_按数值自动填充颜色&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Excel Tips : Fill the color according to the number&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Tips Code:    [蓝色][&amp;gt;&amp;#x3D;60];[红色][&amp;lt;60]&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="excel" scheme="http://example.com/categories/excel/"/>
    
    
    <category term="Tips" scheme="http://example.com/tags/Tips/"/>
    
  </entry>
  
  <entry>
    <title>工作笔记_离线驱动导入工具CeoMSX</title>
    <link href="http://example.com/2023/06/13/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0_%E9%A9%B1%E5%8A%A8%E5%B7%A5%E5%85%B7%E8%AE%A9%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%9FG%E8%B5%B7%E6%9D%A5%E5%90%A7/"/>
    <id>http://example.com/2023/06/13/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0_%E9%A9%B1%E5%8A%A8%E5%B7%A5%E5%85%B7%E8%AE%A9%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%9FG%E8%B5%B7%E6%9D%A5%E5%90%A7/</id>
    <published>2023-06-13T09:06:06.000Z</published>
    <updated>2023-06-13T09:07:02.175Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p><p>leiyu-code.github.io</p><p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p><h2 id="工作笔记-离线驱动导入工具CeoMSX"><a href="#工作笔记-离线驱动导入工具CeoMSX" class="headerlink" title="工作笔记_离线驱动导入工具CeoMSX"></a>工作笔记_离线驱动导入工具CeoMSX</h2><p><strong>How Replace the computer hardware without renstalling the system</strong></p><p><strong>Come on Use CeoMsx</strong></p><p>当您遇到系统无法安装，数据无法读取，怎么办？答案是肯定的，USM是您的首选。USM内置SRS方案能帮助您在PE下识别读取硬盘重要数据，CEO_MSX能帮助您给正常系统导入磁盘控制器驱动从而顺利安装系统，还可以帮助你在换电脑硬件的时候不用重新安装操作系统，甚至能为您导入服务器raid驱动。</p><span id="more"></span><p> 。USM内置SRS方案能帮助您在PE下识别读取硬盘重要数据，CEO_MSX能帮助您给正常系统导入磁盘控制器驱动从而顺利安装系统。若遇到不支持的设备，请第一时间联系我，反馈给我，我们将免费为您开启VIP绿色通道，我们将以最快的速度适配您的设备。  </p><p> 驱动收集原则，系统自身能支持的尽量用系统自带的，确保成功率。(比如NT6.x原生支持AHCI规范，比如Win8之后系统默认  支持USB3.0，比如Win8.1之后的系统默认支持Nvme)  备注：驱动整理收集内容公开，不限任何组织或个人使用，但需注明来源，否则我们保留拒绝使用的权利</p><p> 支持XP&#x2F;Vista&#x2F;Win7&#x2F;Win8&#x2F;Win8.1&#x2F;Win10及对应的服务器版本     </p><p>几个静默参数，方便第三方开发使用，具体参数说明如下（参数不区分大小写）:  </p><p>&#x2F;g 采用通用匹配方案默认静默导入(所有盘符下存在的系统都导入)  </p><p>&#x2F;e 采用精确匹配方案默认静默导入(所有盘符下存在的系统都导入)(默认即为&#x2F;e模式，可省略)  </p><p>&#x2F;c: 指定盘符静默导入&#x2F;安装  </p><p>&#x2F;AHCI:No 在Nt6系统中不导入AHCI驱动，若需导入请使用</p><p>&#x2F;AHCI:Yes参数(没有指定此参数时，默认为No)(2019-06-18版新参数)  CEO  MassStorage and XHCI Drivers(CeoMSX)  支持磁盘控制器驱动及XHCI驱动(SRS+USB3.0&#x2F;3.1)离线导入，其中“通用匹配”就是封装系统时使用的导入SRS方案。  </p><p>不支持处理当前系统(比如你启动的是C盘的系统，就不能在C盘系统工作下去处理C盘，但是你可以启动C盘的系统去处理D盘的系统。不要问我支不支持PE，我就不告诉你)  特别注意使用前提：其中USB3.0&#x2F;3.1只对win7做完整支持，并且只有精确匹配方案无通用方案，原因intel usb3.0分版本。已经安装好的系统，导入USB3.0&#x2F;3.1驱动可能无法直接生效，需要触发设备管理器的自动刷新。因此建议在系统开始部署之前就导入，也就是说你如果在PE下装GHO，在GHO恢复完就需要用CeoMSX导入USB3.0&#x2F;3.1驱动(原版系统请用PE下的安装工具安装之后再导入)。  支持多ID列表：  （演示intel usb3.0与asm  usb3.1同机）  <img src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image001.png" alt="img">     <img src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png" alt="img">     <img src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image003.png" alt="img">  <strong>3.png</strong> (64.35  KB, 下载次数: 261)  <a href="https://www.sysceo.com/forum/forum.php?mod=attachment&aid=MjU2Nzd8NmZmZWY0ZWJ8MTY4NjY0NTA1NXwwfDQ3Mzk0&nothumb=yes">下载附件</a> <a href="javascript:;">保存到相册</a>  2020-8-15 16:01 上传     <img src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image004.png" alt="img">     <img src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image005.png" alt="img">     <img src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image006.png" alt="img">     <img src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image007.png" alt="img">     <img src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image008.png" alt="img">     <img src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image009.png" alt="img">     <img src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image010.png" alt="img">  </p><p>来自 <a href="https://www.sysceo.com/forum/thread-47394-1-1.html">https://www.sysceo.com/forum/thread-47394-1-1.html</a> </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;[南月晨的blog](&lt;a href=&quot;https://leiyu-code.github.io/&quot;&gt;南月晨的博客 (leiyu-code.github.io)&lt;/a&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;leiyu-code.github.io&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.linuxcool.com/&quot;&gt;Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;工作笔记-离线驱动导入工具CeoMSX&quot;&gt;&lt;a href=&quot;#工作笔记-离线驱动导入工具CeoMSX&quot; class=&quot;headerlink&quot; title=&quot;工作笔记_离线驱动导入工具CeoMSX&quot;&gt;&lt;/a&gt;工作笔记_离线驱动导入工具CeoMSX&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;How Replace the computer hardware without renstalling the system&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Come on Use CeoMsx&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当您遇到系统无法安装，数据无法读取，怎么办？答案是肯定的，USM是您的首选。USM内置SRS方案能帮助您在PE下识别读取硬盘重要数据，CEO_MSX能帮助您给正常系统导入磁盘控制器驱动从而顺利安装系统，还可以帮助你在换电脑硬件的时候不用重新安装操作系统，甚至能为您导入服务器raid驱动。&lt;/p&gt;</summary>
    
    
    
    <category term="worknote" scheme="http://example.com/categories/worknote/"/>
    
    
    <category term="drive" scheme="http://example.com/tags/drive/"/>
    
    <category term="tools" scheme="http://example.com/tags/tools/"/>
    
  </entry>
  
</feed>
