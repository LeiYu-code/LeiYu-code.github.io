<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>解决git报错port 22</title>
    <url>/2024/12/26/%E8%A7%A3%E5%86%B3git22port%E9%94%99/</url>
    <content><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p>
<p><a href="http://leiyu-code.github.io">leiyu-code.github.io</a></p>
<p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p>
<h1>【git】解决git报错:ssh:connect to host <a href="http://github.com">github.com</a> port 22: Connection timed out 亲测有效</h1>
<p><strong>简介：</strong> 【git】解决git报错:ssh:connect to host <a href="http://github.com">github.com</a> port 22: Connection timed out 亲测有效</p>
<p>如题，git使用中突然报错</p>
<p>ssh:connect to host <a href="http://github.com">github.com</a> port 22: Connection timed out</p>
<p>通过查阅各种资料，得知原因可能是由于电脑的防火墙或者其他网络原因导致ssh连接方式 端口22被封锁。</p>
<h3 id="解决方法">解决方法</h3>
<h3 id="一：抛弃ssh连接方式，使用http连接。">一：抛弃ssh连接方式，使用http连接。</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --local -e</span><br><span class="line">将配置文件的url = git@github.com:username/repo.git一行改为：url = https://github.com/username/repo.git</span><br></pre></td></tr></table></figure>
<h3 id="方法二：如果22号端口不行，那就换一个端口">方法二：如果22号端口不行，那就换一个端口</h3>
<h3 id="进入-ssh文件夹">进入.ssh文件夹</h3>
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/z7drxuznvgnea_e581f158a2904c7597a852544116edf9.png?x-oss-process=image%2Fresize%2Cw_1400%2Fformat%2Cwebp" alt="img"></p>
<p>创建一个config文件</p>
<p>将下面的内容复制进去</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">User git</span><br><span class="line">Hostname ssh.github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line">Port 443</span><br><span class="line"> </span><br><span class="line">Host gitlab.com</span><br><span class="line">Hostname altssh.gitlab.com</span><br><span class="line">User git</span><br><span class="line">Port 443</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>
<p>保存退出</p>
<p>检查是否成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com </span><br></pre></td></tr></table></figure>
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/z7drxuznvgnea_100fca1cccc640c5a97a74b802cf6594.png?x-oss-process=image%2Fresize%2Cw_1400%2Fformat%2Cwebp" alt="img"></p>
<p>这里要根据它的提示操作，有个地方要输入yes</p>
<p>此时大功告成啦</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>wrong</tag>
        <tag>port</tag>
      </tags>
  </entry>
  <entry>
    <title>VS CODE配置c/c++扩展</title>
    <url>/2024/12/16/VS%20CODE%E9%85%8D%E7%BD%AEc++%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p>
<p><a href="http://leiyu-code.github.io">leiyu-code.github.io</a></p>
<p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p>
<h1><strong>VS CODE配置c/c++扩展</strong></h1>
<ol>
<li>
<p>安装扩展</p>
<ul>
<li>首先要安装 “C/C++” 扩展。打开 VS Code，点击左侧的 “扩展” 图标（看起来像方块的拼图），在搜索框中输入 “C/C++”，找到由 Microsoft 发布的 “C/C++” 扩展并安装。这个扩展提供了代码导航、语法检查、调试支持等功能，是调试 C 语言程序的基础。</li>
</ul>
</li>
<li>
<p>配置编译器</p>
<ul>
<li>
<p>Windows 系统</p>
<ul>
<li>安装 MinGW - W64。可以从官方网站（<a href="https://mingw">https://mingw</a> - <a href="https://w64.org/doku.php">w64.org/doku.php</a>）下载安装程序。在安装过程中，注意选择合适的架构（如 x86_64 或 i686）和版本（如 SEH 或 DW2 异常处理）。</li>
<li>将 MinGW - W64 的安装目录下的<code>bin</code>文件夹路径添加到系统环境变量。在 “控制面板” - &gt;“系统和安全” - &gt;“系统” - &gt;“高级系统设置” - &gt;“环境变量” 中，在 “系统变量” 部分找到 “Path” 变量，点击 “编辑”，然后添加 MinGW - W64 的<code>bin</code>路径，例如<code>C:\mingw - w64\mingw64\bin</code>。</li>
</ul>
<span id="more"></span>
</li>
<li>
<p>Linux 系统</p>
<ul>
<li>大多数 Linux 发行版都自带 GCC 编译器。可以通过在终端中输入<code>gcc - v</code>来检查是否已经安装。如果没有安装，可以使用包管理器进行安装。例如，在 Ubuntu 系统中，使用命令<code>sudo apt - get install gcc</code>进行安装。</li>
</ul>
</li>
<li>
<p>MacOS 系统</p>
<ul>
<li>MacOS 也可以使用 GCC 或者 Clang 编译器。Clang 通常是 Xcode 自带的，可以通过在终端中输入<code>clang - v</code>来检查是否已安装。如果需要安装 GCC，可以使用 Homebrew（<a href="https://brew.sh/%EF%BC%89%E7%AD%89%E5%B7%A5%E5%85%B7%E8%BF%9B%E8%A1%8C%E5%AE%89%E8%A3%85%EF%BC%8C%E5%91%BD%E4%BB%A4%E4%B8%BA">https://brew.sh/）等工具进行安装，命令为</a><code>brew install gcc</code>。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>创建调试配置文件（launch.json）</p>
<ul>
<li>
<p>在 VS Code 中打开你的 C 语言项目文件夹。</p>
</li>
<li>
<p>点击左侧的 “运行和调试” 图标（看起来像一个虫子），然后点击 “创建一个 launch.json 文件”。</p>
</li>
<li>
<p>在弹出的调试器类型选择框中，选择 “C++（GDB/LLDB）”。这会生成一个基本的<code>launch.json</code>文件，它用于配置调试会话。</p>
</li>
<li>
<p>编辑</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">launch.json</span><br></pre></td></tr></table></figure>
<p>文件，以下是一个简单的示例：</p>
<p>json</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: gcc - 构建和调试活动文件&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;你的gdb路径&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;为 gdb 启用整齐打印&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;- enable - pretty - printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   - 对于`miDebuggerPath`字段，在Windows系统下如果安装了MinGW - W64，它可能是`C:\mingw - w64\mingw64\bin\gdb.exe`；在Linux系统下通常是`/usr/bin/gdb`；在MacOS系统下如果使用GCC可能是`/usr/local/bin/gdb`（如果是通过Homebrew安装）或者其他路径（具体要看安装情况）。</span><br><span class="line">4. 编写并调试C语言代码</span><br><span class="line">   - 在VS Code中打开一个C语言文件，编写代码。例如：</span><br><span class="line">     ```c</span><br><span class="line">     #include &lt;stdio.h&gt;</span><br><span class="line">     int main()</span><br><span class="line">     &#123;</span><br><span class="line">       int a = 10;</span><br><span class="line">       int b = 20;</span><br><span class="line">       int sum = a + b;</span><br><span class="line">       printf(&quot;两数之和为：%d\n&quot;, sum);</span><br><span class="line">       return 0;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>设置断点。在代码行号的左侧空白处点击，会出现一个红点，这就是断点。例如，在<code>printf(&quot;两数之和为：%d\n&quot;, sum);</code>这一行设置断点。</li>
<li>点击左侧 “运行和调试” 图标，然后点击绿色的 “启动调试” 按钮（或者使用快捷键<code>F5</code>）。</li>
<li>此时程序会运行到断点处停止，你可以在调试控制台（可以通过 “视图” - &gt;“调试控制台” 打开）查看变量的值，也可以使用调试工具栏（有继续、单步执行等按钮）来逐步执行程序，观察程序的运行状态。</li>
</ul>
]]></content>
      <categories>
        <category>vs code</category>
      </categories>
      <tags>
        <tag>software</tag>
        <tag>extentions</tag>
      </tags>
  </entry>
  <entry>
    <title>佳软推荐——最快的文件搜索工具Everything</title>
    <url>/2024/12/13/%E4%BD%B3%E8%BD%AF%E6%8E%A8%E8%8D%90%E2%80%94%E2%80%94%E6%9C%80%E5%BF%AB%E7%9A%84%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2%E5%B7%A5%E5%85%B7Everything/</url>
    <content><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p>
<p><a href="http://leiyu-code.github.io">leiyu-code.github.io</a></p>
<p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p>
<p><em><strong>实用场景（超市  网站前台）</strong></em></p>
<p><em><strong>在一般的超市网站上，动辄就要更新成千上万个图片，一般都是按照商品条码进行搜索，windows自带的搜索半天都不见得能找出来，但是用everything这个软件一瞬间就能把这个商品找出来，而且预览缩略图也能在右边的预览框里显示</strong></em></p>
<ol>
<li>
<p>软件基本信息</p>
<ul>
<li>Everything 是一款由 VoidTools 开发的文件搜索工具，它适用于 Windows 操作系统。其特点是搜索速度极快，可以在短时间内索引和搜索本地硬盘、外置硬盘、USB 设备等存储介质中的文件和文件夹。</li>
</ul>
</li>
<li>
<p>工作原理</p>
<ul>
<li>它通过建立文件索引来实现快速搜索。当软件首次运行时，它会扫描指定的磁盘分区或者整个硬盘，记录下每个文件的名称、路径、大小、日期等信息，并将这些信息存储在一个数据库中。之后，当用户进行搜索时，它不是像 Windows 自带的搜索那样逐个文件夹去查找，而是直接在这个已经建立好的数据库中进行快速匹配，所以能够快速地返回搜索结果。</li>
</ul>
<span id="more"></span>
</li>
<li>
<p>功能特点</p>
<ul>
<li><strong>快速搜索</strong>：例如，在一个拥有大量文件（如数百万个文件）的硬盘上，用户可以在输入文件名的几秒钟内就得到搜索结果。比如，要找一份名为 “项目报告.docx” 的文件，只需在搜索框中输入文件名的一部分，如 “项目”，它就能快速地将包含 “项目” 字样的所有文件列出来。</li>
<li><strong>支持通配符搜索</strong>：可以使用通配符 “<em>” 和 “?” 来进行模糊搜索。“</em>” 代表任意多个字符，“?” 代表一个任意字符。例如，搜索 “*.jpg” 可以找到所有的 JPEG 图片文件；搜索 “te?t.txt” 可以找到类似 “test.txt”“text.txt” 等文件名符合条件的文件。</li>
<li><strong>高级搜索功能</strong>：可以根据文件大小、日期、文件属性等条件进行搜索。如果想找一个在特定日期范围内修改过的文件，或者文件大小大于一定值的文件，都可以通过软件的高级搜索选项来实现。</li>
<li><strong>实时更新索引</strong>：当文件系统发生变化，如新建文件、删除文件、重命名文件时，Everything 会自动更新索引，以确保搜索结果的准确性。不过，在某些情况下，如果索引更新不及时，可以手动刷新索引。</li>
</ul>
</li>
<li>
<p>软件使用场景</p>
<ul>
<li><strong>办公场景</strong>：对于办公人员来说，当电脑中有大量的文档、表格、演示文稿等文件时，能够快速找到所需文件可以大大提高工作效率。<em><strong>比如，在一个广告公司的设计师电脑上，有多年积累的各种设计素材、客户项目文件等，使用 Everything 可以快速定位到某个特定的设计源文件或者客户要求修改的文档。</strong></em></li>
<li><strong>技术支持场景</strong>：对于计算机技术人员，在处理客户电脑问题或者进行系统维护时，需要快速查找系统文件、驱动程序文件等，Everything 就成为一个很有用的工具。<em><strong>例如，查找一个特定版本的设备驱动程序文件，通过快速搜索就可以定位其位置，方便进行更新或者故障排除。</strong></em></li>
</ul>
</li>
</ol>
<hr>
<p><strong>总结：用Everything替代windows内置的搜索工具是最好的选择，可以更有效、更快速地定位想要找的项目或文件</strong></p>
]]></content>
      <categories>
        <category>software</category>
      </categories>
      <tags>
        <tag>everything</tag>
        <tag>searth</tag>
      </tags>
  </entry>
  <entry>
    <title>一个小数点的故事</title>
    <url>/2024/11/12/%E4%B8%80%E4%B8%AA%E5%B0%8F%E6%95%B0%E7%82%B9%E7%9A%84%E6%95%85%E4%BA%8B/</url>
    <content><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p>
<p>leiyu-code.github.io</p>
<p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p>
<p>前几天发了一个牢骚：</p>
<p><img src="https://why-image-1300252878.cos.ap-chengdu.myqcloud.com/img/20220716/20241111201609.png" alt="img"></p>
<p>本来只是单纯的吐槽一下，但是好多人对其中的细节比较感兴趣。</p>
<p>大家都是搞技术的嘛，对于“踩 BUG”这种喜闻乐见的事情，有兴趣是很正常的。</p>
<p>其实我这个 BUG，其实严格意义上不能叫做 BUG，因为和程序无关，甚至和技术的关系都不算大。从标题上你也能猜出来，是和一个业务参数相关。</p>
<p>但是在这个过程中，因为我是整个事件全程的亲历者，所以现在回看这个事情，我还是有一些思考在里面的。</p>
<p>我觉得这是一个程序员会遇到的“典型事件”。</p>
<span id="more"></span>

<p>那就用这篇文章一起复盘一下吧。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h2><p>要说明这个问题的背景，甚至不需要一个具体的业务场景，只需要围绕着以下这个非常常见的利息计算公式，就可以说明问题的起因：</p>
<blockquote>
<p>利息&#x3D;计息金额*日利率。<br>日利率&#x3D;年利率&#x2F;360</p>
</blockquote>
<p>由于日利率的计算，涉及到除法，在对应需求第一次开发时，业务的要求是日利率保存 7 位小数。</p>
<p>在程序中，年利率和日利率是两个字段分别保存的，日利率在初始化的时候就算好落库了，后续程序直接取这个算好的日利率就行了。</p>
<p>系统上线，相安无事。</p>
<p>跑了一段时间后，业务又提来一个需求：当前的精度不够，需要调整到 11 为小数。</p>
<p>你不用好奇歪师傅这边到底是什么业务场景，反正我去看了业务数据，需求是合理的，那就把需求接过来干就行了。</p>
<p>保存 7 位小数和 11 位小数，大家都是搞开发的，肯定也知道这个就是一个小改动，很快就能搞定。</p>
<p>事实也是如此，虽然之前的需求对应的代码不是我写的，但是我看过代码，清楚的知道改动点在哪，所以很快就开发完成。</p>
<p>前面说了，这个需求之前在线上按照 7 位小数跑了一段时间，所以存在一些存量配置。</p>
<p>针对这些存量数据，在需求评审会议上的时候，我提了一句：存量配置怎么处理呢？</p>
<p>业务答复：这次需求上线的时候，你按照 11 位小数重新算好，然后写 SQL 更新一下就行。</p>
<p>我心里一盘算：计算公式明确，年利率我也有，算一把，没啥问题。</p>
<p>就答应了。</p>
<p>然后，不出意外的出意外了。</p>
<p>假设年利率是 2.5%，除以 360 之后，保留 11 位小数，应该是 0.00006944444。</p>
<p>而我不知道当时为什么手抖了，在 SQL 里面写成了 0.00069444444。</p>
<p>我给你对比一下：</p>
<blockquote>
<p>0.00006944444<br>0.00069444444</p>
</blockquote>
<p>相当于我写出来的日利率被扩大了十倍。</p>
<p>然后再回头看看这个公式：</p>
<blockquote>
<p>利息&#x3D;计息金额*日利率</p>
</blockquote>
<p>日利率被扩大十倍，那么对应的计提金额也会被扩大十倍。</p>
<p>这就是问题的背景。</p>
<p>一个单纯的人为失误，和程序没有任何关系，所以严格意义上不属于程序 BUG。</p>
<p>但是这个问题确实是足够低级。</p>
<h2 id="为什么没被发现？"><a href="#为什么没被发现？" class="headerlink" title="为什么没被发现？"></a><strong>为什么没被发现？</strong></h2><p>那么这个错误的 SQL 是怎么通过代码评审、测试验证这两道关卡被带到生产环节的呢？</p>
<p>首先，这一次提交的代码，压根就没有评审环节。</p>
<p>我有代码提交权限，也有代码审核权限。所以我自己提交，自己就审核通过了。</p>
<p>其实这个需求应该是组里面另外一个小伙伴来做，但是当时他被调到其他组了。</p>
<p>他还在我们组的时候，我们的合作模式是他提交代码，我进行审核。</p>
<p>如果有这个环节，我觉得我有 50% 的几率发现问题。</p>
<p>为什么是 50% 呢？</p>
<p>因为这取决于我审核代码时是否有正在处理其他的事情，如果有其他事情处理，我可能会形式主义的看上几眼。如果没有其他事情，而这次提交的代码量又不大的话，我基本上都会认真的过一下提交的内容。</p>
<p>通过代码评审之后，接下来就应该是测试环节。</p>
<p>测试主要关注的是精度从 7 位变成 11 位之后，最终计算出来的利息是否符合预期。</p>
<p>他测试时是走了整个业务的全流程。</p>
<p>在“全流程”中，这个 11 位精度的日利率，是在页面配置年利率的时候通过程序自动计算出来的，不会错的。</p>
<p>而他在验证 SQL 语句的时候，测试环境又没有生产环境的配置，所以他拿着我提供的 SQL，只能保证写的语法没问题，能正常执行，并不能确保里面数据的正确性。</p>
<p>而我也记得很清楚，我当时给他说过：你执行一下 SQL 不报错就行，值的正确性，我来保证。</p>
<p>而且戏剧性的是，测试同事很仔细的去看了值，他去数了确实是 11 位小数。但是可惜，站在他的视角，他发现不了值被扩大了十倍。</p>
<p>所以，测试环节也没有发现这个问题：</p>
<blockquote>
<p>0.00006944444<br>0.00069444444</p>
</blockquote>
<p>就带着上生产了。</p>
<p>一个问题正常来说不应该被带上生产，但是我们确实不能保证测试环节一定能把所有问题都测出来，所以新项目、新迭代的生产验证也是非常有必要的。</p>
<p>这个我们也做了。</p>
<p>按理来说，生产上的数据已经是错误的了，而且是一个“利息金额扩大十倍”的明显的错误，如果主动去做了数据验证，应该能被发现才对。</p>
<p>那为什么做了生产验证，却没有发现问题呢？</p>
<p>因为当时存量配置有三条，我提供了 3 个 SQL，其中有一个是算对了的。</p>
<p>每一条存量配置都对应着大量的利息数据，而算对了的这个对应的数据更多，在比例上超过 60%。</p>
<p>我进行生产验证的时候，在大量的利息计提数据中随机抽选了两条，选中的这两条，恰好都是正确的 SQL 对应的数据。</p>
<p>所以我发现符合预期，得出了生产验证通过的结论。</p>
<p>站在这个节点，回顾整个事件，这个时候应该是最有可能发现问题的时候。</p>
<p>但是没发现。</p>
<p>根本原因是验证方案不严谨，玄学原因是运气不站在我这边。</p>
<h2 id="怎么暴露的？"><a href="#怎么暴露的？" class="headerlink" title="怎么暴露的？"></a><strong>怎么暴露的？</strong></h2><p>你想想，这种业务参数配置错误的问题你能通过什么监控规则监控到吗？</p>
<p>其实很难的。</p>
<p>我们一般来说做技术层面的监控，都是监控程序是否按照预期正常运行。比如在计算的过程中出现异常，那我们是可以监控到的。</p>
<p>但是在这种只是参与计算的值不对，但是能正常计算出一个值的情况，并不会报错。</p>
<p>这种问题通过技术手段很难监控到。如果硬要去做监控，肯定是能做的，比如从异常浮动的维度、横向数据对比的维度，但是配套的开发成本又上去了。</p>
<p>我是怎么发现这个问题的呢？</p>
<p>也是纯粹的运气。</p>
<p>是一个周五的晚上，我做另外的一个和本问题毫无关系的场景下的数据验证的时候，偶然间看到了一笔数据的金额和前几天比，明显大了很多。</p>
<p>这是不符合业务规律的。</p>
<p>然后进一步跟踪，最终定位到了前面的问题 SQL。这个时候距离这个 SQL 上线，已经过去了三天，已经产生了一批错误数据了。</p>
<p>如果我没有偶然间看到这个问题数据，那么这个问题会在什么环节暴露呢？</p>
<p>就是在业务使用这个数据做核对的时候。</p>
<p>那个时候整个问题的性质就变了。不仅是处理时间来不来得及的问题了，而是这个问题是由“开发自主发现”还是由“外部反馈发现”这两个完全不同的性质了。</p>
<p>一般来说，不管是什么问题，先抛开严重程度，只要是开发自主发现的，都能一定程度上让事情变得不那么难堪。</p>
<p>所以我们才一度强调“可监控”的重要性。</p>
<p>随后，我联系了业务，反馈了这个情况。他表示在他下次使用这批数据之前，把数据修复好就行。大概一个月后，他会用到这批数据。</p>
<p>这样，我有接近一个月的时间来处理这个问题，防止问题扩大化。</p>
<p>时间非常充足，站在这个角度，我运气还不错的。</p>
<p>问题已经暴露出来了，随后就是制定针对这批错误数据的修复方案了。</p>
<p>修复方案就和业务场景相关了，属于多个业务场景叠加在一起，所以修复方案其实是比较复杂的，涉及到“修数”和“补数”，没有展开描述的必要了。</p>
<p>只是想简单提一句，这个修复方案是我利用周末的时间想出来的，很多细节问题我都需要考虑到，甚至在心里写了一遍伪代码。</p>
<p>确实是浪费了周末的时间，但是这是为自己的错误买单，半点不怨别人，就是活该。</p>
<p>而对于参与后续方案讨论的同事来说，在这件事情上付出的时间，才是属于无妄之灾。</p>
<p>这就是整个事情的过程，一个小数点引发的血案。</p>
<h2 id="再回首"><a href="#再回首" class="headerlink" title="再回首"></a><strong>再回首</strong></h2><p>现在整个事情的全貌都在你眼前了，你得到了什么经验教训？</p>
<p>因为手抖了，写错了一位小数，这确实是直接原因，所以是想着下次再处理这种数据的时候，更加小心一点吗？</p>
<p>我觉得不是这样的。</p>
<p>我得到的经验教训就是我的标题：开发人员，千万不要去碰那该死的业务参数！</p>
<p>如果在最开始需求评审会，我们讨论到存量数据的时候。</p>
<p>业务说：这次需求上线的时候，你按照 11 位小数重新算好，然后写 SQL 更新一下就行。</p>
<p>我说：不行，这个属于是业务参数，我不能去动。上线完成后，就具备这个功能了，你可以通过页面配置去修改。</p>
<p>我知道他们修改业务参数的流程，很长很复杂。</p>
<p>首先业务需要发起一个参数变更的 OA 流程，然后走到他的部门负责人审批。</p>
<p>业务部门负责人审批完成后，会到具体负责业务参数配置的人员手里，还需要该人员对应的部门负责人审核。</p>
<p>审核完成后有权限的人员才会去修改这个业务参数，而这个参数的修改，在对应的系统功能上还有两级甚至三级审核。</p>
<p>整个完成之后发起 OA 的人员还需要进行变更确认，看看页面上是否是自己想要的配置。</p>
<p>这一套流程走下来，你觉得还会出错吗？</p>
<p>很难出错了。</p>
<p>你可以批判这个流程过于臃肿，但是你最终总是会认识到，这个流程其实是在保护打工人。</p>
<p>我知道他流程比较复杂，而我写个 SQL 几乎是没有成本的，但是这是在 SQL 正确的前提下。</p>
<p>如果当时不答应通过 SQL 的方式帮他处理存量数据，他其实有更加正规的流程去处理这些数据，而且不会出错。</p>
<p>事后我们复盘的时候，也有同事私下向我提出了这个的问题：为什么不走 OA 流程去调整这个参数？</p>
<p>另外，关于流程，我给你举一个程序员方面的例子。</p>
<p>一个核心开发人员拥有线上数据库的操作权限，我们先假设这个人绝对忠诚、绝对可以信赖、绝对恪尽职守、绝对不会删库跑路。</p>
<p>某一天，他收到一个预警信息，经过排查发现需要去修改数据库里面某个数据的状态，他直接就去修改了。</p>
<p>这个操作非常常见，特别是在小公司或者在一些在快速发展阶段的公司。</p>
<p>后来这个公司成长起来了，开始更加注重操作风险了，回收了所有人员的数据库权限，以前的事儿既往不咎，以后想要修改数据库数据，必须要发起一个审批流程，经过层层审批之后才能执行。</p>
<p>这个流程和“直接去修改”这个动作比起来，就重了无数倍了。</p>
<p>站在程序员的角度，前几年都是可以直接操作生产数据，突然这个制度出来了，极大的影响了之前的开发惯性。所以刚刚开始执行的时候，你可能会骂一句：xxx。</p>
<p>但是长远来看，这个流程其实是在保护你。</p>
<p>当你有数据库权限的时候，操作对了，没有人会夸你。操作错了，你就是罪魁祸首。</p>
<p>有了一个审批流程，在加重了操作成本的同时，也降低了错误成本。</p>
<p>处理问题的时长可能增加了，对于问题处理的敏捷度可能降低了，但是站在公司的角度，随着公司的发展“稳定”才是永恒的主旋律，在稳定面前，敏捷度反而是可以牺牲的。</p>
<p>歪师傅在第一家公司业务野蛮发展的时代，曾经就有这样的权限，那个时候刚刚参加工作两年多的时间，觉得事情就应该是这样的，这样才是正确的，可以足够敏捷，足够迅速的处理问题。</p>
<p>后来权限回收了，当时我也在私底下骂骂咧咧了几句。</p>
<p>再回来，随着经验和在职场上见过得事儿越来越多，才渐渐认识到：蛮荒时代确实出英雄，但是我没有把握好机会成为英雄。蛮荒时代之后的流程规范，规章制度其实是在保护那批没有成为英雄的人，其中就有我。</p>
<p>最后，给你，也给我自己一个忠告：开发人员，你最好要知道你数据库里面每一个业务参数背后的业务含义，但是千万不要去碰那该死的业务参数。也轮不到你碰，该碰的人会在正确的流程下去碰。</p>
<p>无论什么时候，心中都要绷着这根弦。</p>
]]></content>
      <categories>
        <category>workNote</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>sqlserver</tag>
      </tags>
  </entry>
  <entry>
    <title>优化SQL server</title>
    <url>/2024/11/12/%E4%BC%98%E5%8C%96SQLserver/</url>
    <content><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p>
<p>leiyu-code.github.io</p>
<p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p>
<h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p>在 SQL Server 中，当数据量增大时，数据库的性能可能会受到影响，导致查询速度变慢、响应时间变长等问题。为了应对大量数据，以下是一些常用的优化策略和案例详解。</p>
<h2 id="1-索引优化"><a href="#1-索引优化" class="headerlink" title="1. 索引优化"></a>1. 索引优化</h2><ul>
<li><strong>创建索引</strong>：索引可以显著提高查询速度，特别是在使用 <code>WHERE</code>、<code>JOIN</code> 和 <code>ORDER BY</code> 子句时。为常用的查询字段（尤其是筛选条件字段）创建合适的索引。</li>
<li><strong>选择合适的索引类型</strong>：使用聚集索引（Clustered Index）和非聚集索引（Non-clustered Index）来优化查询性能。聚集索引适用于排序、范围查询等，而非聚集索引适用于单一列或组合列的查询。</li>
<li><strong>避免过多索引</strong>：虽然索引能提高查询性能，但过多的索引会增加更新、插入和删除操作的成本，因此要平衡索引的数量和性能。</li>
</ul>
<p>在 SQL Server 中，索引优化是提高查询性能的重要手段。以下是一个具体的业务场景，假设我们有一个销售订单系统，订单表 <code>Orders</code> 需要根据不同的查询需求来进行索引优化。</p>
<h3 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h3><ul>
<li>查询需求1：按 <code>CustomerID</code> 和 <code>OrderDate</code> 查询订单信息。</li>
<li>查询需求2：按 <code>ProductID</code> 查询所有相关的订单。</li>
<li>查询需求3：查询某一订单的详细信息（通过 <code>OrderID</code>）。</li>
</ul>
<p>基于这些需求，我们将为 <code>Orders</code> 表创建索引，并展示如何选择合适的索引类型。</p>
<h3 id="1-创建表-Orders"><a href="#1-创建表-Orders" class="headerlink" title="1. 创建表 Orders"></a>1. 创建表 <code>Orders</code></h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Orders (</span><br><span class="line">    OrderID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,         <span class="comment">-- 主键索引，自动创建聚集索引</span></span><br><span class="line">    CustomerID <span class="type">INT</span>,                  <span class="comment">-- 客户ID</span></span><br><span class="line">    OrderDate DATETIME,              <span class="comment">-- 订单日期</span></span><br><span class="line">    ProductID <span class="type">INT</span>,                   <span class="comment">-- 产品ID</span></span><br><span class="line">    TotalAmount <span class="type">DECIMAL</span>(<span class="number">18</span>, <span class="number">2</span>),      <span class="comment">-- 订单总金额</span></span><br><span class="line">    Status <span class="type">VARCHAR</span>(<span class="number">20</span>)               <span class="comment">-- 订单状态</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="2-创建索引"><a href="#2-创建索引" class="headerlink" title="2. 创建索引"></a>2. 创建索引</h3><h4 id="2-1-创建聚集索引（Clustered-Index）"><a href="#2-1-创建聚集索引（Clustered-Index）" class="headerlink" title="2.1. 创建聚集索引（Clustered Index）"></a>2.1. 创建聚集索引（Clustered Index）</h4><p>聚集索引通常是基于主键或唯一约束创建的。它将数据按照索引顺序存储，因此在 <code>OrderID</code> 上创建聚集索引能够加速按 <code>OrderID</code> 查找的查询。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- OrderID 是主键，默认会创建聚集索引</span></span><br><span class="line"><span class="comment">-- 所以在这种情况下不需要额外创建聚集索引</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-创建非聚集索引（Non-clustered-Index）"><a href="#2-2-创建非聚集索引（Non-clustered-Index）" class="headerlink" title="2.2. 创建非聚集索引（Non-clustered Index）"></a>2.2. 创建非聚集索引（Non-clustered Index）</h4><p>对于 <code>CustomerID</code> 和 <code>OrderDate</code> 组合字段的查询需求，我们可以为其创建一个复合非聚集索引。这样可以加速基于 <code>CustomerID</code> 和 <code>OrderDate</code> 的查询。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> NONCLUSTERED INDEX idx_Customer_OrderDate</span><br><span class="line"><span class="keyword">ON</span> Orders (CustomerID, OrderDate);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用场景</strong>：该索引有助于加速按 <code>CustomerID</code> 和 <code>OrderDate</code> 查询的性能，特别是当订单数据量较大时。</li>
</ul>
<h4 id="2-3-创建单列非聚集索引"><a href="#2-3-创建单列非聚集索引" class="headerlink" title="2.3. 创建单列非聚集索引"></a>2.3. 创建单列非聚集索引</h4><p>对于查询需求2，如果我们需要按 <code>ProductID</code> 查找所有相关订单，我们可以为 <code>ProductID</code> 创建单列非聚集索引。这样可以提高查询效率。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> NONCLUSTERED INDEX idx_ProductID</span><br><span class="line"><span class="keyword">ON</span> Orders (ProductID);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用场景</strong>：查询某个产品相关的所有订单时，通过该索引可以显著提高查询性能。</li>
</ul>
<h3 id="3-删除冗余索引"><a href="#3-删除冗余索引" class="headerlink" title="3. 删除冗余索引"></a>3. 删除冗余索引</h3><p>如果发现某个查询经常访问多个列，而我们在这些列上创建了多个单列索引，可能会导致性能下降。比如，创建多个针对单列的非聚集索引，可能会降低插入和更新操作的效率。为了避免这种情况，可以定期检查并删除冗余的索引。</p>
<p>假设我们发现 <code>ProductID</code> 和 <code>CustomerID</code> 常常一起出现在查询条件中，我们可以考虑删除 <code>idx_ProductID</code> 索引，改为创建一个组合索引。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除冗余的单列索引</span></span><br><span class="line"><span class="keyword">DROP</span> INDEX idx_ProductID <span class="keyword">ON</span> Orders;</span><br></pre></td></tr></table></figure>

<h3 id="4-查询优化"><a href="#4-查询优化" class="headerlink" title="4. 查询优化"></a>4. 查询优化</h3><p>现在，假设我们有以下几个查询，我们将展示如何利用创建的索引来优化查询性能。</p>
<h4 id="4-1-按-CustomerID-和-OrderDate-查询"><a href="#4-1-按-CustomerID-和-OrderDate-查询" class="headerlink" title="4.1. 按 CustomerID 和 OrderDate 查询"></a>4.1. 按 <code>CustomerID</code> 和 <code>OrderDate</code> 查询</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用 idx_Customer_OrderDate 索引</span></span><br><span class="line"><span class="keyword">SELECT</span> OrderID, ProductID, TotalAmount</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> CustomerID <span class="operator">=</span> <span class="number">1001</span> <span class="keyword">AND</span> OrderDate <span class="keyword">BETWEEN</span> <span class="string">&#x27;2024-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2024-12-31&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-按-ProductID-查询"><a href="#4-2-按-ProductID-查询" class="headerlink" title="4.2. 按 ProductID 查询"></a>4.2. 按 <code>ProductID</code> 查询</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用 idx_ProductID 索引</span></span><br><span class="line"><span class="keyword">SELECT</span> OrderID, CustomerID, TotalAmount</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> ProductID <span class="operator">=</span> <span class="number">500</span>;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-查询特定订单详细信息"><a href="#4-3-查询特定订单详细信息" class="headerlink" title="4.3. 查询特定订单详细信息"></a>4.3. 查询特定订单详细信息</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 按 OrderID 查询，使用默认的聚集索引</span></span><br><span class="line"><span class="keyword">SELECT</span> CustomerID, ProductID, TotalAmount, Status</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> OrderID <span class="operator">=</span> <span class="number">123456</span>;</span><br></pre></td></tr></table></figure>

<h3 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5. 注意事项"></a>5. 注意事项</h3><ul>
<li><strong>索引的维护成本</strong>：虽然索引能显著提高查询性能，但每当进行 <code>INSERT</code>、<code>UPDATE</code> 或 <code>DELETE</code> 操作时，索引也需要维护。这会增加操作的成本。因此，索引不宜过多，需要根据查询需求进行优化。</li>
<li><strong>索引覆盖</strong>：尽量创建覆盖索引，即索引包含查询所需的所有列，这样可以避免查询时回表操作，提高查询效率。</li>
</ul>
<h3 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h3><p>通过为 <code>Orders</code> 表创建合适的索引，我们可以显著优化查询性能。在索引优化中，需要综合考虑查询需求、索引类型（聚集索引、非聚集索引）、索引的数量及其维护成本。</p>
<h2 id="2-查询优化"><a href="#2-查询优化" class="headerlink" title="2. 查询优化"></a>2. 查询优化</h2><ul>
<li><strong>优化 SQL 查询</strong>：确保 SQL 查询尽量高效。避免在查询中使用 <code>SELECT *</code>，而是只选择需要的列；避免重复的计算，尽量减少子查询。</li>
<li><strong>使用执行计划</strong>：利用 SQL Server Management Studio (SSMS) 的执行计划工具查看查询的执行计划，分析和优化查询中的瓶颈部分。</li>
<li><strong>避免复杂的嵌套查询</strong>：复杂的子查询可能会导致性能问题，考虑使用连接（<code>JOIN</code>）来代替。</li>
</ul>
<p>查询优化是通过精心设计 SQL 查询语句和优化索引来提高查询性能的过程。根据你提供的业务场景，我们将基于一个订单系统的 <code>Orders</code> 表，展示几种常见的查询优化方法。</p>
<h3 id="业务场景-1"><a href="#业务场景-1" class="headerlink" title="业务场景"></a>业务场景</h3><p>假设我们有一个销售订单系统，<code>Orders</code> 表包括以下字段：</p>
<ul>
<li><code>OrderID</code>：订单ID，主键。</li>
<li><code>CustomerID</code>：客户ID。</li>
<li><code>OrderDate</code>：订单日期。</li>
<li><code>ProductID</code>：产品ID。</li>
<li><code>TotalAmount</code>：订单总金额。</li>
<li><code>Status</code>：订单状态（如已支付、未支付等）。</li>
</ul>
<p>我们有以下几种查询需求：</p>
<ol>
<li>查询某个客户在某段时间内的所有订单。</li>
<li>查询某个产品在所有订单中的销售情况。</li>
<li>查询某个订单的详细信息。</li>
<li>查询多个客户的订单信息。</li>
</ol>
<h3 id="1-查询优化：按-CustomerID-和-OrderDate-查询订单"><a href="#1-查询优化：按-CustomerID-和-OrderDate-查询订单" class="headerlink" title="1. 查询优化：按 CustomerID 和 OrderDate 查询订单"></a>1. <strong>查询优化：按 <code>CustomerID</code> 和 <code>OrderDate</code> 查询订单</strong></h3><h4 id="查询需求："><a href="#查询需求：" class="headerlink" title="查询需求："></a>查询需求：</h4><p>查询某个客户在某段时间内的所有订单。</p>
<h4 id="查询语句："><a href="#查询语句：" class="headerlink" title="查询语句："></a>查询语句：</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> OrderID, ProductID, TotalAmount, Status</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> CustomerID <span class="operator">=</span> <span class="number">1001</span></span><br><span class="line">  <span class="keyword">AND</span> OrderDate <span class="keyword">BETWEEN</span> <span class="string">&#x27;2024-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2024-12-31&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="优化建议："><a href="#优化建议：" class="headerlink" title="优化建议："></a>优化建议：</h4><ul>
<li><strong>索引优化</strong>：为 <code>CustomerID</code> 和 <code>OrderDate</code> 创建复合索引，因为这是常见的查询模式。复合索引可以加速基于这两个字段的查询。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> NONCLUSTERED INDEX idx_Customer_OrderDate</span><br><span class="line"><span class="keyword">ON</span> Orders (CustomerID, OrderDate);</span><br></pre></td></tr></table></figure>

<h4 id="执行计划优化："><a href="#执行计划优化：" class="headerlink" title="执行计划优化："></a>执行计划优化：</h4><ul>
<li>使用 <code>EXPLAIN</code> 或 <code>SET STATISTICS IO ON</code> 来查看执行计划，确认查询是否使用了索引。</li>
</ul>
<h3 id="2-查询优化：按-ProductID-查询所有相关订单"><a href="#2-查询优化：按-ProductID-查询所有相关订单" class="headerlink" title="2. 查询优化：按 ProductID 查询所有相关订单"></a>2. <strong>查询优化：按 <code>ProductID</code> 查询所有相关订单</strong></h3><h4 id="查询需求：-1"><a href="#查询需求：-1" class="headerlink" title="查询需求："></a>查询需求：</h4><p>查询某个产品的所有订单。</p>
<h4 id="查询语句：-1"><a href="#查询语句：-1" class="headerlink" title="查询语句："></a>查询语句：</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> OrderID, CustomerID, TotalAmount, Status</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> ProductID <span class="operator">=</span> <span class="number">500</span>;</span><br></pre></td></tr></table></figure>

<h4 id="优化建议：-1"><a href="#优化建议：-1" class="headerlink" title="优化建议："></a>优化建议：</h4><ul>
<li><strong>索引优化</strong>：为 <code>ProductID</code> 创建索引，因为这个字段经常作为查询条件。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> NONCLUSTERED INDEX idx_ProductID</span><br><span class="line"><span class="keyword">ON</span> Orders (ProductID);</span><br></pre></td></tr></table></figure>

<h4 id="执行计划优化：-1"><a href="#执行计划优化：-1" class="headerlink" title="执行计划优化："></a>执行计划优化：</h4><ul>
<li>确保查询能够利用 <code>idx_ProductID</code> 索引，避免全表扫描。</li>
</ul>
<h3 id="3-查询优化：查询某个订单的详细信息"><a href="#3-查询优化：查询某个订单的详细信息" class="headerlink" title="3. 查询优化：查询某个订单的详细信息"></a>3. <strong>查询优化：查询某个订单的详细信息</strong></h3><h4 id="查询需求：-2"><a href="#查询需求：-2" class="headerlink" title="查询需求："></a>查询需求：</h4><p>查询某个订单的详细信息。</p>
<h4 id="查询语句：-2"><a href="#查询语句：-2" class="headerlink" title="查询语句："></a>查询语句：</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CustomerID, ProductID, TotalAmount, Status</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> OrderID <span class="operator">=</span> <span class="number">123456</span>;</span><br></pre></td></tr></table></figure>

<h4 id="优化建议：-2"><a href="#优化建议：-2" class="headerlink" title="优化建议："></a>优化建议：</h4><ul>
<li><strong>索引优化</strong>：因为 <code>OrderID</code> 是主键字段，SQL Server 会自动创建聚集索引。查询 <code>OrderID</code> 字段时，查询会直接利用聚集索引。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 聚集索引已自动创建，无需额外创建</span></span><br></pre></td></tr></table></figure>

<h4 id="执行计划优化：-2"><a href="#执行计划优化：-2" class="headerlink" title="执行计划优化："></a>执行计划优化：</h4><ul>
<li>确保查询只扫描一行数据，利用 <code>OrderID</code> 主键索引。</li>
</ul>
<h3 id="4-查询优化：查询多个客户的订单信息"><a href="#4-查询优化：查询多个客户的订单信息" class="headerlink" title="4. 查询优化：查询多个客户的订单信息"></a>4. <strong>查询优化：查询多个客户的订单信息</strong></h3><h4 id="查询需求：-3"><a href="#查询需求：-3" class="headerlink" title="查询需求："></a>查询需求：</h4><p>查询多个客户的订单信息。</p>
<h4 id="查询语句：-3"><a href="#查询语句：-3" class="headerlink" title="查询语句："></a>查询语句：</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> OrderID, CustomerID, ProductID, TotalAmount, Status</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> CustomerID <span class="keyword">IN</span> (<span class="number">1001</span>, <span class="number">1002</span>, <span class="number">1003</span>);</span><br></pre></td></tr></table></figure>

<h4 id="优化建议：-3"><a href="#优化建议：-3" class="headerlink" title="优化建议："></a>优化建议：</h4><ul>
<li><strong>索引优化</strong>：为 <code>CustomerID</code> 创建索引，以便快速过滤出目标客户的订单。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> NONCLUSTERED INDEX idx_CustomerID</span><br><span class="line"><span class="keyword">ON</span> Orders (CustomerID);</span><br></pre></td></tr></table></figure>

<h4 id="执行计划优化：-3"><a href="#执行计划优化：-3" class="headerlink" title="执行计划优化："></a>执行计划优化：</h4><ul>
<li>确保 <code>IN</code> 子句使用了 <code>idx_CustomerID</code> 索引来优化查询。</li>
</ul>
<h3 id="5-查询优化：避免使用-SELECT"><a href="#5-查询优化：避免使用-SELECT" class="headerlink" title="5. 查询优化：避免使用 SELECT \*"></a>5. <strong>查询优化：避免使用 <code>SELECT \*</code></strong></h3><h4 id="查询需求：-4"><a href="#查询需求：-4" class="headerlink" title="查询需求："></a>查询需求：</h4><p>查询所有字段（不推荐，通常用来调试或检查表结构）。</p>
<h4 id="查询语句：-4"><a href="#查询语句：-4" class="headerlink" title="查询语句："></a>查询语句：</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Orders;</span><br></pre></td></tr></table></figure>

<h4 id="优化建议：-4"><a href="#优化建议：-4" class="headerlink" title="优化建议："></a>优化建议：</h4><ul>
<li><strong>明确选择需要的列</strong>：避免使用 <code>SELECT *</code>，明确列出查询需要的字段，避免读取不必要的列。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> OrderID, CustomerID, TotalAmount <span class="keyword">FROM</span> Orders;</span><br></pre></td></tr></table></figure>

<h3 id="6-查询优化：使用-JOIN-进行多表查询"><a href="#6-查询优化：使用-JOIN-进行多表查询" class="headerlink" title="6. 查询优化：使用 JOIN 进行多表查询"></a>6. <strong>查询优化：使用 <code>JOIN</code> 进行多表查询</strong></h3><h4 id="查询需求：-5"><a href="#查询需求：-5" class="headerlink" title="查询需求："></a>查询需求：</h4><p>查询某个客户的订单信息以及相关的产品信息。假设有一个 <code>Products</code> 表，包含 <code>ProductID</code> 和 <code>ProductName</code>。</p>
<h4 id="查询语句：-5"><a href="#查询语句：-5" class="headerlink" title="查询语句："></a>查询语句：</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> o.OrderID, o.TotalAmount, p.ProductName</span><br><span class="line"><span class="keyword">FROM</span> Orders o</span><br><span class="line"><span class="keyword">JOIN</span> Products p <span class="keyword">ON</span> o.ProductID <span class="operator">=</span> p.ProductID</span><br><span class="line"><span class="keyword">WHERE</span> o.CustomerID <span class="operator">=</span> <span class="number">1001</span></span><br><span class="line">  <span class="keyword">AND</span> o.OrderDate <span class="keyword">BETWEEN</span> <span class="string">&#x27;2024-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2024-12-31&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="优化建议：-5"><a href="#优化建议：-5" class="headerlink" title="优化建议："></a>优化建议：</h4><ul>
<li><strong>索引优化</strong>：为 <code>Orders</code> 表的 <code>CustomerID</code>、<code>OrderDate</code> 和 <code>ProductID</code> 创建复合索引，为 <code>Products</code> 表的 <code>ProductID</code> 创建索引，以加速 <code>JOIN</code> 查询。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> NONCLUSTERED INDEX idx_Orders_Customer_OrderDate_Product</span><br><span class="line"><span class="keyword">ON</span> Orders (CustomerID, OrderDate, ProductID);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> NONCLUSTERED INDEX idx_Products_ProductID</span><br><span class="line"><span class="keyword">ON</span> Products (ProductID);</span><br></pre></td></tr></table></figure>

<h4 id="执行计划优化：-4"><a href="#执行计划优化：-4" class="headerlink" title="执行计划优化："></a>执行计划优化：</h4><ul>
<li>确保执行计划中使用了 <code>JOIN</code> 的相关索引，避免全表扫描。</li>
</ul>
<h3 id="7-查询优化：分页查询"><a href="#7-查询优化：分页查询" class="headerlink" title="7. 查询优化：分页查询"></a>7. <strong>查询优化：分页查询</strong></h3><h4 id="查询需求：-6"><a href="#查询需求：-6" class="headerlink" title="查询需求："></a>查询需求：</h4><p>查询某个时间段内的客户订单，并实现分页功能。</p>
<h4 id="查询语句：-6"><a href="#查询语句：-6" class="headerlink" title="查询语句："></a>查询语句：</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> OrderID, CustomerID, TotalAmount, Status</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> OrderDate <span class="keyword">BETWEEN</span> <span class="string">&#x27;2024-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2024-12-31&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> OrderDate</span><br><span class="line"><span class="keyword">OFFSET</span> <span class="number">0</span> <span class="keyword">ROWS</span> <span class="keyword">FETCH</span> NEXT <span class="number">20</span> <span class="keyword">ROWS</span> <span class="keyword">ONLY</span>;</span><br></pre></td></tr></table></figure>

<h4 id="优化建议：-6"><a href="#优化建议：-6" class="headerlink" title="优化建议："></a>优化建议：</h4><ul>
<li><strong>索引优化</strong>：确保在 <code>OrderDate</code> 上有合适的索引，能够加速排序操作。</li>
<li>使用 <code>OFFSET</code> 和 <code>FETCH</code> 语句实现分页查询，避免一次性加载大量数据。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> NONCLUSTERED INDEX idx_OrderDate</span><br><span class="line"><span class="keyword">ON</span> Orders (OrderDate);</span><br></pre></td></tr></table></figure>

<h3 id="8-避免过多的子查询"><a href="#8-避免过多的子查询" class="headerlink" title="8. 避免过多的子查询"></a>8. <strong>避免过多的子查询</strong></h3><h4 id="查询需求：-7"><a href="#查询需求：-7" class="headerlink" title="查询需求："></a>查询需求：</h4><p>查询某个客户在某段时间内的订单总金额。</p>
<h4 id="查询语句：-7"><a href="#查询语句：-7" class="headerlink" title="查询语句："></a>查询语句：</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CustomerID, </span><br><span class="line">       (<span class="keyword">SELECT</span> <span class="built_in">SUM</span>(TotalAmount) <span class="keyword">FROM</span> Orders <span class="keyword">WHERE</span> CustomerID <span class="operator">=</span> <span class="number">1001</span> <span class="keyword">AND</span> OrderDate <span class="keyword">BETWEEN</span> <span class="string">&#x27;2024-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2024-12-31&#x27;</span>) <span class="keyword">AS</span> TotalSpent</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> CustomerID <span class="operator">=</span> <span class="number">1001</span>;</span><br></pre></td></tr></table></figure>

<h4 id="优化建议：-7"><a href="#优化建议：-7" class="headerlink" title="优化建议："></a>优化建议：</h4><ul>
<li><strong>避免使用子查询</strong>：尽量避免在 <code>SELECT</code> 语句中使用子查询，可以改为 <code>JOIN</code> 或 <code>GROUP BY</code> 来提高效率。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> o.CustomerID, <span class="built_in">SUM</span>(o.TotalAmount) <span class="keyword">AS</span> TotalSpent</span><br><span class="line"><span class="keyword">FROM</span> Orders o</span><br><span class="line"><span class="keyword">WHERE</span> o.CustomerID <span class="operator">=</span> <span class="number">1001</span></span><br><span class="line">  <span class="keyword">AND</span> o.OrderDate <span class="keyword">BETWEEN</span> <span class="string">&#x27;2024-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2024-12-31&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> o.CustomerID;</span><br></pre></td></tr></table></figure>

<h3 id="小结一下-1"><a href="#小结一下-1" class="headerlink" title="小结一下"></a>小结一下</h3><p>通过优化 SQL 查询语句、合理使用索引以及减少不必要的操作，我们能够显著提高查询性能。具体做法包括：</p>
<ul>
<li>创建合适的索引（单列索引和复合索引）。</li>
<li>优化查询语句，避免使用 <code>SELECT *</code> 和过多的子查询。</li>
<li>使用合适的分页技术和 <code>JOIN</code> 优化多表查询。</li>
<li>分析查询执行计划，确保查询高效执行。</li>
</ul>
<p>这些优化措施可以帮助 SQL Server 在面对大量数据时保持高效的查询性能。</p>
<h2 id="3-数据分区和分表"><a href="#3-数据分区和分表" class="headerlink" title="3. 数据分区和分表"></a>3. 数据分区和分表</h2><ul>
<li><strong>表分区</strong>：对于非常大的表，可以考虑使用表分区。表分区可以根据某些条件（例如时间、ID 范围等）将数据分割到多个物理文件中，这样查询时只访问相关的分区，减少了全表扫描的开销。</li>
<li><strong>水平拆分（Sharding）</strong>：将数据分散到多个独立的表或数据库中，通常基于某种规则（如区域、日期等）。每个表包含数据的一个子集，可以提高查询效率。</li>
</ul>
<p>数据分区（Partitioning）和分表（Sharding）是优化数据库性能的关键手段，尤其在处理大数据量时。通过数据分区或分表，可以有效地减少查询和写入的压力，提高数据访问效率。以下是基于业务场景的具体代码案例，展示如何使用数据分区和分表来优化 SQL Server 的性能。</p>
<h3 id="业务场景-2"><a href="#业务场景-2" class="headerlink" title="业务场景"></a>业务场景</h3><p>假设我们有一个订单系统，<code>Orders</code> 表记录了所有订单信息。随着订单量的增加，单表的查询和维护变得越来越困难。因此，我们需要使用分区和分表技术来优化数据库的性能。</p>
<h3 id="1-数据分区（Partitioning）"><a href="#1-数据分区（Partitioning）" class="headerlink" title="1. 数据分区（Partitioning）"></a>1. <strong>数据分区（Partitioning）</strong></h3><p>数据分区是在单一表上进行逻辑分区，它允许将一个大的表按某个规则（如时间范围、数值区间等）分成多个物理段（分区）。每个分区可以独立管理，查询可以在特定的分区内进行，从而提高查询性能。</p>
<h4 id="业务需求"><a href="#业务需求" class="headerlink" title="业务需求"></a>业务需求</h4><ul>
<li>按照订单日期（<code>OrderDate</code>）将 <code>Orders</code> 表分区，以便在查询时快速定位到特定时间段内的订单。</li>
</ul>
<h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><ol>
<li>创建分区函数（Partition Function）和分区方案（Partition Scheme）。</li>
<li>在 <code>Orders</code> 表上应用分区。</li>
</ol>
<h4 id="创建分区函数（Partition-Function）"><a href="#创建分区函数（Partition-Function）" class="headerlink" title="创建分区函数（Partition Function）"></a>创建分区函数（Partition Function）</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建分区函数：按年度分区</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PARTITION</span> <span class="keyword">FUNCTION</span> OrderDatePartitionFunc (<span class="type">DATE</span>)</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">RANGE</span> <span class="keyword">RIGHT</span> <span class="keyword">FOR</span> <span class="keyword">VALUES</span> (<span class="string">&#x27;2023-01-01&#x27;</span>, <span class="string">&#x27;2024-01-01&#x27;</span>, <span class="string">&#x27;2025-01-01&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>该分区函数将根据订单日期（<code>OrderDate</code>）把数据分为多个区间，每个区间的范围是按年划分的。</p>
<h4 id="创建分区方案（Partition-Scheme）"><a href="#创建分区方案（Partition-Scheme）" class="headerlink" title="创建分区方案（Partition Scheme）"></a>创建分区方案（Partition Scheme）</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建分区方案：将分区函数应用到物理文件组</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PARTITION</span> SCHEME OrderDatePartitionScheme</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">PARTITION</span> OrderDatePartitionFunc</span><br><span class="line"><span class="keyword">TO</span> ([<span class="keyword">PRIMARY</span>], [FG_2023], [FG_2024], [FG_2025]);</span><br></pre></td></tr></table></figure>

<p>此方案为每个分区指定一个物理文件组（如 <code>PRIMARY</code>、<code>FG_2023</code> 等）。</p>
<h4 id="创建分区表"><a href="#创建分区表" class="headerlink" title="创建分区表"></a>创建分区表</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建分区表：应用分区方案</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Orders</span><br><span class="line">(</span><br><span class="line">    OrderID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    CustomerID <span class="type">INT</span>,</span><br><span class="line">    OrderDate <span class="type">DATE</span>,</span><br><span class="line">    ProductID <span class="type">INT</span>,</span><br><span class="line">    TotalAmount <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    Status <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">ON</span> OrderDatePartitionScheme (OrderDate);</span><br></pre></td></tr></table></figure>

<p><code>Orders</code> 表按 <code>OrderDate</code> 字段进行分区，数据会根据日期分布到不同的物理文件组中。</p>
<h4 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询 2024 年的订单，查询仅会访问相应的分区，提高查询效率</span></span><br><span class="line"><span class="keyword">SELECT</span> OrderID, CustomerID, ProductID, TotalAmount</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> OrderDate <span class="keyword">BETWEEN</span> <span class="string">&#x27;2024-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2024-12-31&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>通过分区，查询只会扫描相关分区的数据，从而提高查询速度。</p>
<h3 id="2-数据分表（Sharding）"><a href="#2-数据分表（Sharding）" class="headerlink" title="2. 数据分表（Sharding）"></a>2. <strong>数据分表（Sharding）</strong></h3><p>分表是将数据水平拆分到多个物理表中，每个表存储一部分数据。常见的分表策略包括按范围分表、按哈希值分表等。分表可以显著提升查询性能，但需要管理多个表及其关系。</p>
<h4 id="业务需求-1"><a href="#业务需求-1" class="headerlink" title="业务需求"></a>业务需求</h4><ul>
<li>按 <code>CustomerID</code> 将 <code>Orders</code> 表进行分表，客户ID为基础将数据分配到不同的表中。</li>
<li>客户ID的范围是均匀的，因此我们可以使用哈希分表策略。</li>
</ul>
<h4 id="步骤：-1"><a href="#步骤：-1" class="headerlink" title="步骤："></a>步骤：</h4><ol>
<li>创建多个分表。</li>
<li>在应用层处理分表逻辑。</li>
</ol>
<h4 id="创建分表"><a href="#创建分表" class="headerlink" title="创建分表"></a>创建分表</h4><p>假设我们决定将 <code>Orders</code> 表按 <code>CustomerID</code> 的哈希值分成 4 个表。可以通过以下方式创建 4 个分表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建 Orders_1 分表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Orders_1</span><br><span class="line">(</span><br><span class="line">    OrderID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    CustomerID <span class="type">INT</span>,</span><br><span class="line">    OrderDate <span class="type">DATE</span>,</span><br><span class="line">    ProductID <span class="type">INT</span>,</span><br><span class="line">    TotalAmount <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    Status <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建 Orders_2 分表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Orders_2</span><br><span class="line">(</span><br><span class="line">    OrderID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    CustomerID <span class="type">INT</span>,</span><br><span class="line">    OrderDate <span class="type">DATE</span>,</span><br><span class="line">    ProductID <span class="type">INT</span>,</span><br><span class="line">    TotalAmount <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    Status <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建 Orders_3 分表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Orders_3</span><br><span class="line">(</span><br><span class="line">    OrderID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    CustomerID <span class="type">INT</span>,</span><br><span class="line">    OrderDate <span class="type">DATE</span>,</span><br><span class="line">    ProductID <span class="type">INT</span>,</span><br><span class="line">    TotalAmount <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    Status <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建 Orders_4 分表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Orders_4</span><br><span class="line">(</span><br><span class="line">    OrderID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    CustomerID <span class="type">INT</span>,</span><br><span class="line">    OrderDate <span class="type">DATE</span>,</span><br><span class="line">    ProductID <span class="type">INT</span>,</span><br><span class="line">    TotalAmount <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    Status <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="分表逻辑"><a href="#分表逻辑" class="headerlink" title="分表逻辑"></a>分表逻辑</h4><p>在应用层，我们需要实现一个分表路由逻辑，通过哈希值来确定应该向哪个表插入数据或查询数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 示例：根据 CustomerID 哈希值选择分表</span></span><br><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@CustomerID</span> <span class="type">INT</span> <span class="operator">=</span> <span class="number">1001</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@TableSuffix</span> <span class="type">INT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用哈希算法来决定表</span></span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@TableSuffix</span> <span class="operator">=</span> <span class="variable">@CustomerID</span> <span class="operator">%</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line">IF <span class="variable">@TableSuffix</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> Orders_1 (OrderID, CustomerID, OrderDate, ProductID, TotalAmount, Status)</span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="number">123456</span>, <span class="number">1001</span>, <span class="string">&#x27;2024-01-01&#x27;</span>, <span class="number">101</span>, <span class="number">150.00</span>, <span class="string">&#x27;Paid&#x27;</span>);</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">ELSE</span> IF <span class="variable">@TableSuffix</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> Orders_2 (OrderID, CustomerID, OrderDate, ProductID, TotalAmount, Status)</span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="number">123457</span>, <span class="number">1002</span>, <span class="string">&#x27;2024-01-02&#x27;</span>, <span class="number">102</span>, <span class="number">250.00</span>, <span class="string">&#x27;Pending&#x27;</span>);</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">ELSE</span> IF <span class="variable">@TableSuffix</span> <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> Orders_3 (OrderID, CustomerID, OrderDate, ProductID, TotalAmount, Status)</span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="number">123458</span>, <span class="number">1003</span>, <span class="string">&#x27;2024-01-03&#x27;</span>, <span class="number">103</span>, <span class="number">350.00</span>, <span class="string">&#x27;Shipped&#x27;</span>);</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> Orders_4 (OrderID, CustomerID, OrderDate, ProductID, TotalAmount, Status)</span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="number">123459</span>, <span class="number">1004</span>, <span class="string">&#x27;2024-01-04&#x27;</span>, <span class="number">104</span>, <span class="number">450.00</span>, <span class="string">&#x27;Delivered&#x27;</span>);</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<h4 id="查询逻辑"><a href="#查询逻辑" class="headerlink" title="查询逻辑"></a>查询逻辑</h4><p>为了查询某个客户的订单，我们也需要在应用层决定查询哪个分表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询某个客户的订单</span></span><br><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@CustomerID</span> <span class="type">INT</span> <span class="operator">=</span> <span class="number">1001</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@TableSuffix</span> <span class="type">INT</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@TableSuffix</span> <span class="operator">=</span> <span class="variable">@CustomerID</span> <span class="operator">%</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询数据</span></span><br><span class="line">IF <span class="variable">@TableSuffix</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Orders_1 <span class="keyword">WHERE</span> CustomerID <span class="operator">=</span> <span class="variable">@CustomerID</span>;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">ELSE</span> IF <span class="variable">@TableSuffix</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Orders_2 <span class="keyword">WHERE</span> CustomerID <span class="operator">=</span> <span class="variable">@CustomerID</span>;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">ELSE</span> IF <span class="variable">@TableSuffix</span> <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Orders_3 <span class="keyword">WHERE</span> CustomerID <span class="operator">=</span> <span class="variable">@CustomerID</span>;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Orders_4 <span class="keyword">WHERE</span> CustomerID <span class="operator">=</span> <span class="variable">@CustomerID</span>;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<h3 id="3-分区和分表的选择"><a href="#3-分区和分表的选择" class="headerlink" title="3. 分区和分表的选择"></a>3. <strong>分区和分表的选择</strong></h3><ul>
<li><strong>分区</strong>：适用于对一个表进行物理划分，但仍然保持数据的逻辑统一性。例如，按时间（如订单日期）分区可以有效提高时间范围查询的性能。</li>
<li><strong>分表</strong>：适用于数据量特别大的情况，将数据拆分到多个表中，以减少单个表的查询压力。通常采用哈希分表或者范围分表。</li>
</ul>
<h3 id="小结一下-2"><a href="#小结一下-2" class="headerlink" title="小结一下"></a>小结一下</h3><ul>
<li><strong>分区</strong>可以让你在一个大的表上进行逻辑划分，在查询时只访问相关的分区，提高性能。</li>
<li><strong>分表</strong>则是将数据水平拆分到多个物理表，通常用于处理极大数据量的场景。</li>
<li>在 SQL Server 中实现分区和分表需要对表的设计、索引设计和查询策略进行综合考虑，以确保数据访问效率和维护的便利性。</li>
</ul>
<h2 id="4-数据归档"><a href="#4-数据归档" class="headerlink" title="4. 数据归档"></a>4. 数据归档</h2><ul>
<li><strong>归档旧数据</strong>：对于已经不常查询的数据，可以将其归档到独立的历史表或数据库中，从而减轻主数据库的负担。只保留近期数据在主表中，优化查询性能。</li>
<li><strong>压缩旧数据</strong>：可以通过压缩技术来存储归档数据，节省存储空间。</li>
</ul>
<p>数据归档是指将不再频繁访问的历史数据从主数据库中移除，并将其存储在归档系统或表中，从而提高主数据库的性能。数据归档通常用于老旧数据、历史记录等不再活跃但需要保留的数据。</p>
<h3 id="业务场景-3"><a href="#业务场景-3" class="headerlink" title="业务场景"></a>业务场景</h3><p>假设我们有一个订单系统，<code>Orders</code> 表记录了所有订单信息。随着时间的推移，订单数据量急剧增加，但在实际业务中，超过一定时间的订单数据查询频率下降。为了提高数据库性能，我们决定将超过 1 年的订单数据从主表中移除并存档到归档表中。</p>
<h3 id="步骤：-2"><a href="#步骤：-2" class="headerlink" title="步骤："></a>步骤：</h3><ol>
<li>创建主表（<code>Orders</code>）和归档表（<code>ArchivedOrders</code>）。</li>
<li>定期将超过 1 年的订单数据从 <code>Orders</code> 表移到 <code>ArchivedOrders</code> 表。</li>
<li>确保归档数据的查询不会影响到主表的性能。</li>
</ol>
<h3 id="1-创建主表和归档表"><a href="#1-创建主表和归档表" class="headerlink" title="1. 创建主表和归档表"></a>1. 创建主表和归档表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建主订单表 Orders</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Orders</span><br><span class="line">(</span><br><span class="line">    OrderID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    CustomerID <span class="type">INT</span>,</span><br><span class="line">    OrderDate <span class="type">DATE</span>,</span><br><span class="line">    ProductID <span class="type">INT</span>,</span><br><span class="line">    TotalAmount <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    Status <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建归档表 ArchivedOrders</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ArchivedOrders</span><br><span class="line">(</span><br><span class="line">    OrderID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    CustomerID <span class="type">INT</span>,</span><br><span class="line">    OrderDate <span class="type">DATE</span>,</span><br><span class="line">    ProductID <span class="type">INT</span>,</span><br><span class="line">    TotalAmount <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    Status <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="2-归档操作（将超过-1-年的订单移至归档表）"><a href="#2-归档操作（将超过-1-年的订单移至归档表）" class="headerlink" title="2. 归档操作（将超过 1 年的订单移至归档表）"></a>2. 归档操作（将超过 1 年的订单移至归档表）</h3><p>为了定期将过期的订单移至归档表，可以使用定时任务（如 SQL Server Agent 作业）来执行这个操作。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 将超过 1 年的订单数据从 Orders 表移到 ArchivedOrders 表</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> ArchivedOrders (OrderID, CustomerID, OrderDate, ProductID, TotalAmount, Status)</span><br><span class="line"><span class="keyword">SELECT</span> OrderID, CustomerID, OrderDate, ProductID, TotalAmount, Status</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> OrderDate <span class="operator">&lt;</span> DATEADD(<span class="keyword">YEAR</span>, <span class="number">-1</span>, GETDATE());</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除 Orders 表中超过 1 年的订单数据</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> OrderDate <span class="operator">&lt;</span> DATEADD(<span class="keyword">YEAR</span>, <span class="number">-1</span>, GETDATE());</span><br></pre></td></tr></table></figure>

<p>这段代码会将 <code>Orders</code> 表中 <code>OrderDate</code> 小于当前日期 1 年的订单数据插入到 <code>ArchivedOrders</code> 表，并将这些数据从 <code>Orders</code> 表中删除。</p>
<h3 id="3-定时归档任务（使用-SQL-Server-Agent）"><a href="#3-定时归档任务（使用-SQL-Server-Agent）" class="headerlink" title="3. 定时归档任务（使用 SQL Server Agent）"></a>3. 定时归档任务（使用 SQL Server Agent）</h3><p>我们可以使用 SQL Server Agent 来创建一个定时任务，定期执行数据归档操作。例如，每天运行一次，将 1 年前的订单数据归档：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 在 SQL Server Agent 中创建作业来执行归档操作</span></span><br><span class="line">USE msdb;</span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXEC</span> sp_add_job</span><br><span class="line">    <span class="variable">@job</span>_name <span class="operator">=</span> N<span class="string">&#x27;ArchiveOldOrders&#x27;</span>;</span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXEC</span> sp_add_jobstep</span><br><span class="line">    <span class="variable">@job</span>_name <span class="operator">=</span> N<span class="string">&#x27;ArchiveOldOrders&#x27;</span>,</span><br><span class="line">    <span class="variable">@step</span>_name <span class="operator">=</span> N<span class="string">&#x27;ArchiveOrdersStep&#x27;</span>,</span><br><span class="line">    <span class="variable">@subsystem</span> <span class="operator">=</span> N<span class="string">&#x27;TSQL&#x27;</span>,</span><br><span class="line">    <span class="variable">@command</span> <span class="operator">=</span> N<span class="string">&#x27;</span></span><br><span class="line"><span class="string">        INSERT INTO ArchivedOrders (OrderID, CustomerID, OrderDate, ProductID, TotalAmount, Status)</span></span><br><span class="line"><span class="string">        SELECT OrderID, CustomerID, OrderDate, ProductID, TotalAmount, Status</span></span><br><span class="line"><span class="string">        FROM Orders</span></span><br><span class="line"><span class="string">        WHERE OrderDate &lt; DATEADD(YEAR, -1, GETDATE());</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        DELETE FROM Orders</span></span><br><span class="line"><span class="string">        WHERE OrderDate &lt; DATEADD(YEAR, -1, GETDATE());</span></span><br><span class="line"><span class="string">    &#x27;</span>,</span><br><span class="line">    <span class="variable">@database</span>_name <span class="operator">=</span> N<span class="string">&#x27;VGDB&#x27;</span>;</span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置作业的调度，例如每天运行一次</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_add_schedule</span><br><span class="line">    <span class="variable">@schedule</span>_name <span class="operator">=</span> N<span class="string">&#x27;ArchiveOrdersDaily&#x27;</span>,</span><br><span class="line">    <span class="variable">@enabled</span> <span class="operator">=</span> <span class="number">1</span>,</span><br><span class="line">    <span class="variable">@freq</span>_type <span class="operator">=</span> <span class="number">4</span>, <span class="comment">-- 每天</span></span><br><span class="line">    <span class="variable">@freq</span>_interval <span class="operator">=</span> <span class="number">1</span>, <span class="comment">-- 每天执行一次</span></span><br><span class="line">    <span class="variable">@active</span>_start_time <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXEC</span> sp_attach_schedule</span><br><span class="line">    <span class="variable">@job</span>_name <span class="operator">=</span> N<span class="string">&#x27;ArchiveOldOrders&#x27;</span>,</span><br><span class="line">    <span class="variable">@schedule</span>_name <span class="operator">=</span> N<span class="string">&#x27;ArchiveOrdersDaily&#x27;</span>;</span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 启动作业</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_start_job <span class="variable">@job</span>_name <span class="operator">=</span> N<span class="string">&#x27;ArchiveOldOrders&#x27;</span>;</span><br><span class="line">GO</span><br></pre></td></tr></table></figure>

<h3 id="4-查询归档数据"><a href="#4-查询归档数据" class="headerlink" title="4. 查询归档数据"></a>4. 查询归档数据</h3><p>归档后的数据依然可以查询，但不会影响主表的查询性能。为了查找某个客户的历史订单，可以查询归档表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询某个客户的历史订单</span></span><br><span class="line"><span class="keyword">SELECT</span> OrderID, CustomerID, OrderDate, ProductID, TotalAmount, Status</span><br><span class="line"><span class="keyword">FROM</span> ArchivedOrders</span><br><span class="line"><span class="keyword">WHERE</span> CustomerID <span class="operator">=</span> <span class="number">1001</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> OrderDate <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<h3 id="5-优化与注意事项"><a href="#5-优化与注意事项" class="headerlink" title="5. 优化与注意事项"></a>5. 优化与注意事项</h3><ul>
<li><strong>归档策略</strong>：可以根据实际业务需求选择合适的时间范围（例如，3 个月、6 个月或 1 年）。可以通过调整 <code>WHERE</code> 条件来修改归档规则。</li>
<li><strong>性能优化</strong>：定期归档操作可以减轻主表的负担，提高查询性能。定期删除旧数据也能减少主表的存储空间。</li>
<li><strong>归档数据的备份和恢复</strong>：归档数据同样需要定期备份，并能够在需要时恢复。确保归档表也包括足够的备份策略。</li>
</ul>
<h3 id="6-归档与清理数据的另一个选项：软删除"><a href="#6-归档与清理数据的另一个选项：软删除" class="headerlink" title="6. 归档与清理数据的另一个选项：软删除"></a>6. 归档与清理数据的另一个选项：软删除</h3><p>在某些情况下，数据归档后并没有从数据库中完全删除，而是标记为“已归档”或“已删除”。这种方法的优点是可以随时恢复数据，而不会丢失。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 在 Orders 表中添加 Archived 标志</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Orders</span><br><span class="line"><span class="keyword">ADD</span> Archived BIT <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将数据标记为已归档</span></span><br><span class="line"><span class="keyword">UPDATE</span> Orders</span><br><span class="line"><span class="keyword">SET</span> Archived <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">WHERE</span> OrderDate <span class="operator">&lt;</span> DATEADD(<span class="keyword">YEAR</span>, <span class="number">-1</span>, GETDATE());</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询未归档的数据</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Orders <span class="keyword">WHERE</span> Archived <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询归档数据</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Orders <span class="keyword">WHERE</span> Archived <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>通过这种方法，归档的订单仍然保留在主表中，但通过 <code>Archived</code> 字段可以区分已归档和未归档的订单。</p>
<h3 id="小结一下-3"><a href="#小结一下-3" class="headerlink" title="小结一下"></a>小结一下</h3><p>数据归档操作是管理大数据量数据库的一种有效策略。通过定期将历史数据从主数据库表中迁移到归档表，可以显著提高数据库的查询性能，同时确保历史数据得以保留，便于以后查询和审计。</p>
<h2 id="5-存储和硬件优化"><a href="#5-存储和硬件优化" class="headerlink" title="5. 存储和硬件优化"></a>5. 存储和硬件优化</h2><ul>
<li><strong>磁盘 I&#x2F;O 优化</strong>：数据库的性能受到磁盘 I&#x2F;O 的限制，尤其是在处理大量数据时。使用 SSD 存储比传统的硬盘（HDD）提供更快的 I&#x2F;O 性能。</li>
<li><strong>增加内存</strong>：增加 SQL Server 的内存，可以使数据库缓冲池更大，从而减少磁盘 I&#x2F;O，提升查询性能。</li>
<li><strong>使用 RAID 配置</strong>：使用 RAID 10 或其他 RAID 配置，确保数据读写的高效性和可靠性。</li>
</ul>
<p>存储和硬件优化是提升数据库性能的关键部分，尤其是在大规模数据处理的环境中。通过合理的硬件资源分配、存储结构优化以及数据库配置，可以显著提高性能。下面我们将针对一个电商平台的订单系统来讲解如何在存储和硬件层面优化 SQL Server。</p>
<h3 id="业务场景："><a href="#业务场景：" class="headerlink" title="业务场景："></a>业务场景：</h3><p>假设你有一个电商平台，订单数据存储在 SQL Server 中，订单数量日益增加，导致查询性能下降。在此场景中，我们可以通过以下方法进行存储和硬件优化。</p>
<h3 id="优化策略："><a href="#优化策略：" class="headerlink" title="优化策略："></a>优化策略：</h3><ol>
<li><strong>磁盘 I&#x2F;O 优化</strong>：<ul>
<li>使用 SSD 替代传统硬盘（HDD）以提高读写速度。</li>
<li>将数据文件、日志文件和临时文件存储在不同的物理磁盘上。</li>
</ul>
</li>
<li><strong>表和索引存储</strong>：<ul>
<li>使用适当的存储格式和文件组织方式，如分区表和表压缩。</li>
<li>将频繁访问的表和索引放置在高性能的磁盘上。</li>
</ul>
</li>
<li><strong>硬件资源配置</strong>：<ul>
<li>增加内存以支持更多的数据缓存，减少磁盘访问。</li>
<li>使用多核 CPU 以提高并发查询的处理能力。</li>
</ul>
</li>
<li><strong>数据压缩</strong>：<ul>
<li>在 SQL Server 中启用数据压缩，以减少磁盘空间的使用并提高 I&#x2F;O 性能。</li>
</ul>
</li>
</ol>
<h3 id="1-创建表并优化存储"><a href="#1-创建表并优化存储" class="headerlink" title="1. 创建表并优化存储"></a>1. 创建表并优化存储</h3><p>首先，我们创建订单表，并为订单表的 <code>OrderID</code> 列创建聚集索引。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建 Orders 表并优化存储</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Orders</span><br><span class="line">(</span><br><span class="line">    OrderID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY CLUSTERED,  <span class="comment">-- 聚集索引</span></span><br><span class="line">    CustomerID <span class="type">INT</span>,</span><br><span class="line">    OrderDate DATETIME,</span><br><span class="line">    ProductID <span class="type">INT</span>,</span><br><span class="line">    TotalAmount <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    Status <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">) </span><br><span class="line"><span class="keyword">ON</span> [<span class="keyword">PRIMARY</span>]</span><br><span class="line"><span class="keyword">WITH</span> (DATA_COMPRESSION <span class="operator">=</span> PAGE);  <span class="comment">-- 启用数据页压缩以节省空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 启用非聚集索引，用于优化查询</span></span><br><span class="line"><span class="keyword">CREATE</span> NONCLUSTERED INDEX idx_OrderDate</span><br><span class="line"><span class="keyword">ON</span> Orders(OrderDate)</span><br><span class="line"><span class="keyword">WITH</span> (DATA_COMPRESSION <span class="operator">=</span> PAGE);  <span class="comment">-- 同样启用数据压缩</span></span><br></pre></td></tr></table></figure>

<p>通过使用 <code>DATA_COMPRESSION = PAGE</code>，我们启用了 SQL Server 的数据压缩功能，以节省存储空间并提高磁盘 I&#x2F;O 性能。<code>PAGE</code> 压缩比 <code>ROW</code> 压缩更高效，适合大型数据表。</p>
<h3 id="2-分区表优化"><a href="#2-分区表优化" class="headerlink" title="2. 分区表优化"></a>2. 分区表优化</h3><p>在订单数据量不断增加的情况下，我们可以将订单表进行分区。根据 <code>OrderDate</code> 列将数据划分为不同的分区，以减少查询时的扫描范围，提高查询效率。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建分区函数</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PARTITION</span> <span class="keyword">FUNCTION</span> pf_OrderDate (DATETIME)</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">RANGE</span> <span class="keyword">RIGHT</span> <span class="keyword">FOR</span> <span class="keyword">VALUES</span> (<span class="string">&#x27;2022-01-01&#x27;</span>, <span class="string">&#x27;2023-01-01&#x27;</span>, <span class="string">&#x27;2024-01-01&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建分区方案</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PARTITION</span> SCHEME ps_OrderDate</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">PARTITION</span> pf_OrderDate</span><br><span class="line"><span class="keyword">TO</span> ([<span class="keyword">PRIMARY</span>], [<span class="keyword">PRIMARY</span>], [<span class="keyword">PRIMARY</span>], [<span class="keyword">PRIMARY</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建分区表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Orders</span><br><span class="line">(</span><br><span class="line">    OrderID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY CLUSTERED, </span><br><span class="line">    CustomerID <span class="type">INT</span>,</span><br><span class="line">    OrderDate DATETIME,</span><br><span class="line">    ProductID <span class="type">INT</span>,</span><br><span class="line">    TotalAmount <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    Status <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">) </span><br><span class="line"><span class="keyword">ON</span> ps_OrderDate(OrderDate);  <span class="comment">-- 按 OrderDate 列进行分区</span></span><br></pre></td></tr></table></figure>

<p>在此代码中，我们根据 <code>OrderDate</code> 列的年份划分了不同的分区（如 2022 年、2023 年和 2024 年的订单数据）。这样可以使查询在某一特定时间范围内的性能更高，因为 SQL Server 只需要扫描相关分区的数据，而不是整个表。</p>
<h3 id="3-硬件优化配置"><a href="#3-硬件优化配置" class="headerlink" title="3. 硬件优化配置"></a>3. 硬件优化配置</h3><h4 id="3-1-确保使用-SSD-磁盘"><a href="#3-1-确保使用-SSD-磁盘" class="headerlink" title="3.1. 确保使用 SSD 磁盘"></a>3.1. 确保使用 SSD 磁盘</h4><p>SSD 磁盘比传统硬盘的读写速度快，因此将数据库的主要数据文件、日志文件和临时文件分别存储在不同的磁盘上（最好是 SSD）可以提高性能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 将 SQL Server 数据文件 (.mdf) 存储在 SSD 磁盘</span><br><span class="line">-- 将日志文件 (.ldf) 存储在 SSD 磁盘</span><br><span class="line">-- 将临时数据库文件 (.ndf) 存储在 SSD 磁盘</span><br></pre></td></tr></table></figure>

<h4 id="3-2-配置-SQL-Server-内存"><a href="#3-2-配置-SQL-Server-内存" class="headerlink" title="3.2. 配置 SQL Server 内存"></a>3.2. 配置 SQL Server 内存</h4><p>将 SQL Server 的内存设置为最大化，以便更多数据可以缓存在内存中，从而减少磁盘 I&#x2F;O。以下为如何设置 SQL Server 的最大内存配置：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看当前内存设置</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;show advanced options&#x27;</span>, <span class="number">1</span>;</span><br><span class="line">RECONFIGURE;</span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;max server memory (MB)&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置最大内存为 16 GB</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;max server memory (MB)&#x27;</span>, <span class="number">16384</span>;</span><br><span class="line">RECONFIGURE;</span><br></pre></td></tr></table></figure>

<p>通过适当的内存配置，SQL Server 可以将更多数据缓存在内存中，从而减少对磁盘的访问，提高查询响应速度。</p>
<h4 id="3-3-配置-SQL-Server-并行处理"><a href="#3-3-配置-SQL-Server-并行处理" class="headerlink" title="3.3. 配置 SQL Server 并行处理"></a>3.3. 配置 SQL Server 并行处理</h4><p>如果服务器具有多核 CPU，可以通过设置 SQL Server 允许更多的并行查询操作，从而提高多线程查询的处理能力。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看当前并行度配置</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;max degree of parallelism&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置为 4，允许最多 4 个 CPU 并行处理查询</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;max degree of parallelism&#x27;</span>, <span class="number">4</span>;</span><br><span class="line">RECONFIGURE;</span><br></pre></td></tr></table></figure>

<h3 id="4-磁盘-I-x2F-O-优化：分开存储数据文件、日志文件和临时文件"><a href="#4-磁盘-I-x2F-O-优化：分开存储数据文件、日志文件和临时文件" class="headerlink" title="4. 磁盘 I&#x2F;O 优化：分开存储数据文件、日志文件和临时文件"></a>4. 磁盘 I&#x2F;O 优化：分开存储数据文件、日志文件和临时文件</h3><p>磁盘 I&#x2F;O 是数据库性能的瓶颈之一。为了提高数据库的性能，最好将数据文件、日志文件和临时文件存储在不同的物理磁盘上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 数据文件 (.mdf) 存储在磁盘 A</span><br><span class="line">-- 日志文件 (.ldf) 存储在磁盘 B</span><br><span class="line">-- 临时数据库文件 (.ndf) 存储在磁盘 C</span><br></pre></td></tr></table></figure>

<h3 id="5-数据备份和恢复优化"><a href="#5-数据备份和恢复优化" class="headerlink" title="5. 数据备份和恢复优化"></a>5. 数据备份和恢复优化</h3><p>确保定期备份数据，并使用增量备份、差异备份等方式以减少备份时的磁盘负担。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 进行完整备份</span></span><br><span class="line">BACKUP DATABASE VGDB <span class="keyword">TO</span> DISK <span class="operator">=</span> <span class="string">&#x27;D:\Backups\VGDB_full.bak&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 进行差异备份</span></span><br><span class="line">BACKUP DATABASE WGDB <span class="keyword">TO</span> DISK <span class="operator">=</span> <span class="string">&#x27;D:\Backups\VGDB_diff.bak&#x27;</span> <span class="keyword">WITH</span> DIFFERENTIAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 进行事务日志备份</span></span><br><span class="line">BACKUP LOG VGDB <span class="keyword">TO</span> DISK <span class="operator">=</span> <span class="string">&#x27;D:\Backups\VGDB_log.trn&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>通过这种方法，可以在系统崩溃时快速恢复数据，同时减少备份过程中对硬盘 I&#x2F;O 性能的影响。</p>
<h3 id="6-监控和维护"><a href="#6-监控和维护" class="headerlink" title="6. 监控和维护"></a>6. 监控和维护</h3><p>定期监控 SQL Server 的性能，并根据硬件和存储需求做出相应的调整。通过 SQL Server 的动态管理视图（DMV）来监控 I&#x2F;O 性能、查询执行计划、索引使用情况等。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看磁盘 I/O 状况</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sys.dm_io_virtual_file_stats(<span class="keyword">NULL</span>, <span class="keyword">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看查询执行计划的缓存</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sys.dm_exec_query_stats;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看当前的索引使用情况</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sys.dm_db_index_usage_stats;</span><br></pre></td></tr></table></figure>

<h3 id="小结一下-4"><a href="#小结一下-4" class="headerlink" title="小结一下"></a>小结一下</h3><p>通过存储和硬件优化，可以显著提升 SQL Server 数据库的性能。关键的优化措施包括使用 SSD 磁盘、将数据文件、日志文件和临时文件分开存储、启用数据压缩、使用分区表来提高查询效率以及调整内存和并行处理配置等。定期的维护和监控也能帮助你发现性能瓶颈并作出相应调整。</p>
<h2 id="6-数据库参数和配置优化"><a href="#6-数据库参数和配置优化" class="headerlink" title="6. 数据库参数和配置优化"></a>6. 数据库参数和配置优化</h2><ul>
<li><strong>调整最大并发连接数</strong>：确保 SQL Server 配置了足够的最大并发连接数，避免过多连接时导致性能下降。</li>
<li><strong>设置合适的内存限制</strong>：为 SQL Server 配置足够的内存（<code>max server memory</code>），避免内存溢出或过度使用磁盘交换。</li>
<li><strong>自动更新统计信息</strong>：确保 SQL Server 自动更新查询的统计信息（<code>AUTO_UPDATE_STATISTICS</code>），以便查询优化器选择最优执行计划。</li>
</ul>
<p>数据库参数和配置优化是确保数据库系统性能达到最佳状态的重要步骤。在高并发、高负载的场景下，合理的配置可以显著提高数据库性能，减少响应时间和延迟。以下是基于一个电商平台订单系统的业务场景，如何通过优化数据库的参数和配置来提升性能的完整代码案例。</p>
<h3 id="业务场景：-1"><a href="#业务场景：-1" class="headerlink" title="业务场景："></a>业务场景：</h3><p>假设电商平台的订单量非常大，系统每天处理数百万个订单，数据库的性能和响应速度是系统正常运行的关键。为确保数据库性能，在 SQL Server 中进行参数和配置优化至关重要。</p>
<h3 id="优化策略：-1"><a href="#优化策略：-1" class="headerlink" title="优化策略："></a>优化策略：</h3><ol>
<li><strong>调整内存配置</strong>：通过配置 SQL Server 使用更多的内存来缓存数据，减少磁盘 I&#x2F;O。</li>
<li><strong>设置最大并行度</strong>：根据 CPU 核心数，调整 SQL Server 的并行查询处理能力。</li>
<li><strong>优化磁盘和存储配置</strong>：确保日志文件、数据文件和临时文件分开存储。</li>
<li><strong>启用自动数据库优化</strong>：确保数据库能够自动进行碎片整理、更新统计信息等任务。</li>
<li><strong>调整事务日志和恢复模式</strong>：确保数据库在发生故障时能够快速恢复。</li>
</ol>
<h3 id="1-调整内存配置"><a href="#1-调整内存配置" class="headerlink" title="1. 调整内存配置"></a>1. 调整内存配置</h3><p>内存配置优化是提高 SQL Server 性能的关键部分。通过增加 SQL Server 的最大内存，可以保证查询操作不会因为磁盘 I&#x2F;O 的瓶颈而导致性能问题。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看当前最大内存配置</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;show advanced options&#x27;</span>, <span class="number">1</span>;</span><br><span class="line">RECONFIGURE;</span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;max server memory (MB)&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置最大内存为 16 GB</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;max server memory (MB)&#x27;</span>, <span class="number">16384</span>;  <span class="comment">-- 16 GB</span></span><br><span class="line">RECONFIGURE;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，我们将 SQL Server 的最大内存设置为 16 GB。适当配置内存可以提高查询性能，减少磁盘的访问。</p>
<h3 id="2-设置最大并行度"><a href="#2-设置最大并行度" class="headerlink" title="2. 设置最大并行度"></a>2. 设置最大并行度</h3><p>SQL Server 可以利用多个 CPU 核心进行并行查询处理。通过合理设置并行度，可以提高大查询的处理能力。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看当前的最大并行度设置</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;max degree of parallelism&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置最大并行度为 4（适用于 4 核 CPU 的机器）</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;max degree of parallelism&#x27;</span>, <span class="number">4</span>;</span><br><span class="line">RECONFIGURE;</span><br></pre></td></tr></table></figure>

<p>通过此设置，SQL Server 可以在查询时利用最多 4 个 CPU 核心进行并行处理。如果你的服务器有更多核心，可以根据实际情况调整这个参数。</p>
<h3 id="3-调整事务日志和恢复模式"><a href="#3-调整事务日志和恢复模式" class="headerlink" title="3. 调整事务日志和恢复模式"></a>3. 调整事务日志和恢复模式</h3><p>对于电商平台而言，事务日志的优化至关重要。确保在进行大规模事务操作时，日志文件能够高效地处理，并且确保恢复模式符合业务需求。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看数据库的恢复模式</span></span><br><span class="line"><span class="keyword">SELECT</span> name, recovery_model_desc</span><br><span class="line"><span class="keyword">FROM</span> sys.databases</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;VGDB&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置恢复模式为简单恢复模式</span></span><br><span class="line"><span class="keyword">ALTER</span> DATABASE VGDB</span><br><span class="line"><span class="keyword">SET</span> RECOVERY SIMPLE;</span><br></pre></td></tr></table></figure>

<p>对于不需要完整备份的数据库，使用简单恢复模式可以减少日志文件的增长，减轻磁盘 I&#x2F;O 压力。</p>
<h3 id="4-配置自动数据库优化"><a href="#4-配置自动数据库优化" class="headerlink" title="4. 配置自动数据库优化"></a>4. 配置自动数据库优化</h3><p>确保数据库能够定期执行自动优化任务，如重建索引、更新统计信息等。定期优化可以提高数据库的查询性能，避免碎片化问题。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 启用自动更新统计信息</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;auto update statistics&#x27;</span>, <span class="number">1</span>;</span><br><span class="line">RECONFIGURE;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 启用自动创建统计信息</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;auto create statistics&#x27;</span>, <span class="number">1</span>;</span><br><span class="line">RECONFIGURE;</span><br></pre></td></tr></table></figure>

<p>通过启用自动更新统计信息和自动创建统计信息，可以确保 SQL Server 在执行查询时能够使用最新的执行计划，减少查询优化器的负担。</p>
<h3 id="5-配置磁盘和存储"><a href="#5-配置磁盘和存储" class="headerlink" title="5. 配置磁盘和存储"></a>5. 配置磁盘和存储</h3><p>确保 SQL Server 的数据文件、日志文件和临时文件存储在不同的磁盘上，特别是将日志文件和数据文件存储在高速磁盘（如 SSD）上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 将数据文件 (.mdf) 存储在磁盘 A（SSD）</span><br><span class="line">-- 将日志文件 (.ldf) 存储在磁盘 B（SSD）</span><br><span class="line">-- 将临时数据库文件 (.ndf) 存储在磁盘 C（SSD）</span><br></pre></td></tr></table></figure>

<p>通过将数据文件、日志文件和临时文件分别存储在不同的磁盘上，可以避免磁盘 I&#x2F;O 争用，提升数据库的整体性能。</p>
<h3 id="6-启用数据库压缩"><a href="#6-启用数据库压缩" class="headerlink" title="6. 启用数据库压缩"></a>6. 启用数据库压缩</h3><p>对于需要存储大量数据的电商平台，启用数据压缩可以减少存储空间并提高查询性能，尤其是在磁盘 I&#x2F;O 上。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 启用表压缩</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Orders REBUILD <span class="keyword">PARTITION</span> <span class="operator">=</span> <span class="keyword">ALL</span> <span class="keyword">WITH</span> (DATA_COMPRESSION <span class="operator">=</span> PAGE);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 启用索引压缩</span></span><br><span class="line"><span class="keyword">ALTER</span> INDEX <span class="keyword">ALL</span> <span class="keyword">ON</span> Orders REBUILD <span class="keyword">PARTITION</span> <span class="operator">=</span> <span class="keyword">ALL</span> <span class="keyword">WITH</span> (DATA_COMPRESSION <span class="operator">=</span> PAGE);</span><br></pre></td></tr></table></figure>

<p>通过启用数据压缩，我们可以有效节省存储空间，减少磁盘 I&#x2F;O 操作，并提高查询速度。</p>
<h3 id="7-配置自动维护任务"><a href="#7-配置自动维护任务" class="headerlink" title="7. 配置自动维护任务"></a>7. 配置自动维护任务</h3><p>SQL Server 提供了自动维护任务，如索引重建、数据库碎片整理等，可以通过 SQL Server Agent 定时任务来自动执行这些任务，保持数据库的高效运行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建一个定期执行的作业，执行索引重建任务</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_add_job <span class="variable">@job</span>_name <span class="operator">=</span> <span class="string">&#x27;RebuildIndexes&#x27;</span>, <span class="variable">@enabled</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">EXEC</span> sp_add_jobstep <span class="variable">@job</span>_name <span class="operator">=</span> <span class="string">&#x27;RebuildIndexes&#x27;</span>, </span><br><span class="line">    <span class="variable">@step</span>_name <span class="operator">=</span> <span class="string">&#x27;RebuildIndexStep&#x27;</span>, </span><br><span class="line">    <span class="variable">@subsystem</span> <span class="operator">=</span> <span class="string">&#x27;TSQL&#x27;</span>, </span><br><span class="line">    <span class="variable">@command</span> <span class="operator">=</span> <span class="string">&#x27;ALTER INDEX ALL ON Orders REBUILD&#x27;</span>,</span><br><span class="line">    <span class="variable">@retry</span>_attempts <span class="operator">=</span> <span class="number">3</span>, </span><br><span class="line">    <span class="variable">@retry</span>_interval <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置作业运行频率：每天凌晨 2 点执行</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_add_schedule <span class="variable">@schedule</span>_name <span class="operator">=</span> <span class="string">&#x27;RebuildIndexSchedule&#x27;</span>,</span><br><span class="line">    <span class="variable">@enabled</span> <span class="operator">=</span> <span class="number">1</span>,</span><br><span class="line">    <span class="variable">@freq</span>_type <span class="operator">=</span> <span class="number">4</span>, </span><br><span class="line">    <span class="variable">@freq</span>_interval <span class="operator">=</span> <span class="number">1</span>, </span><br><span class="line">    <span class="variable">@active</span>_start_time <span class="operator">=</span> <span class="number">20000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXEC</span> sp_attach_schedule <span class="variable">@job</span>_name <span class="operator">=</span> <span class="string">&#x27;RebuildIndexes&#x27;</span>, <span class="variable">@schedule</span>_name <span class="operator">=</span> <span class="string">&#x27;RebuildIndexSchedule&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>这个作业将在每天凌晨 2 点执行，重建 <code>Orders</code> 表上的所有索引，从而避免因索引碎片而降低查询性能。</p>
<h3 id="8-启用即时日志备份"><a href="#8-启用即时日志备份" class="headerlink" title="8. 启用即时日志备份"></a>8. 启用即时日志备份</h3><p>对于生产环境，尤其是电商平台，确保日志备份及时执行至关重要。启用日志备份可以保证在数据库发生故障时进行快速恢复。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 设置事务日志备份</span></span><br><span class="line">BACKUP LOG VGDB <span class="keyword">TO</span> DISK <span class="operator">=</span> <span class="string">&#x27;D:\Backups\YourDatabase_log.trn&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>通过定期执行事务日志备份，可以确保在发生故障时，数据库能够恢复到最新的状态。</p>
<h3 id="9-启用数据库缓存"><a href="#9-启用数据库缓存" class="headerlink" title="9. 启用数据库缓存"></a>9. 启用数据库缓存</h3><p>SQL Server 会缓存查询结果和数据页，通过调整缓存策略来优化性能。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看缓存的页面数量</span></span><br><span class="line">DBCC SHOW_STATISTICS(<span class="string">&#x27;Orders&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 强制清除缓存（有时可以用于测试）</span></span><br><span class="line">DBCC FREEPROCCACHE;</span><br><span class="line">DBCC DROPCLEANBUFFERS;</span><br></pre></td></tr></table></figure>

<p>在日常操作中，我们不建议经常清除缓存，但可以在需要时清除缓存来测试性能优化效果。</p>
<h3 id="小结一下-5"><a href="#小结一下-5" class="headerlink" title="小结一下"></a>小结一下</h3><p>通过优化 SQL Server 的配置和参数，可以显著提升电商平台的数据库性能。关键的优化措施包括调整内存和并行度、优化磁盘存储和日志配置、启用数据压缩、定期执行自动数据库优化任务、配置数据库压缩和定期备份等。根据业务需求和硬件资源进行合理配置，以确保数据库在高并发、高负载的环境中能够稳定高效地运行。</p>
<h2 id="7-批量数据处理"><a href="#7-批量数据处理" class="headerlink" title="7. 批量数据处理"></a>7. 批量数据处理</h2><ul>
<li><strong>批量插入&#x2F;更新操作</strong>：在处理大量数据时，可以使用批量插入或更新操作，而不是一行一行地进行。这能显著提高数据的加载速度。</li>
<li><strong>避免大事务</strong>：对于大量的数据修改，避免使用大事务，因为大事务可能会导致锁竞争、日志文件过大等问题。使用小批次事务进行操作。</li>
</ul>
<p>批量数据处理在大规模应用中是不可避免的，尤其是像电商平台、金融系统等业务场景，通常需要进行大批量的订单、用户信息处理等。批量操作能够显著提高数据处理效率，但也需要谨慎设计，以确保性能和稳定性。</p>
<h3 id="业务场景：-2"><a href="#业务场景：-2" class="headerlink" title="业务场景："></a>业务场景：</h3><p>假设在电商平台中，订单信息需要进行批量处理，比如批量更新订单状态、批量删除失效订单、批量插入订单数据等。通过设计合适的批量操作，能够有效减少单次操作的数据库访问次数，提升系统的响应能力。</p>
<h3 id="优化方案："><a href="#优化方案：" class="headerlink" title="优化方案："></a>优化方案：</h3><ol>
<li><strong>批量插入数据</strong>：通过 <code>BULK INSERT</code> 或者 <code>INSERT INTO</code> 多行插入方式，减少多次单独插入操作带来的性能瓶颈。</li>
<li><strong>批量更新数据</strong>：使用 <code>UPDATE</code> 操作一次性更新多条记录。</li>
<li><strong>批量删除数据</strong>：批量删除过期的订单，或者批量删除无效的用户信息。</li>
</ol>
<p>以下是具体的 SQL Server 批量数据处理的代码案例。</p>
<h3 id="1-批量插入数据"><a href="#1-批量插入数据" class="headerlink" title="1. 批量插入数据"></a>1. 批量插入数据</h3><p>批量插入可以减少大量单独插入操作的时间开销，通过 <code>INSERT INTO</code> 语句一次插入多条数据。</p>
<h4 id="示例：批量插入订单数据"><a href="#示例：批量插入订单数据" class="headerlink" title="示例：批量插入订单数据"></a>示例：批量插入订单数据</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 假设 Orders 表结构如下：OrderID INT, CustomerID INT, OrderDate DATETIME, OrderStatus VARCHAR(20)</span></span><br><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@OrderData</span> <span class="keyword">TABLE</span> (OrderID <span class="type">INT</span>, CustomerID <span class="type">INT</span>, OrderDate DATETIME, OrderStatus <span class="type">VARCHAR</span>(<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将订单数据插入临时表</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="variable">@OrderData</span> (OrderID, CustomerID, OrderDate, OrderStatus)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    (<span class="number">1</span>, <span class="number">101</span>, <span class="string">&#x27;2024-11-01&#x27;</span>, <span class="string">&#x27;Pending&#x27;</span>),</span><br><span class="line">    (<span class="number">2</span>, <span class="number">102</span>, <span class="string">&#x27;2024-11-02&#x27;</span>, <span class="string">&#x27;Shipped&#x27;</span>),</span><br><span class="line">    (<span class="number">3</span>, <span class="number">103</span>, <span class="string">&#x27;2024-11-03&#x27;</span>, <span class="string">&#x27;Delivered&#x27;</span>),</span><br><span class="line">    (<span class="number">4</span>, <span class="number">104</span>, <span class="string">&#x27;2024-11-04&#x27;</span>, <span class="string">&#x27;Cancelled&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 批量插入数据到 Orders 表</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Orders (OrderID, CustomerID, OrderDate, OrderStatus)</span><br><span class="line"><span class="keyword">SELECT</span> OrderID, CustomerID, OrderDate, OrderStatus</span><br><span class="line"><span class="keyword">FROM</span> <span class="variable">@OrderData</span>;</span><br></pre></td></tr></table></figure>

<p>在此例中，我们先将数据插入临时表 <code>@OrderData</code>，然后通过 <code>INSERT INTO SELECT</code> 语句批量插入 <code>Orders</code> 表。这种方式可以大大减少数据库访问的次数。</p>
<h3 id="2-批量更新数据"><a href="#2-批量更新数据" class="headerlink" title="2. 批量更新数据"></a>2. 批量更新数据</h3><p>批量更新操作通常用于修改多个记录中的某些字段，避免多次单独更新。</p>
<h4 id="示例：批量更新订单状态"><a href="#示例：批量更新订单状态" class="headerlink" title="示例：批量更新订单状态"></a>示例：批量更新订单状态</h4><p>假设需要批量更新所有未发货的订单状态为 “Shipped”，可以通过如下 SQL 来实现：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 批量更新订单状态</span></span><br><span class="line"><span class="keyword">UPDATE</span> Orders</span><br><span class="line"><span class="keyword">SET</span> OrderStatus <span class="operator">=</span> <span class="string">&#x27;Shipped&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> OrderStatus <span class="operator">=</span> <span class="string">&#x27;Pending&#x27;</span> <span class="keyword">AND</span> OrderDate <span class="operator">&lt;</span> <span class="string">&#x27;2024-11-01&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>该操作会一次性更新所有符合条件的记录，避免多次单独更新操作带来的性能问题。</p>
<h3 id="3-批量删除数据"><a href="#3-批量删除数据" class="headerlink" title="3. 批量删除数据"></a>3. 批量删除数据</h3><p>在某些场景下，我们需要批量删除某些过期或无效的数据。例如，删除 30 天之前的过期订单。</p>
<h4 id="示例：批量删除过期订单"><a href="#示例：批量删除过期订单" class="headerlink" title="示例：批量删除过期订单"></a>示例：批量删除过期订单</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除过期的订单</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> OrderDate <span class="operator">&lt;</span> DATEADD(<span class="keyword">DAY</span>, <span class="number">-30</span>, GETDATE()) <span class="keyword">AND</span> OrderStatus <span class="operator">=</span> <span class="string">&#x27;Completed&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们删除所有已完成且订单日期超过 30 天的订单。这种批量删除操作比逐个删除要高效得多。</p>
<h3 id="4-批量处理逻辑优化"><a href="#4-批量处理逻辑优化" class="headerlink" title="4. 批量处理逻辑优化"></a>4. 批量处理逻辑优化</h3><p>有时批量操作的数据量非常大，直接处理可能导致性能问题或数据库锁争用。可以考虑分批次执行操作来减轻系统负担。</p>
<h4 id="示例：按批次处理订单数据"><a href="#示例：按批次处理订单数据" class="headerlink" title="示例：按批次处理订单数据"></a>示例：按批次处理订单数据</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@BatchSize</span> <span class="type">INT</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@StartRow</span> <span class="type">INT</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@TotalRows</span> <span class="type">INT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 计算总记录数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@TotalRows</span> <span class="operator">=</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> Orders <span class="keyword">WHERE</span> OrderStatus <span class="operator">=</span> <span class="string">&#x27;Pending&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 循环批量处理数据</span></span><br><span class="line">WHILE <span class="variable">@StartRow</span> <span class="operator">&lt;</span> <span class="variable">@TotalRows</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- 批量更新 1000 条数据</span></span><br><span class="line">    <span class="keyword">UPDATE</span> TOP (<span class="variable">@BatchSize</span>) Orders</span><br><span class="line">    <span class="keyword">SET</span> OrderStatus <span class="operator">=</span> <span class="string">&#x27;Shipped&#x27;</span></span><br><span class="line">    <span class="keyword">WHERE</span> OrderStatus <span class="operator">=</span> <span class="string">&#x27;Pending&#x27;</span> <span class="keyword">AND</span> OrderDate <span class="operator">&lt;</span> <span class="string">&#x27;2024-11-01&#x27;</span> <span class="keyword">AND</span> OrderID <span class="operator">&gt;</span> <span class="variable">@StartRow</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 更新已处理的行数</span></span><br><span class="line">    <span class="keyword">SET</span> <span class="variable">@StartRow</span> <span class="operator">=</span> <span class="variable">@StartRow</span> <span class="operator">+</span> <span class="variable">@BatchSize</span>;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<p>通过分批次处理（每次处理 1000 条记录），可以避免一次性处理大量数据时造成的性能瓶颈或数据库锁的问题。适用于需要批量更新大量记录的情况。</p>
<h3 id="5-使用事务保证数据一致性"><a href="#5-使用事务保证数据一致性" class="headerlink" title="5. 使用事务保证数据一致性"></a>5. 使用事务保证数据一致性</h3><p>对于批量操作来说，通常需要使用事务来保证数据一致性，即要么全部成功，要么全部失败。</p>
<h4 id="示例：批量插入订单并使用事务"><a href="#示例：批量插入订单并使用事务" class="headerlink" title="示例：批量插入订单并使用事务"></a>示例：批量插入订单并使用事务</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> TRY</span><br><span class="line">    <span class="comment">-- 假设 Orders 表结构：OrderID INT, CustomerID INT, OrderDate DATETIME, OrderStatus VARCHAR(20)</span></span><br><span class="line">    <span class="keyword">DECLARE</span> <span class="variable">@OrderData</span> <span class="keyword">TABLE</span> (OrderID <span class="type">INT</span>, CustomerID <span class="type">INT</span>, OrderDate DATETIME, OrderStatus <span class="type">VARCHAR</span>(<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 批量插入订单数据</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="variable">@OrderData</span> (OrderID, CustomerID, OrderDate, OrderStatus)</span><br><span class="line">    <span class="keyword">VALUES</span></span><br><span class="line">        (<span class="number">5</span>, <span class="number">105</span>, <span class="string">&#x27;2024-11-05&#x27;</span>, <span class="string">&#x27;Pending&#x27;</span>),</span><br><span class="line">        (<span class="number">6</span>, <span class="number">106</span>, <span class="string">&#x27;2024-11-06&#x27;</span>, <span class="string">&#x27;Pending&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> Orders (OrderID, CustomerID, OrderDate, OrderStatus)</span><br><span class="line">    <span class="keyword">SELECT</span> OrderID, CustomerID, OrderDate, OrderStatus</span><br><span class="line">    <span class="keyword">FROM</span> <span class="variable">@OrderData</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 提交事务</span></span><br><span class="line">    <span class="keyword">COMMIT</span> TRANSACTION;</span><br><span class="line"><span class="keyword">END</span> TRY</span><br><span class="line"><span class="keyword">BEGIN</span> CATCH</span><br><span class="line">    <span class="comment">-- 错误处理并回滚事务</span></span><br><span class="line">    <span class="keyword">ROLLBACK</span> TRANSACTION;</span><br><span class="line">    PRINT <span class="string">&#x27;Error occurred: &#x27;</span> <span class="operator">+</span> ERROR_MESSAGE();</span><br><span class="line"><span class="keyword">END</span> CATCH;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，批量插入操作被包含在一个事务中，确保插入操作的原子性，即要么全部成功，要么全部失败。如果在执行过程中发生错误，会回滚事务，避免数据不一致的情况。</p>
<h3 id="小结一下-6"><a href="#小结一下-6" class="headerlink" title="小结一下"></a>小结一下</h3><p>批量数据处理是提高 SQL Server 性能的有效手段，尤其是在数据量庞大的电商平台等业务场景中。通过合理使用批量插入、批量更新和批量删除操作，可以大幅度提高数据库的处理效率，减少数据库的 I&#x2F;O 操作次数和锁竞争。在执行批量操作时，记得通过事务保证数据的一致性，分批处理可以进一步优化大规模数据的处理性能。</p>
<h2 id="8-清理无用数据"><a href="#8-清理无用数据" class="headerlink" title="8. 清理无用数据"></a>8. 清理无用数据</h2><ul>
<li><strong>删除过期数据</strong>：定期清理过期或不再需要的数据，减少数据库的大小和查询的复杂性。</li>
<li><strong>清理数据库碎片</strong>：随着数据的增删，表和索引的碎片会增加，影响性能。定期重建索引或重新组织索引，减少碎片。</li>
</ul>
<p>清理无用数据是数据库维护中的常见任务，特别是在处理历史数据、过期记录或冗余数据时。定期清理无用数据不仅能够节省存储空间，还能提高数据库性能，避免无用数据对查询、索引等造成不必要的影响。</p>
<h3 id="业务场景：-3"><a href="#业务场景：-3" class="headerlink" title="业务场景："></a>业务场景：</h3><p>假设我们在一个电商平台中，用户的订单数据每年都会生成大量记录。为了避免订单表过于庞大，且不再使用的订单记录（比如 3 年之前的订单）会占用大量存储空间，我们需要定期清理这些过期订单数据。</p>
<h3 id="优化方案：-1"><a href="#优化方案：-1" class="headerlink" title="优化方案："></a>优化方案：</h3><ol>
<li><strong>删除过期数据</strong>：定期删除超过一定时间的订单数据（比如 3 年前的订单）。</li>
<li><strong>归档过期数据</strong>：将过期的订单数据移到一个历史表或外部存储中，保留必要的历史信息。</li>
</ol>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="1-定期删除过期数据"><a href="#1-定期删除过期数据" class="headerlink" title="1. 定期删除过期数据"></a>1. 定期删除过期数据</h4><p>假设我们的 <code>Orders</code> 表有字段 <code>OrderDate</code> 来记录订单的创建时间，<code>OrderStatus</code> 来标识订单状态。我们可以每月清理 3 年前的已完成或已取消的订单。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除 3 年前已完成或已取消的订单</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> OrderDate <span class="operator">&lt;</span> DATEADD(<span class="keyword">YEAR</span>, <span class="number">-3</span>, GETDATE()) </span><br><span class="line">    <span class="keyword">AND</span> OrderStatus <span class="keyword">IN</span> (<span class="string">&#x27;Completed&#x27;</span>, <span class="string">&#x27;Cancelled&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>DATEADD(YEAR, -3, GETDATE())</code> 会计算出当前日期 3 年前的日期，所有在此日期之前且状态为 <code>&#39;Completed&#39;</code> 或 <code>&#39;Cancelled&#39;</code> 的订单将被删除。</p>
<h4 id="2-定期归档过期数据"><a href="#2-定期归档过期数据" class="headerlink" title="2. 定期归档过期数据"></a>2. 定期归档过期数据</h4><p>如果删除数据不符合业务需求，可以选择将数据归档。比如，将 3 年前的订单转移到 <code>ArchivedOrders</code> 表。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 将 3 年前的已完成或已取消的订单移动到 ArchivedOrders 表</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> ArchivedOrders (OrderID, CustomerID, OrderDate, OrderStatus)</span><br><span class="line"><span class="keyword">SELECT</span> OrderID, CustomerID, OrderDate, OrderStatus</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> OrderDate <span class="operator">&lt;</span> DATEADD(<span class="keyword">YEAR</span>, <span class="number">-3</span>, GETDATE()) </span><br><span class="line">    <span class="keyword">AND</span> OrderStatus <span class="keyword">IN</span> (<span class="string">&#x27;Completed&#x27;</span>, <span class="string">&#x27;Cancelled&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除已归档的订单</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> OrderDate <span class="operator">&lt;</span> DATEADD(<span class="keyword">YEAR</span>, <span class="number">-3</span>, GETDATE()) </span><br><span class="line">    <span class="keyword">AND</span> OrderStatus <span class="keyword">IN</span> (<span class="string">&#x27;Completed&#x27;</span>, <span class="string">&#x27;Cancelled&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>首先将符合条件的订单数据插入到 <code>ArchivedOrders</code> 表，然后再删除原 <code>Orders</code> 表中的这些数据。这样可以保持主表的清洁，减少存储压力，并保留历史数据。</p>
<h4 id="3-使用触发器自动清理无用数据"><a href="#3-使用触发器自动清理无用数据" class="headerlink" title="3. 使用触发器自动清理无用数据"></a>3. 使用触发器自动清理无用数据</h4><p>为了自动化清理操作，可以使用数据库触发器（Trigger），例如，在每次插入数据时检查数据是否超期，如果超期则触发清理操作。触发器可以周期性地执行清理任务。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建触发器，每天检查并删除 3 年前的订单</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> CleanOldOrders</span><br><span class="line"><span class="keyword">ON</span> Orders</span><br><span class="line">AFTER <span class="keyword">INSERT</span>, <span class="keyword">UPDATE</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- 清理过期订单：删除 3 年前的已完成或已取消订单</span></span><br><span class="line">    <span class="keyword">DELETE</span> <span class="keyword">FROM</span> Orders</span><br><span class="line">    <span class="keyword">WHERE</span> OrderDate <span class="operator">&lt;</span> DATEADD(<span class="keyword">YEAR</span>, <span class="number">-3</span>, GETDATE()) </span><br><span class="line">        <span class="keyword">AND</span> OrderStatus <span class="keyword">IN</span> (<span class="string">&#x27;Completed&#x27;</span>, <span class="string">&#x27;Cancelled&#x27;</span>);</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<p>此触发器将在 <code>Orders</code> 表每次执行插入或更新操作时触发，自动检查并清理过期的订单。</p>
<h4 id="4-分批次清理无用数据"><a href="#4-分批次清理无用数据" class="headerlink" title="4. 分批次清理无用数据"></a>4. 分批次清理无用数据</h4><p>如果订单数据量非常大，直接删除可能会导致性能瓶颈或数据库锁定问题。在这种情况下，可以分批次删除数据，以减少单次删除操作的负载。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@BatchSize</span> <span class="type">INT</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@StartRow</span> <span class="type">INT</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@TotalRows</span> <span class="type">INT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 计算需要删除的记录数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@TotalRows</span> <span class="operator">=</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> OrderDate <span class="operator">&lt;</span> DATEADD(<span class="keyword">YEAR</span>, <span class="number">-3</span>, GETDATE()) </span><br><span class="line">    <span class="keyword">AND</span> OrderStatus <span class="keyword">IN</span> (<span class="string">&#x27;Completed&#x27;</span>, <span class="string">&#x27;Cancelled&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分批次删除</span></span><br><span class="line">WHILE <span class="variable">@StartRow</span> <span class="operator">&lt;</span> <span class="variable">@TotalRows</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- 批量删除 1000 条数据</span></span><br><span class="line">    <span class="keyword">DELETE</span> TOP (<span class="variable">@BatchSize</span>) <span class="keyword">FROM</span> Orders</span><br><span class="line">    <span class="keyword">WHERE</span> OrderDate <span class="operator">&lt;</span> DATEADD(<span class="keyword">YEAR</span>, <span class="number">-3</span>, GETDATE()) </span><br><span class="line">        <span class="keyword">AND</span> OrderStatus <span class="keyword">IN</span> (<span class="string">&#x27;Completed&#x27;</span>, <span class="string">&#x27;Cancelled&#x27;</span>)</span><br><span class="line">        <span class="keyword">AND</span> OrderID <span class="operator">&gt;</span> <span class="variable">@StartRow</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 更新已删除的行数</span></span><br><span class="line">    <span class="keyword">SET</span> <span class="variable">@StartRow</span> <span class="operator">=</span> <span class="variable">@StartRow</span> <span class="operator">+</span> <span class="variable">@BatchSize</span>;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<p>通过分批次处理删除操作，每次删除少量记录，减少对数据库性能的影响，并避免长时间锁定表。</p>
<h4 id="5-使用作业调度器定期清理无用数据"><a href="#5-使用作业调度器定期清理无用数据" class="headerlink" title="5. 使用作业调度器定期清理无用数据"></a>5. 使用作业调度器定期清理无用数据</h4><p>如果您使用的是 SQL Server，可以使用作业调度器（SQL Server Agent）定期执行清理任务。首先，您可以创建一个存储过程来执行数据清理操作。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> CleanOldOrders</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DELETE</span> <span class="keyword">FROM</span> Orders</span><br><span class="line">    <span class="keyword">WHERE</span> OrderDate <span class="operator">&lt;</span> DATEADD(<span class="keyword">YEAR</span>, <span class="number">-3</span>, GETDATE()) </span><br><span class="line">        <span class="keyword">AND</span> OrderStatus <span class="keyword">IN</span> (<span class="string">&#x27;Completed&#x27;</span>, <span class="string">&#x27;Cancelled&#x27;</span>);</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<p>然后，在 SQL Server Management Studio 中设置定期作业（例如每天午夜运行该存储过程），这样可以确保无用数据定期清理。</p>
<h3 id="小结一下-7"><a href="#小结一下-7" class="headerlink" title="小结一下"></a>小结一下</h3><p>清理无用数据不仅有助于节省存储空间，还能提高数据库性能。根据实际业务需求，我们可以选择删除、归档或分批处理的方式来清理数据。特别是对于大数据量的表，分批清理和定期作业调度可以有效减少系统的负担。</p>
<h2 id="9-使用缓存"><a href="#9-使用缓存" class="headerlink" title="9. 使用缓存"></a>9. 使用缓存</h2><ul>
<li><strong>缓存常用查询结果</strong>：对于高频次查询，可以将查询结果缓存到内存中，避免每次查询都去数据库中查找。</li>
<li><strong>应用层缓存</strong>：使用 Redis 或 Memcached 等缓存系统，将一些常用数据缓存在内存中，从而减少数据库访问频率。</li>
</ul>
<p>在实际业务中，缓存是提高系统性能的常用手段，特别是对于高频访问的热点数据，通过将其存储在缓存中，可以减少数据库查询的次数和压力，提高响应速度。</p>
<h3 id="业务场景-4"><a href="#业务场景-4" class="headerlink" title="业务场景"></a>业务场景</h3><p>假设我们有一个电商平台，用户在浏览商品详情时，频繁地查询商品的基本信息（如价格、库存、描述等）。由于商品信息变化较少，而查询请求频繁，因此将商品信息缓存起来能够有效提高系统的性能。</p>
<p>我们使用 Redis 作为缓存数据库，常见的做法是：当查询某个商品时，首先检查缓存中是否存在该商品的详情，如果存在，则直接返回缓存中的数据；如果缓存中没有，则从数据库中查询，并将查询结果存入缓存中，以备下次使用。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li>使用 Redis 存储商品信息。</li>
<li>设置适当的过期时间（TTL，Time To Live），避免缓存数据过期。</li>
<li>使用适当的缓存更新策略（例如：每次更新商品信息时更新缓存）。</li>
</ol>
<h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="1-设置-Redis-缓存"><a href="#1-设置-Redis-缓存" class="headerlink" title="1. 设置 Redis 缓存"></a>1. 设置 Redis 缓存</h4><p>首先，使用 Redis 的客户端库（如 <code>redis-py</code>）连接 Redis 服务。假设商品信息表为 <code>Products</code>，有字段 <code>ProductID</code>, <code>ProductName</code>, <code>Price</code>, <code>Stock</code>, <code>Description</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装 Redis 客户端</span></span><br><span class="line">pip install redis</span><br></pre></td></tr></table></figure>

<h4 id="2-商品查询和缓存逻辑"><a href="#2-商品查询和缓存逻辑" class="headerlink" title="2. 商品查询和缓存逻辑"></a>2. 商品查询和缓存逻辑</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接 Redis</span></span><br><span class="line">redis_client = redis.StrictRedis(host=<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">6379</span>, db=<span class="number">0</span>, decode_responses=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接 MySQL 数据库</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_db_connection</span>():</span><br><span class="line">    <span class="keyword">return</span> mysql.connector.connect(</span><br><span class="line">        host=<span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">        user=<span class="string">&quot;root&quot;</span>,</span><br><span class="line">        password=<span class="string">&quot;password&quot;</span>,</span><br><span class="line">        database=<span class="string">&quot;ecommerce&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取商品详情</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_product_details</span>(<span class="params">product_id</span>):</span><br><span class="line">    <span class="comment"># 检查缓存</span></span><br><span class="line">    cached_product = redis_client.get(<span class="string">f&quot;product:<span class="subst">&#123;product_id&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> cached_product:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;从缓存中获取商品信息&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> json.loads(cached_product)  <span class="comment"># 反序列化 JSON 数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果缓存中没有，查询数据库</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;从数据库中获取商品信息&quot;</span>)</span><br><span class="line">    connection = get_db_connection()</span><br><span class="line">    cursor = connection.cursor(dictionary=<span class="literal">True</span>)</span><br><span class="line">    cursor.execute(<span class="string">&quot;SELECT * FROM Products WHERE ProductID = %s&quot;</span>, (product_id,))</span><br><span class="line">    product = cursor.fetchone()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果商品存在，缓存到 Redis 中</span></span><br><span class="line">    <span class="keyword">if</span> product:</span><br><span class="line">        redis_client.setex(<span class="string">f&quot;product:<span class="subst">&#123;product_id&#125;</span>&quot;</span>, <span class="number">3600</span>, json.dumps(product))  <span class="comment"># 缓存 1 小时</span></span><br><span class="line">    cursor.close()</span><br><span class="line">    connection.close()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> product</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新商品信息并更新缓存</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update_product_details</span>(<span class="params">product_id, name, price, stock, description</span>):</span><br><span class="line">    <span class="comment"># 更新数据库</span></span><br><span class="line">    connection = get_db_connection()</span><br><span class="line">    cursor = connection.cursor()</span><br><span class="line">    cursor.execute(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        UPDATE Products</span></span><br><span class="line"><span class="string">        SET ProductName = %s, Price = %s, Stock = %s, Description = %s</span></span><br><span class="line"><span class="string">        WHERE ProductID = %s</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>, (name, price, stock, description, product_id))</span><br><span class="line">    connection.commit()</span><br><span class="line">    cursor.close()</span><br><span class="line">    connection.close()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 更新缓存</span></span><br><span class="line">    updated_product = &#123;</span><br><span class="line">        <span class="string">&quot;ProductID&quot;</span>: product_id,</span><br><span class="line">        <span class="string">&quot;ProductName&quot;</span>: name,</span><br><span class="line">        <span class="string">&quot;Price&quot;</span>: price,</span><br><span class="line">        <span class="string">&quot;Stock&quot;</span>: stock,</span><br><span class="line">        <span class="string">&quot;Description&quot;</span>: description</span><br><span class="line">    &#125;</span><br><span class="line">    redis_client.setex(<span class="string">f&quot;product:<span class="subst">&#123;product_id&#125;</span>&quot;</span>, <span class="number">3600</span>, json.dumps(updated_product))  <span class="comment"># 缓存 1 小时</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：查询商品 101 的信息</span></span><br><span class="line">product_info = get_product_details(<span class="number">101</span>)</span><br><span class="line"><span class="built_in">print</span>(product_info)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：更新商品 101 的信息</span></span><br><span class="line">update_product_details(<span class="number">101</span>, <span class="string">&quot;New Product Name&quot;</span>, <span class="number">199.99</span>, <span class="number">50</span>, <span class="string">&quot;Updated description&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h3><ol>
<li><strong>连接 Redis 和 MySQL：</strong> 使用 <code>redis-py</code> 连接 Redis，使用 <code>mysql.connector</code> 连接 MySQL 数据库。</li>
<li><strong>查询商品：</strong> 在 <code>get_product_details</code> 方法中，我们首先查询 Redis 缓存，看是否已经缓存了商品信息。如果缓存中存在，则直接返回缓存中的数据；如果缓存中没有，则从 MySQL 数据库中查询，并将查询结果缓存到 Redis 中。</li>
<li><strong>更新商品信息：</strong> 当商品信息发生变化时（例如商品名称、价格、库存等更新），我们在数据库中更新商品信息后，同时更新 Redis 缓存，以确保缓存数据的最新性。</li>
<li><strong>缓存设置过期时间：</strong> 使用 <code>setex</code> 方法将商品信息缓存到 Redis 中，并为缓存数据设置过期时间（TTL）。这样可以避免缓存过期数据的存在。</li>
</ol>
<h3 id="进一步优化"><a href="#进一步优化" class="headerlink" title="进一步优化"></a>进一步优化</h3><ol>
<li><strong>缓存穿透：</strong> 在查询时，除了检查缓存是否存在外，还可以添加一些防止缓存穿透的机制，如查询数据库时检查是否存在该商品。如果商品不存在，可以将其设置为 <code>None</code> 或空值，避免多次查询数据库。</li>
<li><strong>缓存淘汰策略：</strong> Redis 有多种缓存淘汰策略（如 LRU、LFU），可以根据实际业务需求配置 Redis 实例的缓存策略，确保热点数据可以长时间保持在缓存中。</li>
<li><strong>异步更新缓存：</strong> 在高并发的场景下，更新缓存的操作可能导致性能问题，可以使用队列和异步处理来优化缓存更新的时机，避免频繁更新缓存。</li>
</ol>
<h3 id="小结一下-8"><a href="#小结一下-8" class="headerlink" title="小结一下"></a>小结一下</h3><p>通过使用 Redis 缓存，电商平台能够有效提高查询商品信息的性能，减轻数据库负担。根据业务需求，我们可以进一步优化缓存策略和更新机制。</p>
<h2 id="10-并行查询与并发"><a href="#10-并行查询与并发" class="headerlink" title="10. 并行查询与并发"></a>10. 并行查询与并发</h2><ul>
<li><strong>启用并行查询</strong>：SQL Server 允许在查询中使用多个 CPU 核心来并行处理。适当调整并行查询的设置（如 <code>max degree of parallelism</code>）可以提高查询性能，尤其是在处理大量数据时。</li>
<li><strong>优化锁策略</strong>：确保数据库的锁策略合理，避免长时间的锁竞争。可以使用行级锁而不是表级锁，减少阻塞。</li>
</ul>
<p>在高并发场景下，使用并行查询可以显著提升数据查询的速度。并行查询的核心思想是将复杂的查询拆分成多个子任务，利用多个 CPU 核心同时处理这些子任务，从而提高整体查询性能。并发则是指在多个任务之间进行切换，使得 CPU 更高效地利用，在某些场景下，通过并发执行多个查询任务可以实现较高的性能。</p>
<h3 id="业务场景-5"><a href="#业务场景-5" class="headerlink" title="业务场景"></a>业务场景</h3><p>假设我们有一个电商平台，其中存储了大量的订单数据。用户查询订单数据时，可能涉及到多个表的联接、多个条件的筛选等复杂的查询操作。为了提高查询性能，我们可以通过并行查询和并发的方式，针对不同的查询任务进行优化。</p>
<p>例如，查询订单数据时，查询条件包括订单状态、订单日期范围和用户 ID 等。我们将该查询拆分为多个并行查询，分别查询不同的条件，再将结果合并返回。</p>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li><strong>并行查询：</strong> 将查询任务拆分成多个子任务，利用多线程或者多进程并行执行每个子任务。</li>
<li><strong>并发查询：</strong> 使用异步 IO 或者线程池来并发执行多个查询操作。</li>
</ol>
<p>我们将使用 Python 的 <code>concurrent.futures</code> 库来实现并行查询，并利用 MySQL 数据库来执行查询操作。</p>
<h3 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="1-并行查询"><a href="#1-并行查询" class="headerlink" title="1. 并行查询"></a>1. 并行查询</h4><p>我们将查询条件分为多个部分，并行地执行查询操作。例如：分别查询订单状态为 <code>Completed</code> 和 <code>Pending</code> 的订单数据，并行查询。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装 MySQL 客户端库</span></span><br><span class="line">pip install mysql-connector-python</span><br><span class="line">import mysql.connector</span><br><span class="line">from concurrent.futures import ThreadPoolExecutor</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接 MySQL 数据库</span></span><br><span class="line">def get_db_connection():</span><br><span class="line">    <span class="built_in">return</span> mysql.connector.connect(</span><br><span class="line">        host=<span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">        user=<span class="string">&quot;root&quot;</span>,</span><br><span class="line">        password=<span class="string">&quot;123123&quot;</span>,</span><br><span class="line">        database=<span class="string">&quot;VGDB&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行查询：查询订单状态为指定状态的订单</span></span><br><span class="line">def query_orders_by_status(status):</span><br><span class="line">    connection = get_db_connection()</span><br><span class="line">    cursor = connection.cursor(dictionary=True)</span><br><span class="line">    query = <span class="string">&quot;SELECT * FROM Orders WHERE OrderStatus = %s&quot;</span></span><br><span class="line">    cursor.execute(query, (status,))</span><br><span class="line">    result = cursor.fetchall()</span><br><span class="line">    cursor.close()</span><br><span class="line">    connection.close()</span><br><span class="line">    <span class="built_in">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行并行查询</span></span><br><span class="line">def fetch_orders():</span><br><span class="line">    statuses = [<span class="string">&#x27;Completed&#x27;</span>, <span class="string">&#x27;Pending&#x27;</span>]  <span class="comment"># 定义我们需要查询的订单状态</span></span><br><span class="line">    <span class="comment"># 使用 ThreadPoolExecutor 并行查询</span></span><br><span class="line">    with ThreadPoolExecutor(max_workers=2) as executor:</span><br><span class="line">        <span class="comment"># 提交查询任务</span></span><br><span class="line">        futures = [executor.submit(query_orders_by_status, status) <span class="keyword">for</span> status <span class="keyword">in</span> statuses]</span><br><span class="line">        <span class="comment"># 获取查询结果</span></span><br><span class="line">        results = [future.result() <span class="keyword">for</span> future <span class="keyword">in</span> futures]</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">return</span> results</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：执行查询</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    orders = fetch_orders()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;查询结果：&quot;</span>, orders)</span><br><span class="line">    <span class="built_in">print</span>(f<span class="string">&quot;查询用时: &#123;time.time() - start_time&#125;秒&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="代码说明-1"><a href="#代码说明-1" class="headerlink" title="代码说明"></a>代码说明</h3><ol>
<li>**<code>query_orders_by_status</code>**：该方法执行数据库查询，查询指定状态的订单。</li>
<li>**<code>fetch_orders</code>**：该方法使用 <code>ThreadPoolExecutor</code> 来并行执行多个查询任务。在这里，我们将订单状态 <code>Completed</code> 和 <code>Pending</code> 分别作为任务提交到线程池中并行查询。</li>
<li>**<code>ThreadPoolExecutor</code>**：我们创建了一个最大工作线程数为 2 的线程池，并使用 <code>submit</code> 提交查询任务。每个查询会在一个独立的线程中执行。</li>
<li>**<code>future.result()</code>**：获取并行查询任务的返回结果。</li>
</ol>
<h4 id="2-并发查询"><a href="#2-并发查询" class="headerlink" title="2. 并发查询"></a>2. 并发查询</h4><p>我们可以通过异步查询或多线程来执行并发查询，适用于数据库查询不会互相依赖的情况。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="comment"># 异步查询数据库</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">query_orders_by_status_async</span>(<span class="params">status, loop</span>):</span><br><span class="line">    <span class="comment"># 使用 ThreadPoolExecutor 让数据库查询异步执行</span></span><br><span class="line">    result = <span class="keyword">await</span> loop.run_in_executor(<span class="literal">None</span>, query_orders_by_status, status)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行查询：查询订单状态为指定状态的订单</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">query_orders_by_status</span>(<span class="params">status</span>):</span><br><span class="line">    connection = get_db_connection()</span><br><span class="line">    cursor = connection.cursor(dictionary=<span class="literal">True</span>)</span><br><span class="line">    query = <span class="string">&quot;SELECT * FROM Orders WHERE OrderStatus = %s&quot;</span></span><br><span class="line">    cursor.execute(query, (status,))</span><br><span class="line">    result = cursor.fetchall()</span><br><span class="line">    cursor.close()</span><br><span class="line">    connection.close()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 异步并发查询</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fetch_orders_concurrently</span>():</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    statuses = [<span class="string">&#x27;Completed&#x27;</span>, <span class="string">&#x27;Pending&#x27;</span>, <span class="string">&#x27;Shipped&#x27;</span>]  <span class="comment"># 查询多个状态的订单</span></span><br><span class="line">    tasks = [query_orders_by_status_async(status, loop) <span class="keyword">for</span> status <span class="keyword">in</span> statuses]</span><br><span class="line">    orders = <span class="keyword">await</span> asyncio.gather(*tasks)  <span class="comment"># 等待所有任务完成</span></span><br><span class="line">    <span class="keyword">return</span> orders</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：执行并发查询</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    asyncio.run(fetch_orders_concurrently())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;查询用时: <span class="subst">&#123;time.time() - start_time&#125;</span>秒&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="代码说明-2"><a href="#代码说明-2" class="headerlink" title="代码说明"></a>代码说明</h3><ol>
<li>**<code>query_orders_by_status_async</code>**：此方法使用 <code>loop.run_in_executor</code> 来将数据库查询操作异步化。通过这种方式，尽管数据库查询是阻塞操作，我们可以并发地执行多个查询。</li>
<li>**<code>asyncio.gather</code>**：将多个异步任务组合在一起，等待所有任务完成后再返回结果。</li>
<li>**<code>asyncio.run</code>**：用于启动事件循环并执行异步查询。</li>
</ol>
<h3 id="进一步优化-1"><a href="#进一步优化-1" class="headerlink" title="进一步优化"></a>进一步优化</h3><ol>
<li><strong>线程池大小</strong>：根据业务需求，调整 <code>ThreadPoolExecutor</code> 中的 <code>max_workers</code> 参数。如果任务非常多，可以适当增加线程池大小，但要注意不要过多，以免影响系统性能。</li>
<li><strong>连接池</strong>：对于数据库操作，可以使用数据库连接池来优化数据库连接的管理。这样可以避免每次查询都建立新的数据库连接，提高性能。</li>
<li><strong>分页查询</strong>：如果查询结果非常庞大，可以通过分页查询来减小每次查询的数据量，进一步提高性能。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>并行查询</strong>：通过将查询任务拆分为多个子任务，并行地处理，可以显著提高查询性能。</li>
<li><strong>并发查询</strong>：适用于在多个查询任务之间进行并发执行，无需等待每个查询任务逐个完成，可以加快整体查询速度。</li>
</ul>
<p>通过结合并行查询和并发查询策略，我们可以显著提高电商平台或其他业务系统的查询响应速度，尤其是在高并发的环境中，保证系统的高效性。</p>
<h2 id="11-SQL-Server-实例优化"><a href="#11-SQL-Server-实例优化" class="headerlink" title="11. SQL Server 实例优化"></a>11. SQL Server 实例优化</h2><ul>
<li><strong>定期重启 SQL Server 实例</strong>：如果 SQL Server 长时间运行，可能会导致缓存过多或内存泄漏等问题，定期重启可以帮助释放资源并优化性能。</li>
<li><strong>启用压缩</strong>：SQL Server 提供数据压缩功能，可以节省存储空间，并提高查询性能，尤其是在读取数据时。</li>
</ul>
<p>SQL Server 实例优化是提升数据库整体性能的一个重要方面。在大型业务系统中，SQL Server 的性能往往直接影响到整个应用的响应速度和稳定性。实例优化包括硬件资源的合理配置、SQL Server 配置参数的优化、内存和 I&#x2F;O 管理、查询优化以及监控等方面。</p>
<p>假设我们有一个在线电商平台，业务量很大，包含大量的商品、订单、用户等数据。我们需要对 SQL Server 实例进行优化，以确保高效的查询性能、稳定的事务处理和快速的数据读取能力。</p>
<h3 id="1-硬件配置优化"><a href="#1-硬件配置优化" class="headerlink" title="1. 硬件配置优化"></a>1. 硬件配置优化</h3><p>SQL Server 实例的性能在很大程度上取决于底层硬件的配置，尤其是内存、CPU、磁盘等资源。</p>
<ul>
<li><strong>内存</strong>：SQL Server 是一个内存密集型应用，内存越大，缓存命中率越高，查询性能也越好。</li>
<li><strong>CPU</strong>：更多的 CPU 核心可以处理更多并发请求。</li>
<li><strong>磁盘</strong>：SSD 驱动器在磁盘 I&#x2F;O 性能方面要优于传统硬盘，尤其是在大型数据库的读写操作中。</li>
</ul>
<h3 id="2-SQL-Server-配置优化"><a href="#2-SQL-Server-配置优化" class="headerlink" title="2. SQL Server 配置优化"></a>2. SQL Server 配置优化</h3><p>SQL Server 提供了很多配置参数来调整实例的行为，可以通过这些参数来优化性能。</p>
<h4 id="配置参数示例"><a href="#配置参数示例" class="headerlink" title="配置参数示例"></a>配置参数示例</h4><ul>
<li><strong>max degree of parallelism</strong>：控制 SQL Server 查询的并行度。通过合理设置并行度，可以提高多核 CPU 系统的查询效率。</li>
<li><strong>max server memory</strong>：限制 SQL Server 使用的最大内存量，防止 SQL Server 占用过多内存导致操作系统性能下降。</li>
<li><strong>cost threshold for parallelism</strong>：设置查询执行的代价阈值，只有当查询的成本超过该值时，SQL Server 才会使用并行执行。</li>
</ul>
<h3 id="3-索引优化"><a href="#3-索引优化" class="headerlink" title="3. 索引优化"></a>3. 索引优化</h3><p>索引是提高查询性能的关键，可以根据业务场景为频繁查询的字段创建索引。但过多的索引会影响插入、更新和删除操作的性能，因此需要在查询性能和维护成本之间找到平衡。</p>
<h3 id="4-查询优化-1"><a href="#4-查询优化-1" class="headerlink" title="4. 查询优化"></a>4. 查询优化</h3><p>对于大型业务系统，查询优化尤为重要。优化查询可以减少数据库的负担，提升响应速度。</p>
<h4 id="业务场景-6"><a href="#业务场景-6" class="headerlink" title="业务场景"></a>业务场景</h4><p>假设电商平台需要处理大量的订单数据，查询常常涉及到联接多个表，比如查询某个用户在某个时间段内的所有订单。我们可以通过优化 SQL 查询来提高查询速度。</p>
<h3 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="1-设置-SQL-Server-实例配置参数"><a href="#1-设置-SQL-Server-实例配置参数" class="headerlink" title="1. 设置 SQL Server 实例配置参数"></a>1. 设置 SQL Server 实例配置参数</h4><p>在 SQL Server 实例中，我们可以通过以下 T-SQL 语句来设置一些基本的优化参数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 设置最大内存使用量为 16 GB</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;max server memory&#x27;</span>, <span class="number">16384</span>;  <span class="comment">-- 单位：MB</span></span><br><span class="line">RECONFIGURE;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置最大并行度为 8 核 CPU</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;max degree of parallelism&#x27;</span>, <span class="number">8</span>;</span><br><span class="line">RECONFIGURE;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置查询的成本阈值为 10</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;cost threshold for parallelism&#x27;</span>, <span class="number">10</span>;</span><br><span class="line">RECONFIGURE;</span><br></pre></td></tr></table></figure>

<h4 id="2-查询优化-1"><a href="#2-查询优化-1" class="headerlink" title="2. 查询优化"></a>2. 查询优化</h4><p>为了提高查询性能，可以在查询时使用以下技巧：</p>
<ul>
<li>避免 SELECT *，仅选择需要的字段。</li>
<li>使用 JOIN 替代子查询，避免不必要的嵌套查询。</li>
<li>创建适当的索引来加速查询。</li>
<li>利用分页查询减少单次查询的数据量。</li>
</ul>
<p>以下是一个优化后的查询示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 假设我们需要查询某个用户的订单信息，优化后的 SQL 查询</span></span><br><span class="line"><span class="keyword">SELECT</span> o.OrderID, o.OrderDate, o.TotalAmount, u.UserName</span><br><span class="line"><span class="keyword">FROM</span> Orders o</span><br><span class="line"><span class="keyword">JOIN</span> Users u <span class="keyword">ON</span> o.UserID <span class="operator">=</span> u.UserID</span><br><span class="line"><span class="keyword">WHERE</span> o.OrderDate <span class="keyword">BETWEEN</span> <span class="string">&#x27;2024-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2024-12-31&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> u.UserID <span class="operator">=</span> <span class="number">12345</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> o.OrderDate <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<h4 id="3-索引优化-1"><a href="#3-索引优化-1" class="headerlink" title="3. 索引优化"></a>3. 索引优化</h4><p>为了优化查询，我们可以在 <code>Orders</code> 表的 <code>UserID</code>、<code>OrderDate</code> 字段上创建索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 为 UserID 列创建索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_user_id <span class="keyword">ON</span> Orders(UserID);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为 OrderDate 列创建索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_order_date <span class="keyword">ON</span> Orders(OrderDate);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为 UserID 和 OrderDate 的组合创建复合索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_user_order_date <span class="keyword">ON</span> Orders(UserID, OrderDate);</span><br></pre></td></tr></table></figure>

<h4 id="4-数据库备份和维护"><a href="#4-数据库备份和维护" class="headerlink" title="4. 数据库备份和维护"></a>4. 数据库备份和维护</h4><p>定期备份和维护数据库可以确保系统在高负载下保持高效。定期的数据库优化任务包括：</p>
<ul>
<li>备份数据。</li>
<li>更新统计信息。</li>
<li>重建索引。</li>
</ul>
<p>以下是一个定期重建索引的示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 重建所有表的索引</span></span><br><span class="line"><span class="keyword">ALTER</span> INDEX <span class="keyword">ALL</span> <span class="keyword">ON</span> Orders REBUILD;</span><br><span class="line"><span class="keyword">ALTER</span> INDEX <span class="keyword">ALL</span> <span class="keyword">ON</span> Users REBUILD;</span><br></pre></td></tr></table></figure>

<h3 id="5-使用-SQL-Server-的性能监控工具"><a href="#5-使用-SQL-Server-的性能监控工具" class="headerlink" title="5. 使用 SQL Server 的性能监控工具"></a>5. 使用 SQL Server 的性能监控工具</h3><p>SQL Server 提供了一些性能监控工具来帮助识别性能瓶颈。例如，<code>SQL Server Profiler</code> 和 <code>Dynamic Management Views (DMVs)</code> 可以帮助我们实时监控 SQL Server 实例的性能，并根据实际情况进行调优。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看 SQL Server 实例当前的资源使用情况</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sys.dm_exec_requests;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看 SQL Server 实例的内存使用情况</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sys.dm_os_memory_clerks;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看 SQL Server 实例的磁盘 I/O 使用情况</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sys.dm_io_virtual_file_stats(<span class="keyword">NULL</span>, <span class="keyword">NULL</span>);</span><br></pre></td></tr></table></figure>

<h3 id="小结一下-9"><a href="#小结一下-9" class="headerlink" title="小结一下"></a>小结一下</h3><ol>
<li><strong>硬件优化</strong>：合理配置 CPU、内存和磁盘，提升 SQL Server 实例的性能。</li>
<li><strong>实例配置优化</strong>：通过配置 SQL Server 的参数，如内存限制、并行度等，优化性能。</li>
<li><strong>索引优化</strong>：合理设计索引结构，提高查询效率。</li>
<li><strong>查询优化</strong>：使用高效的 SQL 查询语句，避免不必要的计算和 I&#x2F;O 操作。</li>
<li><strong>定期维护和备份</strong>：定期进行数据库维护和备份，确保系统稳定运行。</li>
</ol>
<p>通过对 SQL Server 实例的优化，可以显著提升数据库的性能，确保电商平台在高并发、高负载的情况下仍能保持高效响应。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>以上11种优化方案供你参考，优化 SQL Server 数据库性能得从多个方面着手，包括硬件配置、数据库结构、查询优化、索引管理、分区分表、并行处理等。通过合理的索引、查询优化、数据分区等技术，可以在数据量增大时保持较好的性能。同时，定期进行数据库维护和清理，保证数据库高效运行。关注威哥爱编程，V哥做你的技术门童。</p>
<p>本文来自博客园，作者：<a href="https://www.cnblogs.com/wgjava/">威哥爱编程</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/wgjava/p/18534481">https://www.cnblogs.com/wgjava/p/18534481</a></p>
]]></content>
      <categories>
        <category>workNote</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>sqlserver</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库损坏或置疑中间件连接不了数据库</title>
    <url>/2024/11/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BD%AE%E7%96%91/</url>
    <content><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p>
<p>leiyu-code.github.io</p>
<p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p>
<h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p>数据库变为可疑状态通常是由于突然断电、服务器死机或强制关机等原因导致的。为了避免这种情况，建议定期备份数据库，确保有完整的备份文件。此外，确保服务器稳定运行，避免不必要的关机操作，可以减少数据库损坏的风险</p>
<p><em><strong>1、最简单的解决方法是用备份的数据库文件恢复数据库</strong></em></p>
<p><em><strong>2、用以下语句可以修复数据库</strong></em></p>
<span id="more"></span>

<p>先断开与网络的连接</p>
<p>将可疑的数据库修改为紧急状态，以便进行修复操作。可以使用以下SQL语句实现：<br><code>ALTER DATABASE 数据库名 SET EMERGENCY</code><br>执行此操作后，数据库会变为红色紧急状态，此时可以看到数据库的结构和数据，但无法进行备份等操作</p>
<p>接下来，将数据库设置为单用户模式，以便进行修复：<br><code>ALTER DATABASE 数据库名 SET SINGLE_USER</code><br>在单用户模式下，只有一个用户连接，这有助于避免并发问题，可以在后面加个WITH ROLLBACK IMMEDIATE从句立刻回滚未提交的修改</p>
<p>使用DBCC CHECKDB命令检查并修复数据库。此命令可以检测数据库的结构错误，并尝试修复它们。使用以下语句：<br><code>DBCC CHECKDB(数据库名, REPAIR_ALLOW_DATA_LOSS)</code><br>注意，使用此参数可能会造成数据丢失</p>
<p>将数据库恢复为多用户模式，允许正常访问：<br><code>ALTER DATABASE 数据库名 SET MULTI_USER</code></p>
<p>确保数据库设置为在线状态，以便进行正常的读写操作：<br><code>ALTER DATABASE 数据库名 SET ONLINE</code></p>
<p>退出数据库管理工具，重启sql服务<br>cmd命令   service.msc<br>停止MSSQLSERVER服务，再启动MSSQLSERVER服务</p>
]]></content>
      <categories>
        <category>workNote</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>sqlserver</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库日志文件.ldf文件过大</title>
    <url>/2024/09/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A5%E5%BF%97%E6%95%B0%E6%8D%AE%E8%BF%87%E5%A4%A7/</url>
    <content><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p>
<p>leiyu-code.github.io</p>
<p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p>
<h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p><em><strong>数据库LDF日志文件存储的是数据库操作数据的信息，其中包含有(新增数据、修改数据、删除数据等）</strong></em></p>
<p>ldf文件日志过大会占满整个硬盘分区，导致数据库管理软件进不去或数据库报错</p>
<h4 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h4><p><strong>收缩SQL2008数据库</strong></p>
<p>1，点击电脑左下角开始-Microsoft SQL Server2008 R2-SSMS-Microsoft SQL Server Management Studio,进入SSMS页面后使用Windows身份验证连接上SQL Server。</p>
<p><a href="https://imgse.com/i/pAmqBh6"><img src="https://s21.ax1x.com/2024/09/11/pAmqBh6.md.png" alt="pAmqBh6.md.png"></a></p>
<p>2，进入SSMS后在左侧数据库目录中找到需要收缩ldf文件的数据库名称（例如：QFBJZT）然后右键选择“属性”快捷命令。在打开的QFBJZT数据库属性页面单击“选项”标签，恢复模式后下拉菜单中选择“简单”模式，设置好后单击“确定”按钮使设置生效。</p>
<span id="more"></span>

<p><a href="https://imgse.com/i/pAmqs1O"><img src="https://s21.ax1x.com/2024/09/11/pAmqs1O.png" alt="pAmqs1O.png"></a></p>
<p>3，返回SSMS窗口，右键单击目标数据库名称QFBJZT，右键选择任务-收缩-数据库。</p>
<p><a href="https://imgse.com/i/pAmqycD"><img src="https://s21.ax1x.com/2024/09/11/pAmqycD.png" alt="pAmqycD.png"></a></p>
<p>4，在收缩数据库页面中无须调整参数，直接单击“确定”按钮开始收缩数据库的操作。日志文件在一些异常情况下往往是恢复数据库的重要依据，收缩数据库操作主要作用是收缩日志大小。所以需要定期进行上述操作，以免数据库日志过大。</p>
<p><a href="https://imgse.com/i/pAmq0tx"><img src="https://s21.ax1x.com/2024/09/11/pAmq0tx.png" alt="pAmq0tx.png"></a></p>
<p>5，最后再次右键数据库QFBJZT选择“属性”，在打开的QFBJZT数据库属性页面单击“选项”标签，恢复模式后下拉菜单中选择回“完整”模式，设置好后单击“确定”按钮使设置生效即可完成收缩数据库日志文件工作。</p>
<p><a href="https://imgse.com/i/pAmqr9K"><img src="https://s21.ax1x.com/2024/09/11/pAmqr9K.png" alt="pAmqr9K.png"></a></p>
]]></content>
      <categories>
        <category>workNote</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>sqlserver</tag>
      </tags>
  </entry>
  <entry>
    <title>王熙凤毒设相思局　贾天祥正照风月鉴</title>
    <url>/2024/09/05/%E7%8E%8B%E7%86%99%E5%87%A4%E6%AF%92%E8%AE%BE%E7%9B%B8%E6%80%9D%E5%B1%80%E3%80%80%E8%B4%BE%E5%A4%A9%E7%A5%A5%E6%AD%A3%E7%85%A7%E9%A3%8E%E6%9C%88%E9%89%B4/</url>
    <content><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p>
<p><a href="http://leiyu-code.github.io">leiyu-code.github.io</a></p>
<p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p>
<h1>《红楼梦》-第12回</h1>
<h1>王熙凤毒设相思局　贾天祥正照风月鉴</h1>
<p>​		话说凤姐正与平儿说话，只见有人回说：“瑞大爷来了。”凤姐急命“快请进来。”贾瑞见往里让，心中喜出望外，急忙进来，见了凤姐，满面陪笑，连连问好。凤姐儿也假意殷勤，让茶让坐。</p>
<p>贾瑞见凤姐如此打扮，亦发酥倒，因饧了眼问道：“二哥哥怎么还不回来？”凤姐道：“不知什么原故。”贾瑞笑道：“别是路上有人绊住了脚了，舍不得回来也未可知？”凤姐道：“也未可知。男人家见一个爱一个也是有的。”贾瑞笑道：“嫂子这话说错了，我就不这样。”凤姐笑道：“像你这样的人能有几个呢，十个里也挑不出一个来。”贾瑞听了喜的抓耳挠腮，又道：“嫂子天天也闷的很。”凤姐道：“正是呢，只盼个人来说话解解闷儿。”贾瑞笑道：“我倒天天闲着，天天过来替嫂子解解闲闷可好不好？”凤姐笑道：“你哄我呢，你那里肯往我这里来。”贾瑞道：“我在嫂子跟前，若有一点谎话，天打雷劈！只因素日闻得人说，嫂子是个利害人，在你跟前一点也错不得，所以唬住了我。如今见嫂子最是个有说有笑极疼人的，我怎么不来，----死了也愿意！”凤姐笑道：“果然你是个明白人，比贾蓉两个强远了。我看他那样清秀，只当他们心里明白，谁知竟是两个胡涂虫，一点不知人心。”</p>
<span id="more"></span>
<p>贾瑞听了这话，越发撞在心坎儿上，由不得又往前凑了一凑，觑着眼看凤姐带的荷包，然后又问带着什么戒指。凤姐悄悄道：“放尊重着，别叫丫头们看了笑话。”贾瑞如听纶音佛语一般，忙往后退。凤姐笑道：“你该走了。”贾瑞说：“我再坐一坐儿。----好狠心的嫂子。”凤姐又悄悄的道：“大天白日，人来人往，你就在这里也不方便。你且去，等着晚上起了更你来，悄悄的在西边穿堂儿等我。”贾瑞听了，如得珍宝，忙问道：“你别哄我。但只那里人过的多，怎么好躲的？”凤姐道：“你只放心。我把上夜的小厮们都放了假，两边门一关，再没别人了。”贾瑞听了，喜之不尽，忙忙的告辞而去，心内以为得手。</p>
<p>盼到晚上，果然黑地里摸入荣府，趁掩门时，钻入穿堂。果见漆黑无一人，往贾母那边去的门户已倒锁，只有向东的门未关。贾瑞侧耳听着，半日不见人来，忽听咯噔一声，东边的门也倒关了。贾瑞急的也不敢则声，只得悄悄的出来，将门撼了撼，关的铁桶一般。此时要求出去亦不能够，南北皆是大房墙，要跳亦无攀援。这屋内又是过门风，空落落，现是腊月天气，夜又长，朔风凛凛，侵肌裂骨，一夜几乎不曾冻死。好容易盼到早晨，只见一个老婆子先将东门开了，进去叫西门。贾瑞瞅他背着脸，一溜烟抱着肩跑了出来，幸而天气尚早，人都未起，从后门一径跑回家去。</p>
<p>原来贾瑞父母早亡，只有他祖父代儒教养。那代儒素日教训最严，不许贾瑞多走一步，生怕他在外吃酒赌钱，有误学业。今忽见他一夜不归，只料定他在外非饮即赌，嫖娼宿妓，那里想到这段公案，因此气了一夜。贾瑞也捻着一把汗，少不得回来撒谎，只说：“往舅舅家去了，天黑了，留我住了一夜。”代儒道：“自来出门，非禀我不敢擅出，如何昨日私自去了？据此亦该打，何况是撒谎。”因此，发狠到底打了三四十扳，不许吃饭，令他跪在院内读文章，定要补出十天的工课来方罢。贾瑞直冻了一夜，今又遭了苦打，且饿着肚子，跪着在风地里读文章，其苦万状。</p>
<p>此时贾瑞前心犹是未改，再想不到是凤姐捉弄他。过后两日，得了空，便仍来找凤姐。凤姐故意抱怨他失信，贾瑞急的赌身发誓。凤姐因见他自投罗网，少不得再寻别计令他知改，故又约他道：“今日晚上，你别在那里了。你在我这房后小过道子里那间空屋里等我，可别冒撞了。”贾瑞道：“果真？”凤姐道：“谁可哄你，你不信就别来。”贾瑞道：“来，来，来。死也要来！”凤姐道：“这会子你先去罢。”贾瑞料定晚间必妥，此时先去了。凤姐在这里便点兵派将，设下圈套。</p>
<p>那贾瑞只盼不到晚上，偏生家里亲戚又来了，直等吃了晚饭才去，那天已有掌灯时候。又等他祖父安歇了，方溜进荣府，直往那夹道中屋子里来等着，热锅上的蚂蚁一般，只是干转。左等不见人影，右听也没声响，心下自思：“别是又不来了，又冻我一夜不成？”正自胡猜，只见黑曀曀的来了一个人，贾瑞便意定是凤姐，不管皂白，饿虎一般，等那人刚至门前，便如猫捕鼠的一般，抱住叫道：“亲嫂子，等死我了。”说着，抱到屋里炕上就亲嘴扯裤子，满口里“亲娘”“亲爹”的乱叫起来。那人只不作声。贾瑞拉了自己裤子，硬帮帮的就想顶入。忽见灯光一闪，只见贾蔷举着个捻子照道：“谁在屋里？”只见炕上那人笑道：“瑞大叔要臊我呢。”贾瑞一见，却是贾蓉，真臊的无地可入，不知要怎么样才好，回身就要跑，被贾蔷一把揪住道：“别走！如今琏二嫂已经告到太太跟前，说你无故调戏他。他暂用了个脱身计，哄你在这边等着，太太气死过去，因此叫我来拿你。刚才你又拦住他，没的说，跟我去见太太！”</p>
<p>贾瑞听了，魂不附体，只说：“好侄儿，只说没有见我，明日我重重的谢你。”贾蔷道：“你若谢我，放你不值什么，只不知你谢我多少？况且口说无凭，写一文契来。”贾瑞道：“这如何落纸呢？”贾蔷道：“这也不妨，写一个赌钱输了外人帐目，借头家银若干两便罢。”贾瑞道：“这也容易。只是此时无纸笔。”贾蔷道：“这也容易。”说罢翻身出来，纸笔现成，拿来命贾瑞写。他两作好作歹，只写了五十两，然后画了押，贾蔷收起来。然后撕逻贾蓉。贾蓉先咬定牙不依，只说：“明日告诉族中的人评评理。”贾瑞急的至于叩头。贾蔷作好作歹的，也写了一张五十两欠契才罢。贾蔷又道：“如今要放你，我就担着不是。老太太那边的门早已关了，老爷正在厅上看南京的东西，那一条路定难过去，如今只好走后门。若这一走，倘或遇见了人，连我也完了。等我们先去哨探哨探，再来领你。这屋你还藏不得，少时就来堆东西。等我寻个地方。”说毕，拉着贾瑞，仍熄了灯，出至院外，摸着大台矶底下，说道：“这窝儿里好，你只蹲着，别哼一声，等我们来再动。”说毕，二人去了。</p>
<p>贾瑞此时身不由己，只得蹲在那里。心下正盘算，只听头顶上一声响，嗗拉拉一净桶尿粪从上面直泼下来，可巧浇了他一身一头。贾瑞掌不住嗳哟了一声，忙又掩住口，不敢声张，满头满脸浑身皆是尿屎，冰冷打战。只见贾蔷跑来叫：“快走，快走！”贾瑞如得了命，三步两步从后门跑到家里，天已三更，只得叫门。开门人见他这般景况，问是怎的。少不得扯谎说：“黑了，失脚掉在茅厕里了。”一面到了自己房中更衣洗濯，心下方想到是凤姐顽他，因此发一回恨，再想想凤姐的模样儿，又恨不得一时搂在怀内，一夜竟不曾合眼。</p>
<p>自此满心想凤姐，只不敢往荣府去了。贾蓉两个又常常的来索银子，他又怕祖父知道，正是相思尚且难禁，更又添了债务，日间工课又紧，他二十来岁人，尚未娶亲，迩来想着凤姐，未免有那指头告了消乏等事，更兼两回冻恼奔波，因此三五下里夹攻，不觉就得了一病：心内发膨胀，口中无滋味，脚下如绵，眼中似醋，黑夜作烧，白昼常倦，下溺连精，嗽痰带血。诸如此症，不上一年都添全了。于是不能支持，一头睡倒，合上眼还只梦魂颠倒，满口乱说胡话，惊怖异常。百般请医疗治，诸如肉桂，附子，鳖甲，麦冬，玉竹等药，吃了有几十斤下去，也不见个动静。</p>
<p>倏又腊尽春回，这病更又沉重。代儒也着了忙，各处请医疗治，皆不见效。因后来吃“独参汤”，代儒如何有这力量，只得往荣府来寻。王夫人命凤姐秤二两给他，凤姐回说：“前儿新近都替老太太配了药，那整的太太又说留着送杨提督的太太配药，偏生昨儿我已送了去了。”王夫人道：“就是咱们这边没了，你打发个人往你婆婆那边问问，或是你珍大哥哥那府里再寻些来，凑着给人家。吃好了，救人一命，也是你的好处。”凤姐听了，也不遣人去寻，只得将些渣末泡须凑了几钱，命人送去，只说：“太太送来的，再也没了。”然后回王夫人，只说：“都寻了来，共凑了有二两送去。”</p>
<p>那贾瑞此时要命心甚切，无药不吃，只是白花钱，不见效。忽然这日有个跛足道人来化斋，口称专治冤业之症。贾瑞偏生在内就听见了，直着声叫喊说：“快请进那位菩萨来救我！”一面叫，一面在枕上叩首。众人只得带了那道士进来。贾瑞一把拉住，连叫“菩萨救我！”那道士叹道：“你这病非药可医。我有个宝贝与你，你天天看时，此命可保矣。”说毕，从褡裢中取出一面镜子来----两面皆可照人，镜把上面錾着“风月宝鉴”四字----递与贾瑞道：“这物出自太虚幻境空灵殿上，警幻仙子所制，专治邪思妄动之症，有济世保生之功。所以带他到世上，单与那些聪明杰俊，风雅王孙等看照。千万不可照正面，只照他的背面，要紧，要紧！三日后吾来收取，管叫你好了。”说毕，佯常而去，众人苦留不住。</p>
<p>贾瑞收了镜子，想道：“这道士倒有意思，我何不照一照试试。”想毕，拿起“风月鉴”来，向反面一照，只见一个骷髅立在里面，唬得贾瑞连忙掩了，骂：“道士混帐，如何吓我！----我倒再照照正面是什么。”想着，又将正面一照，只见凤姐站在里面招手叫他。贾瑞心中一喜，荡悠悠的觉得进了镜子，与凤姐云雨一番，凤姐仍送他出来。到了床上，哎哟了一声，一睁眼，镜子从手里掉过来，仍是反面立着一个骷髅。贾瑞自觉汗津津的，底下已遗了一滩精。心中到底不足，又翻过正面来，只见凤姐还招手叫他，他又进去。如此三四次。到了这次，刚要出镜子来，只见两个人走来，拿铁锁把他套住，拉了就走。贾瑞叫道：“让我拿了镜子再走。”----只说了这句，就再不能说话了。</p>
<p>旁边伏侍贾瑞的众人，只见他先还拿着镜子照，落下来，仍睁开眼拾在手内，末后镜子落下来便不动了。众人上来看看，已没了气。身子底下冰凉渍湿一大滩精，这才忙着穿衣抬床。代儒夫妇哭的死去活来，大骂道士，“是何妖镜！若不早毁此物，遗害于世不小。”遂命架火来烧，只听镜内哭道：“谁叫你们瞧正面了！你们自己以假为真，何苦来烧我？”正哭着，只见那跛足道人从外面跑来，喊道：“谁毁‘风月鉴’，吾来救也！”说着，直入中堂，抢入手内，飘然去了。</p>
<p>当下，代儒料理丧事，各处去报丧。三日起经，七日发引，寄灵于铁槛寺，日后带回原籍。当下贾家众人齐来吊问，荣国府贾赦赠银二十两，贾政亦是二十两，宁国府贾珍亦有二十两，别者族中贫富不等，或三两五两，不可胜数。另有各同窗家分资，也凑了二三十两。代儒家道虽然淡薄，倒也丰丰富富完了此事。</p>
<p>谁知这年冬底，林如海的书信寄来，却为身染重疾，写书特来接林黛玉回去。贾母听了，未免又加忧闷，只得忙忙的打点黛玉起身。宝玉大不自在，争奈父女之情，也不好拦劝。于是贾母定要贾琏送他去，仍叫带回来。一应土仪盘缠，不消烦说，自然要妥贴。作速择了日期，贾琏与林黛玉辞别了贾母等，带领仆从，登舟往扬州去了。要知端的，且听下回分解。</p>
]]></content>
      <categories>
        <category>excerpt</category>
      </categories>
      <tags>
        <tag>红楼梦</tag>
        <tag>原文</tag>
        <tag>宝物</tag>
      </tags>
  </entry>
  <entry>
    <title>用命令行激活windows</title>
    <url>/2024/08/14/%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BF%80%E6%B4%BBwindows/</url>
    <content><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p>
<p><a href="http://leiyu-code.github.io">leiyu-code.github.io</a></p>
<p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p>
<p>直接以管理员打开CMD或POWERSHELL:</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、slmgr.vbs /upk</span><br><span class="line"><span class="number">2</span>、slmgr /ipk W269N-WFGWX-YVC9B-<span class="number">4</span>J6C9-T83GX</span><br><span class="line"><span class="number">3</span>、slmgr /skms zh.us.to</span><br><span class="line"><span class="number">4</span>、slmgr -ato</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>要是不行，把第三行改成slmgr -skms <a href="http://kms.03k.org">kms.03k.org</a><br>
slmgr.vbs /upk<br>
slmgr /ipk M7XTQ-FN8P6-TTKYV-9D4CC-J462D<br>
slmgr -skms <a href="http://kms.03k.org">kms.03k.org</a><br>
slmgr -ato<br>
slmgr.<br>
slmgr.vbs /upk<br>
slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX<br>
slmgr<br>
slmgr -skms <a href="http://kms.03k.org">kms.03k.org</a></p>
<p><a href="https://www.jianshu.com/p/4968e4f494d4">永久激活windows11 - 简书 (jianshu.com)</a></p>
]]></content>
      <categories>
        <category>Active</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>windows11</tag>
      </tags>
  </entry>
  <entry>
    <title>社区型免费蜜罐-hfish</title>
    <url>/2024/06/23/%E7%A4%BE%E5%8C%BA%E5%9E%8B%E5%85%8D%E8%B4%B9%E8%9C%9C%E7%BD%90-hfish/</url>
    <content><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p>
<p><a href="http://leiyu-code.github.io">leiyu-code.github.io</a></p>
<p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p>
<h4 id="HFish"><a href="https://hfish.net/#/README?id=hfish%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5">HFish</a></h4>
<p>HFish是一款社区型免费蜜罐，侧重企业安全场景，从内网失陷检测、外网威胁感知、威胁情报生产三个场景出发，为用户提供可独立操作且实用的功能，通过安全、敏捷、可靠的中低交互蜜罐增加用户在失陷感知和威胁情报领域的能力。</p>
<p>HFish支持基本网络 服务、OA系统、CRM系统、NAS存储系统、Web服务器、运维平台、安全产品、无线AP、交换机/路由器、邮件系统、IoT设备等90多种蜜罐服务、支持用户制作自定义Web蜜罐、支持流量牵引到免费云蜜网、支持可开关的全端口扫描感知能力、支持可自定义的蜜饵配置、一键部署、跨平台多架构，支持Linux x32/x64/ARM、Windows x32/x64平台和多种国产操作系统、支持龙芯、海光、飞腾、鲲鹏、腾云、兆芯等国产CPU、极低的性能要求、邮件/syslog/webhook/企业微信/钉钉/飞书告警等多项特性，帮助用户降低运维成本，提升运营效率。</p>
<p>用户需要先部署管理端，再通过管理端内置蜜罐节点或部署新节点：</p>
<p><a href="https://hfish.net/#/2-2-linux">Linux管理端下载</a></p>
<p><a href="https://hfish.net/#/2-3-windows">Windows管理端下载</a></p>
<p><a href="https://hfish.net/#/2-1-docker">Docker镜像下载</a></p>
<span id="more"></span>
<p>如果有企业下载需求，您也可以前往<a href="https://hfish.net/#/docs">HFish文档区域</a>下载部署文档方案。</p>
<h4 id="为什么选择HFish"><a href="https://hfish.net/#/README?id=%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9hfish">为什么选择HFish</a></h4>
<blockquote>
<h5 id="免费、简单、安全的蜜罐产品"><a href="https://hfish.net/#/README?id=%E5%85%8D%E8%B4%B9%E3%80%81%E7%AE%80%E5%8D%95%E3%80%81%E5%AE%89%E5%85%A8%E7%9A%84%E8%9C%9C%E7%BD%90%E4%BA%A7%E5%93%81">免费、简单、安全的蜜罐产品</a></h5>
</blockquote>
<p>蜜罐通常被定义为具有轻量级检测能力、低误报率的检测产品，同时它也是企业生产本地威胁情报的优质来源之一。HFish可以帮助中小型企业用户在日常安全运营中进行避免告警洪水、低成本的增加威胁感知和情报生产能力。目前，社区的力量正在不断帮助HFish完善自身，共同探索欺骗防御的最佳实践。</p>
<blockquote>
<h5 id="安全、敏捷的威胁感知节点"><a href="https://hfish.net/#/README?id=%E5%AE%89%E5%85%A8%E3%80%81%E6%95%8F%E6%8D%B7%E7%9A%84%E5%A8%81%E8%83%81%E6%84%9F%E7%9F%A5%E8%8A%82%E7%82%B9">安全、敏捷的威胁感知节点</a></h5>
</blockquote>
<p>HFish被广泛应用于感知办公内网、生产环境、云内网及其他环境失陷主机横向移动、员工账号外泄、扫描和探测行为、私有情报生产甚至内部演练和安全意识培训，HFish的多种告警输出形式与态感、NDR、XDR或日志平台结合，极大拓展检测视野。</p>
<h4 id="HFish架构"><a href="https://hfish.net/#/README?id=hfish%E6%9E%B6%E6%9E%84">HFish架构</a></h4>
<p>HFish采用B/S架构，HFish由管理端（server）和节点端（client）组成，管理端用来生成和管理节点端，并接收、分析和展示节点端回传的数据，节点端接受管理端的控制并负责构建蜜罐服务。</p>
<p>在HFish中，<strong>管理端</strong>只用于<strong>数据的分析和展示</strong>，<strong>节点端</strong>进行<strong>虚拟蜜罐</strong>，最后由<strong>蜜罐来承受攻击</strong>。</p>
<p>HFish各模块关系图</p>
<p><img src="https://hfish.net/images/20210616174908.png" alt="image-20210611130621311"></p>
<h4 id="我们的故事"><a href="https://hfish.net/#/README?id=%E6%88%91%E4%BB%AC%E7%9A%84%E6%95%85%E4%BA%8B">我们的故事</a></h4>
<p>2019年的8月7日，我们发布了自己的第一款开源蜜罐HFish，在之后的16个月里，HFish在Github上获得2.6k个star，在Gitee上成为安全类目TOP5的GVP项目。</p>
<p>2021年2月9日，融合社区反馈和过去2年的思考，我们开启了全新概念的威胁捕捉和诱骗系统HFish v2版本，并宣布采用闭源共享方式向所有用户免费授权使用。</p>
<h4 id="联系我们"><a href="https://hfish.net/#/README?id=%E8%81%94%E7%B3%BB%E6%88%91%E4%BB%AC">联系我们</a></h4>
<p>HFish是北京微步在线科技有限公司旗下社区型免费蜜罐产品</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">联系地址：北京市海淀区苏州街49号盈智大厦4层</span><br><span class="line">联系电话：400-030-1051复制失败成功</span><br></pre></td></tr></table></figure>
<p><img src="http://img.threatbook.cn/hfish/image-20220729162931543.png" alt="image-20220729162931543"></p>
]]></content>
      <categories>
        <category>safe</category>
      </categories>
      <tags>
        <tag>hfish</tag>
      </tags>
  </entry>
  <entry>
    <title>windows命令-route</title>
    <url>/2024/06/23/windows%E5%91%BD%E4%BB%A4%E2%80%94route/</url>
    <content><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p>
<p>leiyu-code.github.io</p>
<p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p>
<h4 id="route命令"><a href="#route命令" class="headerlink" title="route命令"></a><em><strong>route命令</strong></em></h4><p>  route命令用于显示和操作IP路由表。要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者同时位于两个网络的网关来实现。windows环境下route命令常用于多网卡终端，默认路由指向连接访问互联网的网卡，静态路由指向内网网卡。</p>
<span id="more"></span>

<h5 id="1、获取命令帮助"><a href="#1、获取命令帮助" class="headerlink" title="1、获取命令帮助"></a>1、获取命令帮助</h5><p>route –help或者route命令获取帮助 </p>
<p><a href="https://imgse.com/i/pkr05VI"><img src="https://s21.ax1x.com/2024/06/23/pkr05VI.png" alt="pkr05VI.png"></a></p>
<h5 id="2、查看路由表"><a href="#2、查看路由表" class="headerlink" title="2、查看路由表"></a>2、查看路由表</h5><p>route print命令查看主机路由表，可以使用route print -4查看ipv4 路由表。 </p>
<p><a href="https://imgse.com/i/pkr0hqA"><img src="https://s21.ax1x.com/2024/06/23/pkr0hqA.png" alt="pkr0hqA.png"></a></p>
<h5 id="3、显示某网段路由"><a href="#3、显示某网段路由" class="headerlink" title="3、显示某网段路由"></a>3、显示某网段路由</h5><p>route print 192.168.3*显示192.168.3开头的路由段 </p>
<p><a href="https://imgse.com/i/pkr0frd"><img src="https://s21.ax1x.com/2024/06/23/pkr0frd.png" alt="pkr0frd.png"></a></p>
<h5 id="4、添加一条静态路由"><a href="#4、添加一条静态路由" class="headerlink" title="4、添加一条静态路由"></a>4、添加一条静态路由</h5><p>route add添加一条路由，此操作需要使用administrator管理员权限。 </p>
<p><a href="https://imgse.com/i/pkr02xe"><img src="https://s21.ax1x.com/2024/06/23/pkr02xe.png" alt="pkr02xe.png"></a></p>
<h5 id="5、修改一条路由"><a href="#5、修改一条路由" class="headerlink" title="5、修改一条路由"></a>5、修改一条路由</h5><p>route change修改路由网关或者跃点数。 </p>
<p><a href="https://imgse.com/i/pkr0WKH"><img src="https://s21.ax1x.com/2024/06/23/pkr0WKH.png" alt="pkr0WKH.png"></a></p>
<h5 id="6、删除一条路由"><a href="#6、删除一条路由" class="headerlink" title="6、删除一条路由"></a>6、删除一条路由</h5><p>route delete删除一条路由 </p>
<p><a href="https://imgse.com/i/pkr0Iat"><img src="https://s21.ax1x.com/2024/06/23/pkr0Iat.png" alt="pkr0Iat.png"></a></p>
<h5 id="7、永久添加一条路由"><a href="#7、永久添加一条路由" class="headerlink" title="7、永久添加一条路由"></a>7、永久添加一条路由</h5><p>route add ipnet mask x.x.x.0 gateway -p添加永久路由 </p>
<p><a href="https://imgse.com/i/pkr0oIP"><img src="https://s21.ax1x.com/2024/06/23/pkr0oIP.png" alt="pkr0oIP.png"></a></p>
<p><em><strong>使用语法及参数说明</strong></em></p>
<h5 id="1、使用语法"><a href="#1、使用语法" class="headerlink" title="1、使用语法"></a>1、使用语法</h5><blockquote>
<p> 用法：ROUTE [-f] [-p] [-4|-6] command [destination] [MASK netmask] [gateway] [METRIC metric] [IF interface] </p>
</blockquote>
<h5 id="2、参数说明"><a href="#2、参数说明" class="headerlink" title="2、参数说明"></a>2、参数说明</h5><table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">参数说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-f</td>
<td align="left">清除所有网关项的路由表。如果与某个命令结合使用，在运行该命令前，应清除路由表。</td>
</tr>
<tr>
<td align="left">-p</td>
<td align="left">与 ADD 命令结合使用时，将路由设置为在系统引导期间保持不变。默认情况下，重新启动系统时，不保存路由。忽略所有其他命令，这始终会影响相应的永久路由。Windows 95不支持此选项。</td>
</tr>
<tr>
<td align="left">-4</td>
<td align="left">强制使用 IPv4。</td>
</tr>
<tr>
<td align="left">-6</td>
<td align="left">强制使用 IPv6。</td>
</tr>
<tr>
<td align="left">command</td>
<td align="left">其中之一: PRINT 打印路由  ADD 添加路由  DELETE 删除路由  CHANGE 修改现有路由</td>
</tr>
<tr>
<td align="left">destination</td>
<td align="left">指定主机。</td>
</tr>
<tr>
<td align="left">MASK</td>
<td align="left">指定下一个参数为“网络掩码”值。</td>
</tr>
<tr>
<td align="left">netmask</td>
<td align="left">指定此路由项的子网掩码值。如果未指定，其默认设置为 255.255.255.255。</td>
</tr>
<tr>
<td align="left">gateway</td>
<td align="left">指定网关。</td>
</tr>
<tr>
<td align="left">interface</td>
<td align="left">指定路由的接口号码。</td>
</tr>
<tr>
<td align="left">METRIC</td>
<td align="left">指定跃点数，例如目标的成本。</td>
</tr>
</tbody></table>
<hr>
<p><em><strong>实例</strong></em></p>
<p>需求描述：<br>    1. Win10, 网卡1接外网，网卡2接内网，只能Ping通外网无法Ping通内网。<br>        如果禁用网卡1(外网)，即可Ping通网卡2（内网）</p>
<ol start="2">
<li>备注：<br>① 这里的网卡对有线网卡或无线网卡都适用；<br>②Win10版本 64位1909;<br>③WIN7可以在“网络和共享中心”——“更改适配器设置”——“网络设置中界面中，按ALT键”调出隐藏菜单栏——在选项“高级-高级设置”中，可以手动调整网卡优先级。<br>But，Win10不可以，取消了，只能通过修改接口跃点数实现（不建议）。</li>
<li>解决方法：静态路由——只针对有限数量的IP<br>Eg. 网卡1网段192.168.20，网卡2网段10.19.20，只能Ping通网段1,需要和网段2的IP（11.20.203.5）建立通讯，那就在CMD命令中增加一个路由：<br>route -p add 11.20.203.5(目标IP) mask 255.255.255.0(子网掩码) 192.168.20.254（网关）<br>注意：以管理员运行CMD，运行完提示完成后，必须重启。</li>
</ol>
<p><a href="https://javaforall.cn/161116.html">https://javaforall.cn/161116.html</a></p>
<p>原文链接：<a href="https://javaforall.cn/">https://javaforall.cn</a></p>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>cmd</tag>
        <tag>route</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器安全批处理</title>
    <url>/2024/06/23/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E6%89%B9%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p>
<p><a href="http://leiyu-code.github.io">leiyu-code.github.io</a></p>
<p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p>
<p><em><strong>用法：</strong></em></p>
<p>桌面新建文本文件</p>
<p>将下列代码粘贴到文件文件，并且改文件名称后缀txt为bat，双击运行</p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@<span class="built_in">ECHO</span> OFF </span><br><span class="line"><span class="built_in">CLS</span> </span><br><span class="line"><span class="built_in">TITLE</span> SERVER SAFE SETUP PRO </span><br><span class="line"><span class="built_in">COLOR</span> <span class="number">0</span>A </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe C:\ /p Administrators:f system:f &quot;network service&quot;:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe D:\ /p Administrators:f system:f servU:f &quot;network service&quot;:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe E:\ /p Administrators:f system:f servU:f &quot;network service&quot;:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe &quot;C:\Program Files&quot; /t /p Administrators:f system:f everyone:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe &quot;C:\Program Files\Common Files&quot; /t /g Administrators:f system:f everyone:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows /p Administrators:f system:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32 /p Administrators:f system:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe C:\WINDOWS\system32\inetsrv /p Administrators:f system:f everyone:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe &quot;C:\Documents and Settings&quot; /p Administrators:f system:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe &quot;C:\Documents and Settings\All Users&quot; /t /p Administrator:f system:f everyone:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\temp /p everyone:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe <span class="variable">%systemroot%</span>\system32\shell32.dll /p Administrators:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe <span class="variable">%systemroot%</span>\system32\wshom.ocx /p Administrators:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32\*.exe /p Administrators:f system:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe &quot;c:\Documents and Settings\All Users&quot; /e /g everyone:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe <span class="variable">%systemroot%</span>\system32\svchost.exe /e /g &quot;network service&quot;:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe <span class="variable">%systemroot%</span>\system32\msdtc.exe /e /g &quot;network service&quot;:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe <span class="variable">%windir%</span>\system32\mtxex.dll /e /g everyone:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32\<span class="built_in">cmd</span>.exe /p Administrator:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32\<span class="built_in">net</span>.exe /p Administrator:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32\net1.exe /p Administrator:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32\sc.exe /p Administrator:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32\<span class="built_in">at</span>.exe /p Administrator:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe <span class="variable">%windir%</span>\system32\dllhost.exe /e /g everyone:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32\netsh.exe /p Administrator:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32\<span class="built_in">net</span>.exe /p Administrator:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32\<span class="built_in">cacls</span>.exe /p Administrator:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32\cmdkey.exe /p Administrator:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32\ftp.exe /p Administrator:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32\tftp.exe /p Administrator:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32\reg.exe /p Administrator:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32\regedt32.exe /p Administrator:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe c:\windows\system32\regini.exe /p Administrator:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe <span class="variable">%windir%</span>\assembly /e /t /g &quot;network service&quot;:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe <span class="variable">%windir%</span>\Microsoft.<span class="built_in">NET</span> /e /t /g everyone:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe &quot;<span class="variable">%windir%</span>\Microsoft.<span class="built_in">NET</span>\Framework\v1.<span class="number">1</span>.<span class="number">4322</span>\Temporary ASP.<span class="built_in">NET</span> Files&quot; /e /t /g everyone:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe <span class="variable">%windir%</span>\system32\mscoree.dll /e /g everyone:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe <span class="variable">%windir%</span>\system32\ws03res.dll /e /g everyone:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe <span class="variable">%windir%</span>\system32\msxml*.dll /e /g everyone:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe C:\WINDOWS\system32\urlmon.dll /e /g everyone:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe C:\WINDOWS\system32\mlang.dll /e /g everyone:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe C:\WINDOWS\system32\TAPI32.dll /e /g everyone:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe C:\WINDOWS\system32\WININET.dll /e /g everyone:r </span><br><span class="line"><span class="built_in">cacls</span> c:\windows\assembly /e /t /p &quot;network service&quot;:r </span><br><span class="line"><span class="built_in">cacls</span> c:\windows\Microsoft.<span class="built_in">NET</span> /e /t /p &quot;network service&quot;:r </span><br><span class="line"><span class="built_in">cacls</span> &quot;C:\WINDOWS\Microsoft.<span class="built_in">NET</span>\Framework\v1.<span class="number">1</span>.<span class="number">4322</span>\Temporary ASP.<span class="built_in">NET</span> Files&quot; /e /t /p &quot;network service&quot;:f </span><br><span class="line"><span class="built_in">cacls</span> C:\WINDOWS\system32\mscoree.dll /e /g everyone:r </span><br><span class="line"><span class="built_in">cacls</span> C:\WINDOWS\system32\ws03res.dll /e /g everyone:r </span><br><span class="line"><span class="built_in">cacls</span> c:\WINDOWS /e /g &quot;network service&quot;:r </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">exist</span> c:\windows <span class="built_in">cacls</span> c:\windows /e /g &quot;network service&quot;:r </span><br><span class="line"><span class="built_in">cacls</span> c:\windows\Microsoft.<span class="built_in">NET</span> /e /t /p &quot;network service&quot;:r </span><br><span class="line"><span class="built_in">cacls</span> &quot;C:\WINDOWS\Microsoft.<span class="built_in">NET</span>\Framework\v1.<span class="number">1</span>.<span class="number">4322</span>\Temporary ASP.<span class="built_in">NET</span> Files&quot; /e /t /p &quot;network service&quot;:f </span><br><span class="line"><span class="built_in">cacls</span> &quot;C:\WINDOWS\Microsoft.<span class="built_in">NET</span>\Framework\v2.<span class="number">0</span>.<span class="number">50727</span>\Temporary ASP.<span class="built_in">NET</span> Files&quot; /e /t /p &quot;network service&quot;:f </span><br><span class="line"><span class="built_in">cacls</span> c:\windows\system32 /e /g &quot;network service&quot;:r </span><br><span class="line"><span class="built_in">cacls</span> c:\windows\system32\rasapi32.dll /e /g &quot;network service&quot;:r </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe C:\WINDOWS\system32\inetsrv\adsiis.dll /p Administrators:f autosystem:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe C:\WINDOWS\system32\inetsrv\iisadmpwd /p Administrators:f autosystem:f </span><br><span class="line"><span class="built_in">echo</span> y|<span class="built_in">cacls</span>.exe C:\WINDOWS\system32\inetsrv\MetaBack /p Administrators:f autosystem:f </span><br><span class="line"><span class="built_in">cacls</span> C&quot;:\Program Files\Serv-U&quot; /e /g &quot;servu&quot;:f </span><br><span class="line"><span class="built_in">cacls</span> d:\wwwroot /e /g servU:f </span><br><span class="line"><span class="built_in">echo</span> 以上设置服务器目录权限 </span><br><span class="line"></span><br><span class="line"><span class="built_in">net</span> stop Browser </span><br><span class="line">sc config Browser <span class="built_in">start</span>= disabled </span><br><span class="line"><span class="built_in">net</span> stop lanmanserver </span><br><span class="line">sc config lanmanserver <span class="built_in">start</span>= disabled </span><br><span class="line"><span class="built_in">net</span> share c$ /delete </span><br><span class="line"><span class="built_in">net</span> share d$ /delete </span><br><span class="line"><span class="built_in">net</span> share e$ /delete </span><br><span class="line"><span class="built_in">net</span> share f$ /delete </span><br><span class="line"><span class="built_in">net</span> share admin$ /delete </span><br><span class="line"><span class="built_in">net</span> share ipc$ /delete </span><br><span class="line"><span class="built_in">echo</span> 以上删除默认共享，设置服务项 </span><br><span class="line"><span class="built_in">echo</span> .. delshare.reg ....... </span><br><span class="line"><span class="built_in">echo</span> Windows Registry Editor Version <span class="number">5</span>.<span class="number">00</span>&gt; c:\delshare.reg </span><br><span class="line"><span class="built_in">echo</span> [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\lanmanserver\parameters]&gt;&gt; c:\delshare.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;AutoShareWks&quot;=dword:<span class="number">00000000</span>&gt;&gt; c:\delshare.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;AutoShareServer&quot;=dword:<span class="number">00000000</span>&gt;&gt; c:\delshare.reg </span><br><span class="line"><span class="built_in">echo</span> .. delshare.reg ..... </span><br><span class="line">regedit /s c:\delshare.reg </span><br><span class="line"><span class="built_in">echo</span> .. delshare.reg .... </span><br><span class="line"><span class="built_in">del</span> c:\delshare.reg </span><br><span class="line"><span class="built_in">echo</span> . </span><br><span class="line"><span class="built_in">echo</span> ........ </span><br><span class="line"><span class="built_in">echo</span> . </span><br><span class="line"><span class="built_in">echo</span> ========================================================= </span><br><span class="line"><span class="built_in">echo</span> . </span><br><span class="line"><span class="built_in">echo</span> .....................dos.... </span><br><span class="line"><span class="built_in">echo</span> . </span><br><span class="line"><span class="built_in">echo</span> ......... </span><br><span class="line"><span class="built_in">echo</span> Windows Registry Editor Version <span class="number">5</span>.<span class="number">00</span>&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters]&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;EnableICMPRedirect&quot;=dword:<span class="number">00000000</span>&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;DeadGWDetectDefault&quot;=dword:<span class="number">00000001</span>&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;DontAddDefaultGatewayDefault&quot;=dword:<span class="number">00000000</span>&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;EnableSecurityFilters&quot;=dword:<span class="number">00000000</span>&quot;&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;AllowUnqualifiedQuery&quot;=dword:<span class="number">00000000</span>&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;PrioritizeRecordData&quot;=dword:<span class="number">00000001</span>&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;ReservedPorts&quot;=hex(<span class="number">7</span>):<span class="number">31</span>,<span class="number">00</span>,<span class="number">34</span>,<span class="number">00</span>,<span class="number">33</span>,<span class="number">00</span>,<span class="number">33</span>,<span class="number">00</span>,<span class="number">2</span>d,<span class="number">00</span>,<span class="number">31</span>,<span class="number">00</span>,<span class="number">34</span>,<span class="number">00</span>,<span class="number">33</span>,<span class="number">00</span>,<span class="number">34</span>,<span class="number">00</span>,\&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> <span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;SynAttackProtect&quot;=dword:<span class="number">00000002</span>&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;EnablePMTUDiscovery&quot;=dword:<span class="number">00000000</span>&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;NoNameReleaseOnDemand&quot;=dword:<span class="number">00000001</span>&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;EnableDeadGWDetect&quot;=dword:<span class="number">00000000</span>&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;KeepAliveTime&quot;=dword:<span class="number">00300000</span>&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;PerformRouterDiscovery&quot;=dword:<span class="number">00000000</span>&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;EnableICMPRedirects&quot;=dword:<span class="number">00000000</span>&gt;&gt; c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> . </span><br><span class="line"><span class="built_in">echo</span> ========================================================== </span><br><span class="line"><span class="built_in">echo</span> .. dosforwin.reg ..... </span><br><span class="line">regedit /s c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> .. dosforwin.reg .... </span><br><span class="line"><span class="built_in">del</span> c:\dosforwin.reg </span><br><span class="line"><span class="built_in">echo</span> ============================================================== </span><br><span class="line"><span class="built_in">echo</span> . </span><br><span class="line"><span class="built_in">echo</span> =============================================================== </span><br><span class="line"><span class="built_in">echo</span> ..Remote Registry Service........... </span><br><span class="line"><span class="built_in">echo</span> ......... </span><br><span class="line"><span class="built_in">echo</span> . </span><br><span class="line"><span class="built_in">echo</span> Windows Registry Editor Version <span class="number">5</span>.<span class="number">00</span>&gt; c:\regedit.reg </span><br><span class="line"><span class="built_in">echo</span> [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\RemoteRegistry]&gt;&gt; c:\regedit.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;<span class="built_in">Start</span>&quot;=dword:<span class="number">00000004</span>&gt;&gt; c:\regedit.reg </span><br><span class="line"><span class="built_in">echo</span> . </span><br><span class="line"><span class="built_in">echo</span> .. regedit.reg ..... </span><br><span class="line">regedit /s c:\regedit.reg </span><br><span class="line"><span class="built_in">echo</span> . </span><br><span class="line"><span class="built_in">echo</span> ...... </span><br><span class="line"><span class="built_in">del</span> c:\regedit.reg </span><br><span class="line"><span class="built_in">echo</span> =============================================================== </span><br><span class="line"><span class="built_in">echo</span> ..Messenger....... </span><br><span class="line"><span class="built_in">echo</span> ......... </span><br><span class="line"><span class="built_in">echo</span> Windows Registry Editor Version <span class="number">5</span>.<span class="number">00</span>&gt; c:\message.reg </span><br><span class="line"><span class="built_in">echo</span> [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Messenger]&gt;&gt; c:\message.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;<span class="built_in">Start</span>&quot;=dword:<span class="number">00000004</span>&gt;&gt; c:\message.reg </span><br><span class="line"><span class="built_in">echo</span> . </span><br><span class="line"><span class="built_in">echo</span> .. message.reg ..... </span><br><span class="line">regedit /s c:\message.reg </span><br><span class="line"><span class="built_in">echo</span> . </span><br><span class="line"><span class="built_in">echo</span> .. message.reg </span><br><span class="line"><span class="built_in">del</span> c:\message.reg </span><br><span class="line"><span class="built_in">echo</span> =============================================================== </span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> =============================================================== </span><br><span class="line"><span class="built_in">echo</span> ..lanmanserver....... </span><br><span class="line"><span class="built_in">echo</span> ......... </span><br><span class="line"><span class="built_in">echo</span> Windows Registry Editor Version <span class="number">5</span>.<span class="number">00</span>&gt; c:\lanmanserver.reg </span><br><span class="line"><span class="built_in">echo</span> [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\lanmanserver]&gt;&gt; c:\lanmanserver.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;<span class="built_in">Start</span>&quot;=dword:<span class="number">00000004</span>&gt;&gt; c:\lanmanserver.reg </span><br><span class="line"><span class="built_in">echo</span> . </span><br><span class="line"><span class="built_in">echo</span> .. lanmanserver.reg ..... </span><br><span class="line">regedit /s c:\lanmanserver.reg </span><br><span class="line"><span class="built_in">echo</span> . </span><br><span class="line"><span class="built_in">echo</span> .. lanmanserver.reg </span><br><span class="line"><span class="built_in">del</span> c:\lanmanserver.reg </span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> ============================================================== </span><br><span class="line"><span class="built_in">echo</span> ...TCP/IP NetBIOS Helper Service </span><br><span class="line"><span class="built_in">echo</span> ......... </span><br><span class="line"><span class="built_in">echo</span> Windows Registry Editor Version <span class="number">5</span>.<span class="number">00</span>&gt; c:\netbios.reg </span><br><span class="line"><span class="built_in">echo</span> [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\LmHosts]&gt;&gt; c:\netbios.reg </span><br><span class="line"><span class="built_in">echo</span> &quot;<span class="built_in">Start</span>&quot;=dword:<span class="number">00000004</span>&gt;&gt; c:\netbios.reg </span><br><span class="line"><span class="built_in">echo</span> . </span><br><span class="line"><span class="built_in">echo</span> .. netbios.reg ..... </span><br><span class="line">regedit /s c:\netbios.reg </span><br><span class="line"><span class="built_in">echo</span> . </span><br><span class="line"><span class="built_in">echo</span> .. netbios.reg </span><br><span class="line"><span class="built_in">del</span> c:\netbios.reg </span><br><span class="line">regedit /s forddos.reg </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>server</category>
      </categories>
      <tags>
        <tag>safe</tag>
        <tag>bat</tag>
      </tags>
  </entry>
  <entry>
    <title>美食推荐——蒸鸡蛋糕</title>
    <url>/2024/06/21/%E7%BE%8E%E9%A3%9F%E6%8E%A8%E8%8D%90%E2%80%94%E2%80%94%E8%92%B8%E9%B8%A1%E8%9B%8B%E7%B3%95/</url>
    <content><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p>
<p>leiyu-code.github.io</p>
<p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p>
<p><strong>问题：做蒸鸡蛋糕总是里边有孔洞</strong></p>
<p><a href="https://imgse.com/i/pkD2R10"><img src="https://s21.ax1x.com/2024/06/21/pkD2R10.png" alt="pkD2R10.png"></a></p>
<span id="more"></span>



<p>原料：鸡蛋、食盐、香油</p>
<p>制作步骤：</p>
<p>1、两个鸡蛋敲小碗里。</p>
<p>2、另一个小碗中加入与蛋液差不多量的清水。水对蛋液比例1：1到1：1.5之间均可。清水用温水好些，在水中加入食盐，搅拌均匀，使之充分溶解。食盐也可在后续搅蛋液的时候放，为了能更均匀所以先放清水里了。</p>
<p>3、把食盐水和蛋液混合，搅拌，至蛋液完全搅散。（这时候表面会有很多气泡，这样直接蒸的话里边的气泡就是孔洞的成因。）</p>
<p>4、现在<strong>进行消除气泡的工艺——过筛</strong>。用细筛网过一遍蛋液，气泡都留在筛网上了。过完筛的蛋液再去除表面少量的气泡，就可以了。</p>
<p>5、加入适量的香油。加香油蒸出来的鸡蛋糕是金黄的，很漂亮。没有香油加其他植物油也可，颜色上可能差些，但不耽误好吃。</p>
<p>6、上蒸锅，<strong>至关重要的第二道工艺来了——扣盘子。这样可以避免蒸的过程中蛋液起泡。</strong>（如果盛蛋液的容器口过大，用保鲜膜覆盖也可，效果是一样的。只是比扣盘子麻烦些，我试过。）</p>
<p>7、盖上锅盖，大火把水烧开。用中火，蒸12分钟即可。（蒸的过程中什么也不用管，例如开盖放气之类的，这些都已经被扣盘子的工艺解决了。）</p>
<p><a href="https://imgse.com/i/pkD22pq"><img src="https://s21.ax1x.com/2024/06/21/pkD22pq.png" alt="pkD22pq.png"></a></p>
<hr>
<p><strong>总结：</strong> <em><strong>过筛，是为了消气泡；</strong></em></p>
<p>​            <em><strong>扣盘子，是为了蒸制过程蛋液表面平整。</strong></em>这两个步骤很有用哦，其余就可自由发挥了，加些葱花、虾皮之类的也不错，全凭个人喜好～</p>
]]></content>
      <categories>
        <category>food</category>
      </categories>
      <tags>
        <tag>eggcake</tag>
      </tags>
  </entry>
  <entry>
    <title>佳软推荐——最好用的PDF虚拟打印机CutePDF Writer</title>
    <url>/2024/06/21/%E4%BD%B3%E8%BD%AF%E6%8E%A8%E8%8D%90%E2%80%94%E2%80%94%E6%9C%80%E5%A5%BD%E7%94%A8%E7%9A%84PDF%E8%99%9A%E6%8B%9F%E6%89%93%E5%8D%B0%E6%9C%BACutePDF%20Writer/</url>
    <content><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p>
<p>leiyu-code.github.io</p>
<p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p>
<p>CutePDF Writer是 Acro Software公司出品的免费PDF虚拟打印机，支持 win98-win7，支持32位&#x2F;64位。<br><strong>软件优点：</strong>经典、稳定、持续但绝不频繁地升级；完美支持中文、字体美观。CutePDF Writer 是我使用时间跨度最长、纯使用时间最长的PDF虚拟打印机。<br>它也需要PS2PDF的转换器，当然，推荐的转换器依然是Ghostscript。并且，官方提供了一个专门制作的 GPLGS8.15 Converter，与 CutePDF Writer配合使用。相比自己下载的版本，它体积更小，并且兼容性更有保证。<br>完全免费，可以用于商业用途。（FREE for commercial and non-commercial use!）无水印。无弹出广告。</p>
<p><a href="https://imgse.com/i/pkDcl36"><img src="https://s21.ax1x.com/2024/06/21/pkDcl36.png" alt="pkDcl36.png"></a></p>
<span id="more"></span>



<p><em><strong>CutePDF Writer的安装：</strong></em></p>
<p>下载 <a href="http://download.cutepdf.com/download/CuteWriter.zip">zip安装包</a>（8MB），内含2个文件。<br>　　　- 先运行其中的 converter.exe （5MB），安装转换器。安装过程基本不需要任何干预。<br>　　　- 再运行其中的 CuteWriter.exe （3MB），安装PDF Writer。注意：安装过程<strong>有Ask Toobar推广广告，可以选择不安装</strong>（视频第50秒开始）。<br>　　　- 然后，就可以在任意程序的“打印”菜单中，选择CutePDF Writer，把文档打印为pdf了。</p>
<p><a href="https://imgse.com/i/pkDc3jO"><img src="https://s21.ax1x.com/2024/06/21/pkDc3jO.png" alt="pkDc3jO.png"></a></p>
<p><a href="https://imgse.com/i/pkDc1gK"><img src="https://s21.ax1x.com/2024/06/21/pkDc1gK.png" alt="pkDc1gK.png"></a></p>
<hr>
<p><strong>总结：最好用的pdf打印机CutePDF Writer，别的pdf打印机打出来乱码、格式不对的时候下来试试吧！</strong></p>
<p>​           <em><strong>WPS也自己带有pdf打印机，安装后就可以直接使用</strong></em></p>
]]></content>
      <categories>
        <category>software</category>
      </categories>
      <tags>
        <tag>print</tag>
        <tag>pdf</tag>
      </tags>
  </entry>
  <entry>
    <title>com+错误代码8007042c-依赖服务或组无法启动</title>
    <url>/2024/06/21/com+%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%818007042c-%E4%BE%9D%E8%B5%96%E6%9C%8D%E5%8A%A1%E6%88%96%E7%BB%84%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p>
<p>leiyu-code.github.io</p>
<p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p>
<p><em><strong>com+错误代码8007042c-依赖服务或组无法启动</strong></em></p>
<p><a href="https://imgse.com/i/pkDwpDI"><img src="https://s21.ax1x.com/2024/06/21/pkDwpDI.png" alt="pkDwpDI.png"></a></p>
<span id="more"></span>



<p><em><strong>解决方法：</strong></em></p>
<ol>
<li><p>查看系统日志，发现与 COM+ System Application 服务相依的服务因下列错误system Event Notification Senice而无法启动:无法启动服务，原因可能是已被禁用或与其相关联的设备没有启动。</p>
</li>
<li><p>进入控制面板里的卸载或更改程序和功能，点击打开或关闭windows功能,勾选system Event Notification Senice，安装windows相关功能。</p>
<p><a href="https://imgse.com/i/pkDwPVP"><img src="https://s21.ax1x.com/2024/06/21/pkDwPVP.png" alt="pkDwPVP.png"></a></p>
<p><a href="https://imgse.com/i/pkDwSKA"><img src="https://s21.ax1x.com/2024/06/21/pkDwSKA.png" alt="pkDwSKA.png"></a></p>
<p><a href="https://imgse.com/i/pkDw9bt"><img src="https://s21.ax1x.com/2024/06/21/pkDw9bt.png" alt="pkDw9bt.png"></a></p>
</li>
<li><p>打开com+和dtc相关的服务。</p>
<p><a href="https://imgse.com/i/pkDBTDs"><img src="https://s21.ax1x.com/2024/06/21/pkDBTDs.png" alt="pkDBTDs.png"></a></p>
<p><a href="https://imgse.com/i/pkDBouj"><img src="https://s21.ax1x.com/2024/06/21/pkDBouj.png" alt="pkDBouj.png"></a></p>
</li>
</ol>
<hr>
<p><strong>总结：widows系统报错，先查看系统日志，应用程序日志，查看错误原因，无法启动服务就安装相应的windows功能，启动相应的服务，并将有关联的服务改成自动启动。</strong></p>
]]></content>
      <categories>
        <category>workNote</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>wrong</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器安全配置基本设置</title>
    <url>/2024/06/21/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p>
<p>leiyu-code.github.io</p>
<p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p>
<p>对windows服务器进行以下的设置和相关策略的制定，可以有效的增加服务器的自身防御能力，防止黑客利用常见的攻击手段和方法对服务器进行入侵和破坏，降低数据被盗取的风险。</p>
<p><em><strong>gpedit.msc  组策略编辑器</strong></em></p>
<p><em><strong>regedit  注册表编辑器</strong></em></p>
<p><em><strong>services.msc  计算机服务</strong></em></p>
<p><em><strong>msconfig  系统配置</strong></em></p>
<p><em><strong>firewall.cpl  防火墙</strong></em></p>
<span id="more"></span>



<p><em><strong>计算机安全策略配置：</strong></em></p>
<p><strong>(一) 修改远程桌面端口</strong></p>
<p>将默认端口3389修改为XXX。</p>
<p><strong>(二) 帐户</strong></p>
<p>对系统管理员默认帐户administrator进行重命名，停用guest用户。</p>
<p><strong>(三) 开启windows防火墙</strong></p>
<p>  取消网络连接中的文件和打印共享。</p>
<p>  在例外里面添加远程桌面端口XXX。</p>
<p>  在防火墙高级设置时勾选Web服务和安全的Web服务。</p>
<p>  在防火墙开放FTP端口XX。</p>
<p>  开放短信发送平台端口：XXX</p>
<p><strong>(四) 禁用无关服务</strong></p>
<p>  Printspooler 打印服务</p>
<p>  Wirelessconfiguration 无线服务</p>
<p>  RoutingandRemoteAccess在局域网以及广域网环境中为企业提供路由服务。</p>
<p>  NTLMSecuritysupportprovide：telnet服务和MicrosoftSerch服务使用。</p>
<p>  Telnet允许远程用户登录到此计算机并运行程序。</p>
<p>  RemoteDesktopHelpSessionManager：远程协助服务。</p>
<p>  ErrorReportingService收集、存储和向Microsoft报告异常应用程序。</p>
<p>  RemoteRegistry 远程注册表操作。</p>
<p><strong>(五) 禁止IPC空连接</strong></p>
<p>打开注册表找到Local_Machine\System\CurrentControlSet\Control\LSA-RestrictAnonymous把这个值改成”1”即可。</p>
<p><strong>(六) 删除默认共享</strong></p>
<p>打开注册表找到HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters，新建AutoShareServer类型是REG_DWORD把值改为0。</p>
<p><strong>(七) 策略配置</strong></p>
<p>组策略配置:gpedit—&gt;计算机配置—&gt;windows设置—&gt;安全设置—&gt;本地策略。</p>
<p>在用户权利分配下，从通过网络访问此计算机中删除PowerUsers和BackupOperators;</p>
<p>启用不允许匿名访问SAM帐号和共享;</p>
<p>启用不允许为网络验证存储凭据或Passport;</p>
<p>从文件共享中删除允许匿名登录的DFS$和COMCFG;</p>
<p>启用交互登录：不显示上次的用户名;</p>
<p>启用在下一次密码变更时不存储LANMAN哈希值;</p>
<p>禁止IIS匿名用户在本地登录。</p>
<hr>
<p><strong>总结：</strong> 打开windows防火墙、windows更新，并进行简单的配置也能在最大的程度上防止黑客的入侵</p>
]]></content>
      <categories>
        <category>server</category>
      </categories>
      <tags>
        <tag>safe</tag>
      </tags>
  </entry>
  <entry>
    <title>斑马Zebra条码打印机软件和驱动须知</title>
    <url>/2024/06/20/%E6%96%91%E9%A9%ACZebra%E6%9D%A1%E7%A0%81%E6%89%93%E5%8D%B0%E6%9C%BA%E8%BD%AF%E4%BB%B6%E5%92%8C%E9%A9%B1%E5%8A%A8%E9%A1%BB%E7%9F%A5/</url>
    <content><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p>
<p>leiyu-code.github.io</p>
<p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p>
<p><em><strong>条码打印机须知</strong></em></p>
<p>1、888T的打印方式是热敏&#x2F;热转印；</p>
<p>​      888D的打印方式是热敏</p>
<p>2、热敏打印和热转印是条码机的两种打印方式。</p>
<p>虽然每种方法都使用热敏打印头对打印表面加热。 </p>
<p>热转印是通过加热色带，在多种材料上打印出耐用、持久的图案。</p>
<p>热敏打印不使用色带，而是直接在标签材料上打印图案。</p>
<p>3、条码打印机使用的条码编辑软件要有相应的打印机驱动才能进入条码编辑软件</p>
<span id="more"></span>



<p><em><strong>热敏和热转印的区别：</strong></em></p>
<ol>
<li>技术原理</li>
</ol>
<p><strong>热敏打印：</strong>主要通过对打印头加热，并接触经过化学处理的热敏介质标签后打印出所需图案。热敏标签打印机在使用时不需要任何油墨、墨粉或碳带，使用成本相对较低。</p>
<p><strong>热转印打印：</strong>主要通过打印头对碳带加热，油墨转印在标签材料上形成图案。热转印标签打印机由于需要碳带，标签纸技术要求比热敏高，因此整体成本存在较大差距。</p>
<p><strong>02. 适配耗材</strong></p>
<p><strong>热敏打印：</strong>只能使用热敏纸</p>
<p><strong>热转印打印：</strong>可接受更多品种的介质，包括PP合成纸、PVC、PET等材质</p>
<p><strong>03. 保存时间</strong></p>
<p><strong>热敏打印标签：</strong>对热、光、化学溶剂和磨损敏感，在日常环境下长时间存放后，图案会随时间推移而褪色。市面上普通的热敏标签打印内容保存时间一般为几个月，精臣销售的热敏标签纸采用多层覆膜工艺，一般可保存1-2年不等（具体时长受实际使用环境因素影响决定）。</p>
<p><strong>热转印打印标签：</strong>能够提供其他打印技术无法匹敌的图案质量和耐久性，相较于热敏打印，保存时间更长久，一般为5年左右，具体时间受标签纸和碳带质量影响，精臣热转印标签采用高品质树脂基碳带，一般可保存8-10年时间。</p>
<p><strong>04. 使用场景</strong></p>
<p><strong>热敏打印：</strong>适用于家用、餐饮、商超零售、服装、物流等标签标识更新频率较快并且对条形码要求不高的行业。</p>
<p><strong>热转印打印：</strong>适用于制造业、汽车业、电力通信、医疗业、纺织业、化学工业、制药工业、零售分发业、运输业和物流、政府机构等多类行业。</p>
<p><em><strong>Zebra 888t条码打印机使用软件</strong></em></p>
<p>ZebraDesigner  V2</p>
<p><a href="https://imgse.com/i/pkDYyx1"><img src="https://s21.ax1x.com/2024/06/21/pkDYyx1.png" alt="pkDYyx1.png"></a></p>
<p><a href="https://imgse.com/i/pkDYcKx"><img src="https://s21.ax1x.com/2024/06/21/pkDYcKx.png" alt="pkDYcKx.png"></a></p>
<p><a href="https://imgse.com/i/pkDYs2R"><img src="https://s21.ax1x.com/2024/06/21/pkDYs2R.png" alt="pkDYs2R.png"></a></p>
<hr>
<p><strong>总结：打印条码需要选择带碳带的热转印条码打印机，比如Zebra 888t条码打印机</strong></p>
<p>​           <strong>条码打印机若是安不上驱动，检查打印数据线和打印口是否损坏，一般来讲，线插好后驱动安装完成后，条码打印机就可以打印测试页了</strong></p>
<p>​           <strong>条码打印机要是打印的不清晰，请先更换碳带，再选择相应的纸张，要么就与条码编辑软件里的字体设置有关系，需要更改字体</strong></p>
<p>​          <strong>斑马打印机选择的条码编辑软件为ZebraDesigner  V2，经测试可以正常使用。</strong></p>
]]></content>
      <categories>
        <category>workNote</category>
      </categories>
      <tags>
        <tag>software</tag>
        <tag>print</tag>
        <tag>zebra</tag>
      </tags>
  </entry>
  <entry>
    <title>腾讯文档使用教程</title>
    <url>/2024/04/29/%E8%85%BE%E8%AE%AF%E6%96%87%E6%A1%A3%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p>
<p>leiyu-code.github.io</p>
<p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p>
<h1 id="腾讯文档使用教程"><a href="#腾讯文档使用教程" class="headerlink" title="腾讯文档使用教程"></a><strong>腾讯文档使用教程</strong></h1><h3 id="【图文教程】"><a href="#【图文教程】" class="headerlink" title="【图文教程】"></a><strong>【图文教程】</strong></h3><p>1、在线文档 (Word) 使用教程:</p>
<p><a href="https://docs.qq.com/doc/p/fc045c173c6cd5278d17893571b5ca1f2a907de1">https://docs.qq.com/doc/p/fc045c173c6cd5278d17893571b5ca1f2a907de1</a></p>
<p>2、在线表格 (Excel) 使用教程:</p>
<p><a href="https://docs.qq.com/doc/p/46053051e04c02507b9f889c3e7d5e7b342ab38e">https://docs.qq.com/doc/p/46053051e04c02507b9f889c3e7d5e7b342ab38e</a></p>
<p>3、在线幻灯片 (PPT) 使用教程：</p>
<p><a href="https://docs.qq.com/doc/p/7ec3015255751fe252077f1b1921124ec032142d">https://docs.qq.com/doc/p/7ec3015255751fe252077f1b1921124ec032142d</a></p>
<p>4、在线收集表使用教程:</p>
<p><a href="https://docs.qq.com/doc/p/9119455d5eadbb23a232efb4188feb7656fdd7e4">https://docs.qq.com/doc/p/9119455d5eadbb23a232efb4188feb7656fdd7e4</a></p>
<p>5、     智能表格使用教程:</p>
<p><a href="https://docs.qq.com/aio/DZmFVQ05WbUdOeXRI">https://docs.qq.com/aio/DZmFVQ05WbUdOeXRI</a></p>
<p>6、     智能文档使用教程：</p>
<p><a href="https://docs.qq.com/aio/DWXh1S2tCRnlhVEFL?p=18PtEOLdNUBVPBHaTmbfJT">https://docs.qq.com/aio/DWXh1S2tCRnlhVEFL</a></p>
<p>7、     思维导图（Mind）使用教程：</p>
<p><a href="https://docs.qq.com/doc/p/ba603297f82a62611bd7f25612655a048bd2f5c6?pub=1&dver=2.1.27141849">https://docs.qq.com/doc/p/ba603297f82a62611bd7f25612655a048bd2f5c6</a></p>
<p>8、     流程图（Flowchart）使用教程：</p>
<p><a href="https://docs.qq.com/doc/p/b0bad2bb71932d45900fa83105ce00bfe9dfc3a7">https://docs.qq.com/doc/p/b0bad2bb71932d45900fa83105ce00bfe9dfc3a7</a></p>
<h3 id="【视频教程】"><a href="#【视频教程】" class="headerlink" title="【视频教程】"></a><strong>【视频教程】</strong></h3><p>1、【视频教程】1分钟学会做项目规划</p>
<p><a href="https://v.qq.com/x/page/f30639oiqsl.html">https://v.qq.com/x/page/f30639oiqsl.html</a> </p>
<p>2、【视频教程】1分钟学会信息收集</p>
<p><a href="https://v.qq.com/x/page/i3063rsg6yq.html">https://v.qq.com/x/page/i3063rsg6yq.html</a></p>
<p>3、【视频教程】1分钟学会如何进行远程会议</p>
<p><a href="https://v.qq.com/x/page/n30637654dl.html">https://v.qq.com/x/page/n30637654dl.html</a> </p>
<p>4、【视频教程】1分钟学会如何追踪项目进度</p>
<p><a href="https://v.qq.com/x/page/c3063yywrdr.html">https://v.qq.com/x/page/c3063yywrdr.html</a> </p>
<p>5、【视频教程】1分钟学会做项目执行</p>
<p><a href="https://v.qq.com/x/page/v3063xxa8at.html">https://v.qq.com/x/page/v3063xxa8at.html</a> </p>
]]></content>
      <categories>
        <category>Tencent</category>
      </categories>
      <tags>
        <tag>software</tag>
        <tag>TencentDocs</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware Workstation重新安装报错的解决方法</title>
    <url>/2023/11/13/VMware%20Workstation%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85%E6%8A%A5%E9%94%99%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p>
<p>leiyu-code.github.io</p>
<p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p>
<p><strong>在重新安装VMware Workstation时会报错，错误的内容乱七八糟，了解了一下后，报错的原因如下：</strong></p>
<p><strong>1、软件安装临时目录里的反安装程序被删除，导致程序一直出现Vc++ runtime一直安装不了</strong></p>
<p><strong>2、卸载的时候软件目录里的文件未被清理干净</strong></p>
<p><strong>3、注册表文件未被清理干净</strong></p>
<p>解决方法：</p>
<p>1、卸载所有的C++运行库</p>
<p>2、重启后再重新安装运行库</p>
<p>3、重启后再重新安装运行库</p>
<p><em><strong>在安装过程中试了很多方法都不能成功地安装VM，最后使用了一款VM反安装工具后VM就能正常地安装了</strong></em></p>
<hr>
<p><strong>总结：软件安装不了最好先卸载所有的C++运行库，不行了再使用软件的专用清理工具清理下，就可以正常安装了</strong></p>
<span id="more"></span>



<p>VM清理工具在以下链接里，快去下来试试吧！</p>
]]></content>
      <categories>
        <category>Vm</category>
      </categories>
      <tags>
        <tag>vm</tag>
        <tag>software</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL语句学习手册实例</title>
    <url>/2023/07/10/SQL%E8%AF%AD%E5%8F%A5%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p>
<p>leiyu-code.github.io</p>
<p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p>
<h2 id="SQL语句学习手册实例"><a href="#SQL语句学习手册实例" class="headerlink" title="SQL语句学习手册实例"></a>SQL语句学习手册实例</h2><p><strong>How to use sql &amp; examples</strong></p>
<p><em><strong>point:表</strong></em></p>
<p>​          <em><strong>视图</strong></em></p>
<p>​         <em><strong>索引</strong></em></p>
<p>​        <em><strong>表达式</strong></em></p>
<p>​        <em><strong>函数</strong></em></p>
<p>​        <em><strong>权限控制</strong></em></p>
<span id="more"></span>



<h3 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h3><p>例 1 对于表的教学管理数据库中的表 STUDENTS ，可以定义如下：<br>   CREATE TABLE STUDENTS<br>   (SNO      NUMERIC (6, 0) NOT NULL<br>   SNAME    CHAR (8) NOT NULL<br>   AGE      NUMERIC(3,0)<br>   SEX      CHAR(2)<br>   BPLACE CHAR(20)<br>   PRIMARY KEY(SNO))<br>例 2 对于表的教学管理数据库中的表 ENROLLS ，可以定义如下：<br>        CREATE TABLE ENROLLS<br>        (SNO      NUMERIC(6,0) NOT NULL<br>        CNO     CHAR(4) NOT NULL<br>        GRADE   INT<br>        PRIMARY KEY(SNO,CNO)<br>        FOREIGN KEY(SNO) REFERENCES STUDENTS(SNO)<br>        FOREIGN KEY(CNO) REFERENCES COURSES(CNO)<br>        CHECK ((GRADE IS NULL) OR (GRADE BETWEEN 0 AND 100)))<br>例 3 根据表的 STUDENTS 表，建立一个只包含学号、姓名、年龄的女学生表。<br>        CREATE TABLE GIRL<br>        AS SELECT SNO, SNAME, AGE<br>        FROM STUDENTS<br>        WHERE SEX&#x3D;’ 女 ‘; </p>
<p>例 4 删除教师表 TEACHER 。<br>        DROP TABLE TEACHER<br>例 5 在教师表中增加住址列。<br>       ALTER TABLE TEACHERS<br>       ADD (ADDR CHAR(50))<br>例 6 把 STUDENTS 表中的 BPLACE 列删除，并且把引用 BPLACE 列的所有视图和约束也一起删除。<br>        ALTER TABLE STUDENTS<br>        DROP BPLACE CASCADE<br>例 7 补充定义 ENROLLS 表的主关键字。<br>       ALTER TABLE ENROLLS<br>       ADD PRIMARY KEY (SNO,CNO) ； </p>
<h3 id="视图操作（虚表）"><a href="#视图操作（虚表）" class="headerlink" title="视图操作（虚表）"></a>视图操作（虚表）</h3><p>例 9 建立一个只包括教师号、姓名和年龄的视图 FACULTY 。 ( 在视图定义中不能包含 ORDER BY 子句 )<br>        CREATE VIEW FACULTY<br>        AS SELECT TNO, TNAME, AGE<br>        FROM TEACHERS<br>例 10 从学生表、课程表和选课表中产生一个视图 GRADE_TABLE ， 它包括学生姓名、课程名和成绩。<br>        CREATE VIEW GRADE_TABLE<br>        AS SELECT SNAME,CNAME,GRADE<br>        FROM STUDENTS,COURSES,ENROLLS<br>        WHERE STUDENTS.SNO ＝ ENROLLS.SNO AND<br>        COURSES.CNO&#x3D;ENROLLS.CNO<br>例 11 删除视图 GRADE_TABLE<br>        DROP VIEW GRADE_TABLE RESTRICT </p>
<h3 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h3><p>例 12 在学生表中按学号建立索引。<br>        CREATE  UNIQUE  INDEX  ST<br>        ON STUDENTS (SNO,ASC)<br>例 13 删除按学号所建立的索引。<br>        DROP INDEX ST </p>
<h3 id="数据库模式操作"><a href="#数据库模式操作" class="headerlink" title="数据库模式操作"></a>数据库模式操作</h3><p>例 14 创建一个简易教学数据库的数据库模式  TEACHING_DB ，属主为 ZHANG 。<br>        CREATE SCHEMA TEACHING_DB  AUTHRIZATION  ZHANG<br>例 15 删除简易教学数据库模式 TEACHING_DB 。（（ 1 ）选用 CASCADE ，即当删除数据库模式时，则本数据库模式和其下属的基本表、视图、索引等全部被删除。（ 2 ）选用 RESTRICT ，即本数据库模式下属的基本表、视图、索引等事先已清除，才能删除本数据库模式，否则拒绝删除。）<br>        DROP SCHEMA TEACHING_DB CASCADE </p>
<h3 id="单表操作"><a href="#单表操作" class="headerlink" title="单表操作"></a>单表操作</h3><p>例 16 找出 3 个学分的课程号和课程名。<br>         SELECT CNO, CNAME<br>         FROM 　 COURSES<br>         WHERE 　 CREDIT ＝ 3<br>例 17 查询年龄大于 22 岁的学生情况。<br>         SELECT *<br>         FROM   STUDENTS<br>         WHERE AGE ＞ 22<br>例 18   找出籍贯为河北的男生的姓名和年龄。<br>         SELECT SNAME, AGE<br>         FROM 　 STUDENTS<br>         WHERE 　 BPLACE ＝ ‘ 河北 ‘  AND SEX ＝ ‘ 男 ‘<br>例 19 找出年龄在 20 ～ 23 岁之间的学生的学号、姓名和年龄，并按年龄升序排序。 (ASC （升序）或 DESC （降序）声明排序的方式，缺省为升序。 )<br>         SELECT SNO, SNAME, AGE<br>         FROM   STUDENTS<br>         WHERE AGE BETWEEN 20 AND 23<br>         ORDER BY  AGE<br>例 20 找出年龄小于 23 岁、籍贯是湖南或湖北的学生的姓名和性别。（条件比较运算符＝、＜ 和逻辑运算符 AND （与），此外还可以使用的运算符有：＞（大于）、＞＝（大于等于）、＜＝（小于等于）、＜＞（不等于）、 NOT （非）、 OR （或）等。<br>谓词 LIKE 只能与字符串联用，常常是 “ ＜列名＞  LIKE pattern” 的格式。特殊字符 “_” 和 “%” 作为通配符。<br>谓词 IN 表示指定的属性应与后面的集合（括号中的值集或某个查询子句的结果）中的某个值相匹配，实际上是一系列的 OR （或）的缩写。谓词 NOT IN 表示指定的属性不与后面的集合中的某个值相匹配。<br>谓词 BETWEEN 是 “ 包含于 … 之中 ” 的意思。）<br>        SELECT SNAME, SEX<br>        FROM   STUDENTS<br>        WHERE AGE ＜ 23 AND BPLACE LIKE’ 湖％ ‘<br>        或<br>        SELECT SNAME, SEX<br>        FROM   STUDENTS<br>        WHERE AGE ＜ 23 AND BPLACE IN （ ‘ 湖南 ‘ ， ‘ 湖北 ‘ ）<br>例 22 找出学生表中籍贯是空值的学生的姓名和性别。（在 SQL 中不能使用条件：＜列名＞＝ NULL 。在 SQL 中只有一个特殊的查询条件允许查询 NULL 值：）<br>       SELECT SNAME, SEX<br>       FROM   STUDENTS<br>       WHERE BPLACE IS NULL </p>
<h3 id="多表操作"><a href="#多表操作" class="headerlink" title="多表操作"></a>多表操作</h3><p>例 23 找出成绩为 95 分的学生的姓名。（子查询）<br>        SELECT SNAME<br>        FROM 　 STUDENTS<br>        WHERE 　 SNO ＝<br>              (SELECT SNO<br>               FROM   ENROLLS<br>               WHERE GRADE ＝ 95)<br>例 24 找出成绩在 90 分以上的学生的姓名。<br>       SELECT SNAME<br>        FROM   STUDENTS<br>        WHERE SNO IN<br>                (SELECT SNO<br>                FROM ENROLLS<br>                WHERE GRADE ＞ 90)<br>        或<br>        SELECT SNAME<br>        FROM   STUDENTS<br>        WHERE SNO ＝ ANY<br>                (SELECT SNO<br>                FROM ENROLLS<br>                WHERE GRADE ＞ 90)<br>例 25 查询全部学生的学生名和所学课程号及成绩。（连接查询）<br>        SELECT SNAME, CNO, GRADE<br>        FROM   STUDENTS, ENROLLS<br>        WHERE STUDENTS.SNO ＝ ENROLLS.SNO<br>例 26 找出籍贯为山西或河北，成绩为 90 分以上的学生的姓名、籍贯和成绩。（当构造多表连接查询命令时，必须遵循两条规则。第一，连接条件数正好比表数少 1 （若有三个表，就有两个连接条件 ) ；第二，若一个表中的主关键字是由多个列组成，则对此主关键字中的每一个列都要有一个连接条件（也有少数例外情况））<br>        SELECT SNAME, BPLACE, GRADE<br>        FROM   STUDENTS, ENROLLS<br>        WHERE BPLACE IN (‘ 山西 ’ ， ‘ 河北 ’) AND GRADE ＞＝ 90 AND 　 STUDENTS.SNO&#x3D;ENROLLS.SNO<br>例 28 查出课程成绩在 80 分以上的女学生的姓名、课程名和成绩。（ FROM 子句中的子查询）<br>        SELECT SNAME,CNAME, GRADE<br>        FROM   (SELECT SNAME, CNAME , GRADE<br>                        FROM STUDENTS, ENROLLS,COURSES<br>                        WHERE SEX ＝ ‘ 女 ‘)<br>        AS TEMP (SNAME, CNAME,GRADE)<br>        WHERE GRADE ＞ 80 </p>
<h3 id="表达式与函数的使用"><a href="#表达式与函数的使用" class="headerlink" title="表达式与函数的使用"></a>表达式与函数的使用</h3><p>例 29 查询各课程的学时数。（算术表达式由算术运算符＋、－、 * 、／与列名或数值常量所组成。）<br>        SELECT CNAME,COURSE_TIME ＝ CREDIT<em>16<br>        FROM   COURSES<br>例 30 找出教师的最小年龄。（内部函数： SQL 标准中只使用 COUNT 、 SUM 、 AVG 、 MAX 、 MIN 函数，称之为聚集函数（ Set Function ）。 COUNT 函数的结果是该列统计值的总数目， SUM 函数求该列统计值之和， AVG 函数求该列统计值之平均值， MAX 函数求该列最大值， MIN 函数求该列最小值。）<br>        SELECT MIN(AGE)<br>        FROM   TEACHERS<br>例 31 统计年龄小于等于 22 岁的学生人数。（统计）<br>        SELECT COUNT(</em>)<br>        FROM   STUDENTS<br>        WHERE AGE &lt; ＝ 22<br>例 32 找出学生的平均成绩和所学课程门数。<br>        SELECT SNO, AVG(GRADE), COURSES ＝ COUNT(*)<br>        FROM   ENROLLS<br>        GROUP BY SNO </p>
<p>例 34 找出年龄超过平均年龄的学生姓名。<br>SELECT SNAME<br>FROM STUDENTS<br>WHERE AGE ＞<br>      (SELECT AVG(AGE)<br>        FROM   STUDENTS) </p>
<p>例 35 找出各课程的平均成绩，按课程号分组，且只选择学生超过 3 人的课程的成绩。（ GROUP BY 与 HAVING<br>        GROUP BY 子句把一个表按某一指定列（或一些列）上的值相等的原则分组，然后再对每组数据进行规定的操作。<br>        GROUP BY 子句总是跟在 WHERE 子句后面，当 WHERE 子句缺省时，它跟在 FROM 子句后面。<br>        HAVING 子句常用于在计算出聚集之后对行的查询进行控制。）<br>         SELECT CNO, AVG(GRADE), STUDENTS ＝ COUNT(<em>)<br>         FROM ENROLLS<br>         GROUP BY CNO<br>         HAVING COUNT(</em>) &gt;&#x3D; 3 </p>
<h3 id="相关子查询"><a href="#相关子查询" class="headerlink" title="相关子查询"></a>相关子查询</h3><p>例 37 查询没有选任何课程的学生的学号和姓名。（当一个子查询涉及到一个来自外部查询的列时，称为相关子查询（ Correlated Subquery) 。相关子查询要用到存在测试谓词 EXISTS 和 NOT EXISTS ，以及 ALL 、 ANY （ SOME ）等。）<br>        SELECT SNO, SNAME<br>        FROM   STUDENTS<br>        WHERE NOT EXISTS<br>              (SELECT *<br>              FROM ENROLLS<br>              WHERE ENROLLS.SNO&#x3D;STUDENTS.SNO)<br>例 38   查询哪些课程只有男生选读。<br>        SELECT DISTINCT CNAME<br>        FROM   COURSES C<br>        WHERE ‘ 男 ‘ ＝ ALL<br>               (SELECT SEX<br>                FROM ENROLLS ， STUDENTS<br>                WHERE ENROLLS.SNO&#x3D;STUDENTS.SNO AND<br>                      ENROLLS.CNO&#x3D;C.CNO)<br>例 39 要求给出一张学生、籍贯列表，该表中的学生的籍贯省份，也是其他一些学生的籍贯省份。<br>        SELECT SNAME, BPLACE<br>        FROM   STUDENTS A<br>        WHERE EXISTS<br>               (SELECT *<br>                 FROM STUDENTS B<br>                 WHERE A.BPLACE&#x3D;B.BPLACE AND<br>                       A.SNO &lt; &gt; B.SNO) </p>
<p>例 40 找出选修了全部课程的学生的姓名。<br>        本查询可以改为：查询这样一些学生，没有一门课程是他不选修的。<br>        SELECT SNAME<br>        FROM   STUDENTS<br>        WHERE NOT EXISTS<br>               (SELECT *<br>                FROM COURSES<br>                WHERE NOT EXISTS<br>                        (SELECT *<br>                         FROM ENROLLS<br>                         WHERE ENROLLS.SNO ＝ STUDENTS.SNO<br>                             AND ENROLLS.CNO ＝ COURSES.CNO)) </p>
<h3 id="关系代数运算"><a href="#关系代数运算" class="headerlink" title="关系代数运算"></a>关系代数运算</h3><p>例 41 设有某商场工作人员的两张表：营业员表 SP_SUBORD 和营销经理表 SP_MGR ，其关系数据模式如下：<br>        SP_SUBORD (SALPERS_ID, SALPERS_NAME, MANAGER_ID, OFFICE)<br>        SP_MGR (SALPERS_ID, SALPERS_NAME, MANAGER_ID, OFFICE)<br>        其中，属性 SALPERS_ID 为工作人员的编号 , SALPERS_NAME 为工作人员的姓名 , MANAGER_ID 为所在部门经理的编号 , OFFICE 为工作地点。<br>若查询全部商场工作人员，可以用下面的 SQL 语句：<br>        (SELECT * FROM SP_SUBORD)<br>        UNION<br>        (SELECT * FROM SP_MGR)<br>        或等价地用下面的 SQL 语句：<br>        SELECT *<br>        FROM (TABLE SP_SUBORD UNION TABLE SP_MGR)<br>（ 2 ） INTERSECT<br>         (SELECT * FROM SP_SUBORD)<br>         INTERSECT<br>         (SELECT * FROM SP_MGR)<br>        或等价地用下面的 SQL 语句：<br>        SELECT *<br>        FROM (TABLE SP_SUBORD INTERSECT TABLE SP_MGR)<br>        或用带 ALL 的 SQL 语句：<br>        (SELECT * FROM SP_SUBORD)<br>       INTERSECT ALL<br>        (SELECT * FROM SP_MGR)<br>        或<br>        SELECT *<br>        FROM (TABLE SP_SUBORD INTERSECT ALL TABLE SP_MGR)<br>（ 3 ） EXCEPT<br>        (SELECT * FROM SP_MGR)<br>        EXCEPT<br>        (SELECT * FROM SP_SUBORD)<br>        或等价地用下面的 SQL 语句：<br>        SELECT *<br>        FROM (TABLE SP_MGR EXCEPT TABLE SP_ SUBORD)<br>        或用带 ALL 的 SQL 语句：<br>        (SELECT * FROM SP_MGR)<br>        EXCEPT ALL<br>        (SELECT * FROM SP_SUBORD)<br>例 42 查询籍贯为四川、课程成绩在 80 分以上的学生信息及其成绩。（自然连接）<br>        (SELECT * FROM STUDENTS<br>         WHERE BPLACE&#x3D;‘ 四川 ’)<br>        NATURAL JOIN<br>        (SELECT * FROM ENROLLS<br>         WHERE GRADE &gt;&#x3D;80)<br>例3.43          列出全部教师的姓名及其任课的课程号、班级。<br>（外连接与外部并外连接允许在结果表中保留非匹配元组，空缺部分填以 NULL 。外连接的作用是在做连接操作时避免丢失信息。<br>        外连接有 3 类：<br>（ 1 ）左外连接（ Left Outer Join ）。连接运算谓词为 LEFT [OUTER] JOIN ，其结果表中保留左关系的所有元组。<br>（ 2 ）右外连接（ Right Outer Join ）。连接运算谓词为 RIGHT [OUTER] JOIN ，其结果表中保留右关系的所有元组。<br>（ 3 ）全外连接（ Full Outer Join ）。连接运算谓词为 FULL [OUTER] JOIN ，其结果表中保留左右两关系的所有元组。）<br>          SELECT TNAME, CNO, CLASS<br>          FROM TEACHERS LEFT OUTER JOIN TEACHING USING (TNO) </p>
<h3 id="SQL-的数据操作"><a href="#SQL-的数据操作" class="headerlink" title="SQL 的数据操作"></a>SQL 的数据操作</h3><p>例 44 把教师李映雪的记录加入到教师表 TEACHERS 中。（插入）<br>        INSERT INTO TEACHERS<br>        VALUES(1476 ， ‘ 李映雪 ‘ ， 44 ， ‘ 副教授 ‘)<br>例 45 成绩优秀的学生将留下当教师。<br>        INSERT INTO TEACHERS (TNO ， TNAME)<br>        SELECT DISTINCT SNO ， SNAME<br>        FROM   STUDENTS ， ENROLLS<br>        WHERE STUDENTS.SNO ＝ ENROLLS.SNO AND GRADE ＞＝ 90<br>例 47 把所有学生的年龄增加一岁。（修改）<br>        UPDATE STUDENTS<br>        SET AGE ＝ AGE+1<br>例 48 学生张春明在数据库课考试中作弊，该课成绩应作零分计。<br>        UPDATE ENROLLS<br>        SET GRADE ＝ 0<br>        WHERE CNO ＝ ‘C1’ AND<br>             ‘ 张春明 ‘ ＝<br>             (SELECT SNAME<br>             FROM STUDENTS<br>             WHERE STUDENTS.SNO&#x3D;ENROLLS.SNO)<br>例 49 从教师表中删除年龄已到 60 岁的退休教师的数据。（删除）<br>        DELETE FROM TEACHERS<br>        WHERE AGE ＞＝ 60 </p>
<h3 id="SQL-的数据权限控制"><a href="#SQL-的数据权限控制" class="headerlink" title="SQL 的数据权限控制"></a>SQL 的数据权限控制</h3><p>例 50 授予 LILI 有对表 STUDENTS 的查询权。（表／视图特权的授予<br>        一个 SQL 特权允许一个被授权者在给定的数据库对象上进行特定的操作。授权操作的数据库对象包括：表 &#x2F; 视图、列、域等。授权的操作包括： INSERT 、 UPDATE 、 DELETE 、 SELECT 、 REFERENCES 、 TRIGGER 、 UNDER 、 USAGE 、 EXECUTE 等。其中 INSERT 、 UPDATE 、 DELETE 、 SELECT 、 REFERENCES 、 TRIGGER 有对表做相应操作的权限，故称为表特权。）<br>        GRANT SELECT ON STUDENTS<br>        TO LILI<br>        WITH GRANT OPTION<br>例 51 取消 LILI 的存取 STUDENTS 表的特权。<br>        REVOKE ALL<br>        ON STUDENTS<br>        FROM LILI CASCADE </p>
<p>不断补充中：</p>
<ol>
<li>模糊查找:<br>它判断列值是否与指定的字符串格式相匹配。可用于char、varchar、text、ntext、datetime和smalldatetime等类型查询。<br>　　可使用以下通配字符：<br>　　百分号%：可匹配任意类型和长度的字符，如果是中文，请使用两个百分号即%%。<br>　　下划线_：匹配单个任意字符，它常用来限制表达式的字符长度。<br>　　方括号[]：指定一个字符、字符串或范围，要求所匹配对象为它们中的任一个。[^]：其取值也[] 相同，但它要求所匹配对象为指定字符以外的任一个字符。<br>　　 例如：<br>　　限制以Publishing结尾，使用LIKE ‘%Publishing’<br>　　限制以A开头：LIKE ‘[A]%’<br>　　限制以A开头外：LIKE ‘[^A]%’</li>
</ol>
<p>2.更改表格　<br>         ALTER TABLE table_name<br>        ADD COLUMN column_name DATATYPE<br>        说明：增加一个栏位（没有删除某个栏位的语法。)<br>        ALTER TABLE table_name<br>        ADD PRIMARY KEY (column_name)<br>        说明：更改表得的定义把某个栏位设为主键。<br>        ALTER TABLE table_name<br>        DROP PRIMARY KEY (column_name)<br>        说明：把主键的定义删除。<br>3.group by<br>在select 语句中可以使用group by 子句将行划分成较小的组，然后，使用聚组函数返回每一个组的汇总信息，另外，可以使用having子句限制返回的结果集。group by 子句可以将查询结果分组，并返回行的汇总信息Oracle 按照group by 子句中指定的表达式的值分组查询结果。<br>在带有group by 子句的查询语句中，在select 列表中指定的列要么是group by 子句中指定的列，要么包含聚组函数<br>select max(sal),job emp group by job;<br>(注意max(sal),job的job并非一定要出现，但有意义)<br>查询语句的select 和group by ,having 子句是聚组函数唯一出现的地方，在where 子句中不能使用聚组函数。<br>select deptno,sum(sal) from emp where sal&gt;1200 group by deptno having sum(sal)&gt;8500 order by deptno;<br>当在gropu by 子句中使用having 子句时，查询结果中只返回满足having条件的组。在一个sql语句中可以有where子句和having子句。having 与where 子句类似，均用于设置限定条件</p>
<p>where 子句的作用是在对查询结果进行分组前，将不符合where条件的行去掉，即在分组之前过滤数据，条件中不能包含聚组函数，使用where条件显示特定的行。<br>having 子句的作用是筛选满足条件的组，即在分组之后过滤数据，条件中经常包含聚组函数，使用having 条件显示特定的组，也可以使用多个分组标准进行分组。<br>查询每个部门的每种职位的雇员数<br>select deptno,job,count(*) from emp group by deptno,job;<br>4.外连接与内连接<br>有时候，即使在连接的表中没有相应的行，用户可能想从一张表中看数据，Oracle提供了外连接实现该功能。<br>内连接是指连接查询只显示完全满足连接条件的记录，即等值连接，外连接的查询结果是内连接查询结果的扩展。外连接不仅返回满足连接条件的所有记录而且也返回了一个表中那些在另一个表中没有匹配行的记录。外连接的操作符是“+”。“+”号放在连接条件中信息不完全的那一边（即没有相应行的那一边）。运算符“+”影响NULL行的建立。建一行或多行NULL来匹配连接的表中信息完全的行。<br>外连接运算符“+”只能出现在where子句中表达式的一边。<br>假如在多张表之间有多个连接条件，外连接运算符不能使用or,in逻辑运算符与其它条件组合。</p>
<p>假如emp表中deptno&#x3D;10的ename为空值，dept表中deptno&#x3D;20的loc为空值：<br>1.<br>select<br>ename,dept.deptno,loc<br>from<br>emp,dept<br>where<br>emp.depno(+)&#x3D;dept.deptno;<br>如果在dept.deptno中有的数值在emp.deptno中没有值，则在做外连接时，<br>结果中ename会产生一个空值。(emp.deptno&#x3D;10)<br>2.<br>select<br>ename,dept.deptno,loc<br>from<br>emp,dept<br>where<br>emp.depno&#x3D;dept.deptno(+);<br>如果在emp.deptno中有的数值在dept.deptno中没有值，则在做外连接时，<br>结果中loc会产生一个空值。。(dept.deptno&#x3D;20)</p>
<p>5.自连接<br>自连接是指同一张表的不同行间的连接。该连接不受其他表的影响。用自连接可以比较同一张表中不同行的某一列的值。因为自连接查询仅涉及到某一张表与其自身的连接。所以在from子句中该表名出现两次，分别用两个不同的别名表示，两个别名当作两张不同的表进行处理，与其它的表连接一样，别名之间也使用一个或多个相关的列连接。为了区分同一张表的不同行的列，在名前永别名加以限制。<br>select<br>worker.ename,<br>manager.ename manager<br>from<br>emp worker,<br>emp manager<br>where<br>work.mgr&#x3D;manager.empno;<br>6.集合运算<br>基合运算符可以用于从多张表中选择数据。<br>①UNION运算<br>用于求两个结果集合的并集（两个结果集合的所有记录），并自动去掉重复行。<br>select ename,sal from account where sal&gt;2000<br>union<br>select ename,sal from research where sal&gt;2000<br>union<br>select ename,sal from sales where sal&gt;2000;<br>注：ename,sal 是必须一致的。 </p>
<p>②UNION ALL运算<br>用于求两个结果集合的并集（两个结果集中的所有记录），并且不去掉重复行。<br>select ename,sal from account where sal&gt;2000<br>union<br>select ename,sal from research where sal&gt;2000<br>union<br>select ename,sal from sales where sal&gt;2000;<br>③INTERSECT运算<br>intersect运算返回查询结果中相同的部分。</p>
<p>各部门中有哪些相同的职位？<br>select Job from account<br>intersect<br>select Job from research<br>intersect<br>select Job from sales;</p>
<p>④MINUS运算<br>minus返回两个结果集的差集。（在第一个结果集中存在的，而在第二个结果集中不存在的行。）<br>有那些职位是财务部中有，而在销售部门中没有？<br>select Job from account<br>minus<br>select Job from sales;</p>
]]></content>
      <categories>
        <category>Datebase</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL语句大全</title>
    <url>/2023/07/10/SQL%E8%AF%AD%E5%8F%A5%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p>
<p>leiyu-code.github.io</p>
<p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p>
<h1 id="SQL语句大全"><a href="#SQL语句大全" class="headerlink" title="SQL语句大全"></a>SQL语句大全</h1><h3 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h3><p>1、说明：创建数据库 CREATE DATABASE database-name </p>
<p>2、说明：删除数据库 drop database dbname </p>
<p>3、说明：备份sql server — 创建 备份数据的 device USE master EXEC sp_addumpdevice ‘disk’, ‘testBack’, ‘c:\mssql7backup\MyNwind_1.dat’ — 开始 备份 BACKUP DATABASE pubs TO testBack </p>
<p>4、说明：创建新表 create table tabname(col1 type1 [not null] [primary key],col2 type2 [not null],..)</p>
<p>根据已有的表创建新表： A：create table tab_new like tab_old (使用旧表创建新表) B：create table tab_new as select col1,col2… from tab_old definition only </p>
<p>5、说明：删除新表 drop table tabname </p>
<p>6、说明：增加一个列 Alter table tabname add column col type 注：列增加后将不能删除。DB2中列加上后数据类型也不能改变，唯一能改变的是增加varchar类型的长度。 </p>
<p>7、说明：添加主键： Alter table tabname add primary key(col) 说明：删除主键： Alter table tabname drop primary key(col) </p>
<p>8、说明：创建索引：create [unique] index idxname on tabname(col….) 删除索引：drop index idxname 注：索引是不可更改的，想更改必须删除重新建。 </p>
<p>9、说明：创建视图：create view viewname as select statement 删除视图：drop view viewname </p>
<span id="more"></span>

<p>10、说明：几个简单的基本的sql语句 </p>
<p>选择：select * from table1 where 范围 </p>
<p>插入：insert into table1(field1,field2) values(value1,value2) </p>
<p>删除：delete from table1 where </p>
<p>范围 更新：update table1 set field1&#x3D;value1 where </p>
<p>范围 查找：select * from table1 where field1 like ’%value1%’ —like的语法很精妙，查资料! </p>
<p>排序：select * from table1 order by field1,field2 [desc] </p>
<p>总数：select count as totalcount from table1 </p>
<p>求和：select sum(field1) as sumvalue from table1 </p>
<p>平均：select avg(field1) as avgvalue from table1 </p>
<p>最大：select max(field1) as maxvalue from table1 </p>
<p>最小：select min(field1) as minvalue from table1 </p>
<p>11、说明：几个高级查询运算词 </p>
<p>A： UNION 运算符 UNION 运算符通过组合其他两个结果表（例如 TABLE1 和 TABLE2）并消去表中任何重复行而派生出一个结果表。当 ALL 随 UNION 一起使用时（即 UNION ALL），不消除重复行。两种情况下，派生表的每一行不是来自 TABLE1 就是来自 TABLE2。 </p>
<p>B： EXCEPT 运算符 EXCEPT 运算符通过包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行而派生出一个结果表。当 ALL 随 EXCEPT 一起使用时 (EXCEPT ALL)，不消除重复行。 </p>
<p>C： INTERSECT 运算符 INTERSECT 运算符通过只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果表。当 ALL 随 INTERSECT 一起使用时 (INTERSECT ALL)，不消除重复行。 注：使用运算词的几个查询结果行必须是一致的。 </p>
<p>12、说明：使用外连接 </p>
<p>A、left （outer） join： 左外连接（左连接）：结果集几包括连接表的匹配行，也包括左连接表的所有行。 SQL: select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a &#x3D; b.c </p>
<p>B：right （outer） join: 右外连接(右连接)：结果集既包括连接表的匹配连接行，也包括右连接表的所有行。 </p>
<p>C：full&#x2F;cross （outer） join： 全外连接：不仅包括符号连接表的匹配行，还包括两个连接表中的所有记录。 </p>
<p>12、分组:Group by: 一张表，一旦分组 完成后，查询后只能得到组相关的信息。 </p>
<p>组相关的信息：（统计信息） count,sum,max,min,avg  分组的标准) 在SQLServer中分组时：不能以text,ntext,image类型的字段作为分组依据 在selecte统计函数中的字段，不能和普通的字段放在一起；</p>
<p>13、对数据库进行操作： </p>
<p>分离数据库： sp_detach_db; </p>
<p>附加数据库：sp_attach_db 后接表明，附加需要完整的路径名 </p>
<p>14.如何修改数据库的名称: sp_renamedb ‘old_name’, ‘new_name’</p>
<hr>
<h3 id="二、提升"><a href="#二、提升" class="headerlink" title="二、提升"></a>二、提升</h3><p>1、说明：复制表(只复制结构,源表名：a 新表名：b) (Access可用) 法一：select * into b from a where 1&lt;&gt;1（仅用于SQlServer） 法二：select top 0 * into b from a 2、说明：拷贝表(拷贝数据,源表名：a 目标表名：b) (Access可用) insert into b(a, b, c) select d,e,f from b;</p>
<p>3、说明：跨数据库之间表的拷贝(具体数据使用绝对路径) (Access可用) insert into b(a, b, c) select d,e,f from b in ‘具体数据库’ where 条件 例子：..from b in ‘“&amp;Server.MapPath(“.”)&amp;”\data.mdb” &amp;”‘ where..</p>
<p>4、说明：子查询(表名1：a 表名2：b) select a,b,c from a where a IN (select d from b ) 或者: select a,b,c from a where a IN (1,2,3)</p>
<p>5、说明：显示文章、提交人和最后回复时间 select a.title,a.username,b.adddate from table a,(select max(adddate) adddate from table where table.title&#x3D;a.title) b</p>
<p>6、说明：外连接查询(表名1：a 表名2：b) select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a &#x3D; b.c</p>
<p>7、说明：在线视图查询(表名1：a ) select * from (SELECT a,b,c FROM a) T where t.a &gt; 1;</p>
<p>8、说明：between的用法,between限制查询数据范围时包括了边界值,not between不包括 select * from table1 where time between time1 and time2 select a,b,c, from table1 where a not between 数值1 and 数值2</p>
<p>9、说明：in 的使用方法 select * from table1 where a [not] in (‘值1’,’值2’,’值4’,’值6’)</p>
<p>10、说明：两张关联表，删除主表中已经在副表中没有的信息 delete from table1 where not exists ( select * from table2 where table1.field1&#x3D;table2.field1 )</p>
<p>11、说明：四表联查问题： select * from a left inner join b on a.a&#x3D;b.b right inner join c on a.a&#x3D;c.c inner join d on a.a&#x3D;d.d where …..</p>
<p>12、说明：日程安排提前五分钟提醒 SQL: select * from 日程安排 where datediff(‘minute’,f开始时间,getdate())&gt;5</p>
<p>13、说明：一条sql 语句搞定数据库分页 select top 10 b.* from (select top 20 主键字段,排序字段 from 表名 order by 排序字段 desc) a,表名 b where b.主键字段 &#x3D; a.主键字段 order by a.排序字段 具体实现： 关于数据库分页：</p>
<p>declare @start int,@end int</p>
<p>@sql nvarchar(600)</p>
<p>set @sql&#x3D;’select top’+str(@end-@start+1)+’+from T where rid not in(select top’+str(@str-1)+’Rid from T where Rid&gt;-1)’</p>
<p>exec sp_executesql @sql</p>
<p>注意：在top后不能直接跟一个变量，所以在实际应用中只有这样的进行特殊的处理。Rid为一个标识列，如果top后还有具体的字段，这样做是非常有好处的。因为这样可以避免 top的字段如果是逻辑索引的，查询的结果后实际表中的不一致（逻辑索引中的数据有可能和数据表中的不一致，而查询时如果处在索引则首先查询索引）</p>
<p>14、说明：前10条记录 select top 10 * form table1 where 范围</p>
<p>15、说明：选择在每一组b值相同的数据中对应的a最大的记录的所有信息(类似这样的用法可以用于论坛每月排行榜,每月热销产品分析,按科目成绩排名,等等.) select a,b,c from tablename ta where a&#x3D;(select max(a) from tablename tb where tb.b&#x3D;ta.b)</p>
<p>16、说明：包括所有在 TableA 中但不在 TableB和TableC 中的行并消除所有重复行而派生出一个结果表 (select a from tableA ) except (select a from tableB) except (select a from tableC)</p>
<p>17、说明：随机取出10条数据 select top 10 * from tablename order by newid()</p>
<p>18、说明：随机选择记录 select newid()</p>
<p>19、说明：删除重复记录 </p>
<p>1),delete from tablename where id not in (select max(id) from tablename group by col1,col2,…) </p>
<p>2),select distinct * into temp from tablename delete from tablename insert into tablename select * from temp 评价： 这种操作牵连大量的数据的移动，这种做法不适合大容量但数据操作 </p>
<p>3),例如：在一个外部表中导入数据，由于某些原因第一次只导入了一部分，但很难判断具体位置，这样只有在下一次全部导入，这样也就产生好多重复的字段，怎样删除重复字段</p>
<p>alter table tablename –添加一个自增列 add column_b int identity(1,1) delete from tablename where column_b not in( select max(column_b) from tablename group by column1,column2,…) alter table tablename drop column column_b</p>
<p>20、说明：列出数据库里所有的表名 select name from sysobjects where type&#x3D;’U’ &#x2F;&#x2F; U代表用户</p>
<p>21、说明：列出表里的所有的列名 select name from syscolumns where id&#x3D;object_id(‘TableName’)</p>
<p>22、说明：列示type、vender、pcs字段，以type字段排列，case可以方便地实现多重选择，类似select 中的case。 select type,sum(case vender when ‘A’ then pcs else 0 end),sum(case vender when ‘C’ then pcs else 0 end),sum(case vender when ‘B’ then pcs else 0 end) FROM tablename group by type 显示结果： type vender pcs 电脑 A 1 电脑 A 1 光盘 B 2 光盘 A 2 手机 B 3 手机 C 3</p>
<p>23、说明：初始化表table1</p>
<p>TRUNCATE TABLE table1</p>
<p>24、说明：选择从10到15的记录 select top 5 * from (select top 15 * from table order by id asc) table_别名 order by id desc</p>
<hr>
<h3 id="三、技巧"><a href="#三、技巧" class="headerlink" title="三、技巧"></a>三、技巧</h3><p>1、1&#x3D;1，1&#x3D;2的使用，在SQL语句组合时用的较多</p>
<p>“where 1&#x3D;1” 是表示选择全部    “where 1&#x3D;2”全部不选， 如： if @strWhere !&#x3D;’’ begin set @strSQL &#x3D; ‘select count(<em>) as Total from [‘ + @tblName + ‘] where ‘ + @strWhere end else begin set @strSQL &#x3D; ‘select count(</em>) as Total from [‘ + @tblName + ‘]’ end</p>
<p>我们可以直接写成</p>
<p>错误！未找到目录项。 set @strSQL &#x3D; ‘select count(*) as Total from [‘ + @tblName + ‘] where 1&#x3D;1 安定 ‘+ @strWhere 2、收缩数据库 –重建索引 DBCC REINDEX DBCC INDEXDEFRAG –收缩数据和日志 DBCC SHRINKDB DBCC SHRINKFILE</p>
<p>3、压缩数据库 dbcc shrinkdatabase(dbname)</p>
<p>4、转移数据库给新用户以已存在用户权限 exec sp_change_users_login ‘update_one’,’newname’,’oldname’ go</p>
<p>5、检查备份集 RESTORE VERIFYONLY from disk&#x3D;’E:\dvbbs.bak’</p>
<p>6、修复数据库 ALTER DATABASE [dvbbs] SET SINGLE_USER GO DBCC CHECKDB(‘dvbbs’,repair_allow_data_loss) WITH TABLOCK GO ALTER DATABASE [dvbbs] SET MULTI_USER GO</p>
<p>7、日志清除 SET NOCOUNT ON DECLARE @LogicalFileName sysname, @MaxMinutes INT, @NewSize INT</p>
<p>USE tablename – 要操作的数据库名 SELECT  @LogicalFileName &#x3D; ‘tablename_log’, – 日志文件名 @MaxMinutes &#x3D; 10, – Limit on time allowed to wrap log. @NewSize &#x3D; 1  – 你想设定的日志文件的大小(M)</p>
<p>Setup &#x2F; initialize DECLARE @OriginalSize int SELECT @OriginalSize &#x3D; size FROM sysfiles WHERE name &#x3D; @LogicalFileName SELECT ‘Original Size of ‘ + db_name() + ‘ LOG is ‘ + CONVERT(VARCHAR(30),@OriginalSize) + ‘ 8K pages or ‘ + CONVERT(VARCHAR(30),(@OriginalSize*8&#x2F;1024)) + ‘MB’ FROM sysfiles WHERE name &#x3D; @LogicalFileName CREATE TABLE DummyTrans (DummyColumn char (8000) not null)</p>
<p>DECLARE @Counter    INT, @StartTime DATETIME, @TruncLog   VARCHAR(255) SELECT @StartTime &#x3D; GETDATE(), @TruncLog &#x3D; ‘BACKUP LOG ‘ + db_name() + ‘ WITH TRUNCATE_ONLY’</p>
<p>DBCC SHRINKFILE (@LogicalFileName, @NewSize) EXEC (@TruncLog) – Wrap the log if necessary. WHILE @MaxMinutes &gt; DATEDIFF (mi, @StartTime, GETDATE()) – time has not expired AND @OriginalSize &#x3D; (SELECT size FROM sysfiles WHERE name &#x3D; @LogicalFileName)</p>
<p>AND (@OriginalSize * 8 &#x2F;1024) &gt; @NewSize</p>
<p>BEGIN – Outer loop. SELECT @Counter &#x3D; 0 WHILE   ((@Counter &lt; @OriginalSize &#x2F; 16) AND (@Counter &lt; 50000)) BEGIN – update INSERT DummyTrans VALUES (‘Fill Log’) DELETE DummyTrans SELECT @Counter &#x3D; @Counter + 1 END EXEC (@TruncLog)</p>
<p>END SELECT ‘Final Size of ‘ + db_name() + ‘ LOG is ‘ + CONVERT(VARCHAR(30),size) + ‘ 8K pages or ‘ + CONVERT(VARCHAR(30),(size*8&#x2F;1024)) + ‘MB’ FROM sysfiles WHERE name &#x3D; @LogicalFileName DROP TABLE DummyTrans SET NOCOUNT OFF</p>
<p>8、说明：更改某个表 exec sp_changeobjectowner ‘tablename’,’dbo’</p>
<p>9、存储更改全部表</p>
<p>CREATE PROCEDURE dbo.User_ChangeObjectOwnerBatch @OldOwner as NVARCHAR(128), @NewOwner as NVARCHAR(128) AS</p>
<p>DECLARE @Name    as NVARCHAR(128) DECLARE @Owner   as NVARCHAR(128) DECLARE @OwnerName   as NVARCHAR(128)</p>
<p>DECLARE curObject CURSOR FOR select ‘Name’    &#x3D; name, ‘Owner’    &#x3D; user_name(uid) from sysobjects where user_name(uid)&#x3D;@OldOwner order by name</p>
<p>OPEN   curObject FETCH NEXT FROM curObject INTO @Name, @Owner WHILE(@@FETCH_STATUS&#x3D;0) BEGIN</p>
<p>if @Owner&#x3D;@OldOwner begin set @OwnerName &#x3D; @OldOwner + ‘.’ + rtrim(@Name) exec sp_changeobjectowner @OwnerName, @NewOwner end – select @name,@NewOwner,@OldOwner</p>
<p>FETCH NEXT FROM curObject INTO @Name, @Owner END</p>
<p>close curObject deallocate curObject GO</p>
<p>10、SQL SERVER中直接循环写入数据 declare @i int set @i&#x3D;1 while @i&lt;30 begin insert into test (userid) values(@i) set @i&#x3D;@i+1 end</p>
<p> 案例： 有如下表，要求表中所有没有及格的成绩，在每次增长0.1的基础上，使他们刚好及格：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Name     score</span><br><span class="line"></span><br><span class="line">Zhangshan   80</span><br><span class="line"></span><br><span class="line">Lishi       59</span><br><span class="line"></span><br><span class="line">Wangwu      50</span><br><span class="line"></span><br><span class="line">Songquan    69</span><br></pre></td></tr></table></figure>

<p>while((select min(score) from tb_table)&lt;60)</p>
<p>begin</p>
<p>update tb_table set score &#x3D;score*1.01</p>
<p>where score&lt;60</p>
<p>if (select min(score) from tb_table)&gt;60</p>
<p>break</p>
<p>else</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">continue</span><br></pre></td></tr></table></figure>

<p>end</p>
<hr>
<h3 id="数据开发-经典"><a href="#数据开发-经典" class="headerlink" title="数据开发-经典"></a>数据开发-经典</h3><p>1.按姓氏笔画排序: Select * From TableName Order By CustomerName Collate Chinese_PRC_Stroke_ci_as &#x2F;&#x2F;从少到多</p>
<p>2.数据库加密: select encrypt(‘原始密码’) select pwdencrypt(‘原始密码’) select pwdcompare(‘原始密码’,’加密后密码’) &#x3D; 1–相同；否则不相同 encrypt(‘原始密码’) select pwdencrypt(‘原始密码’) select pwdcompare(‘原始密码’,’加密后密码’) &#x3D; 1–相同；否则不相同</p>
<p>3.取回表中字段: declare @list varchar(1000), @sql nvarchar(1000) select @list&#x3D;@list+’,’+<a href="http://b.name/">b.name</a> from sysobjects a,syscolumns b where <a href="http://a.id%[3Db.id/](http://3Db.id/)"><a href="http://a.id=b.id/">a.id&#x3D;b.id</a></a> and a.name&#x3D;’表A’ set @sql&#x3D;’select ‘+right(@list,len(@list)-1)+’ from 表A’ exec (@sql)</p>
<p>4.查看硬盘分区: EXEC master..xp_fixeddrives</p>
<p>5.比较A,B表是否相等: if (select checksum_agg(binary_checksum(*)) from A)</p>
<p>(select checksum_agg(binary_checksum(*)) from B) print ‘相等’ else print ‘不相等’</p>
<p>6.杀掉所有的事件探察器进程: DECLARE hcforeach CURSOR GLOBAL FOR SELECT ‘kill ‘+RTRIM(spid) FROM master.dbo.sysprocesses WHERE program_name IN(‘SQL profiler’,N’SQL 事件探查器’) EXEC sp_msforeach_worker ‘?’</p>
<p>7.记录搜索: 开头到N条记录 Select Top N * From 表</p>
<p>N到M条记录(要有主索引ID) Select Top M-N * From 表 Where ID in (Select Top M ID From 表) Order by ID Desc</p>
<p>N到结尾记录 Select Top N * From 表 Order by ID Desc</p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>例如1：一张表有一万多条记录，表的第一个字段 RecID 是自增长字段， 写一个SQL语句， 找出表的第31到第40个记录。</p>
<p>select top 10 recid from A where recid not in(select top 30 recid from A)</p>
<p>分析：如果这样写会产生某些问题，如果recid在表中存在逻辑索引。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select top 10 recid from A where……是从索引中查找，而后面的select top 30 recid from A则在数据表中查找，这样由于索引中的顺序有可能和数据表中的不一致，这样就导致查询到的不是本来的欲得到的数据。</span><br></pre></td></tr></table></figure>

<p>解决方案</p>
<p>1， 用order by select top 30 recid from A order by ricid 如果该字段不是自增长，就会出现问题</p>
<p>2， 在那个子查询中也加条件：select top 30 recid from A where recid&gt;-1</p>
<p>例2：查询表中的最后以条记录，并不知道这个表共有多少数据,以及表结构。 set @s &#x3D; ‘select top 1 * from T   where pid not in (select top ‘ + str(@count-1) + ‘ pid from  T)’</p>
<p>print @s      exec sp_executesql @s</p>
<p>9：获取当前数据库中的所有用户表 select Name from sysobjects where xtype&#x3D;’u’ and status&gt;&#x3D;0</p>
<p>10：获取某一个表的所有字段 select name from syscolumns where id&#x3D;object_id(‘表名’)</p>
<p>select name from syscolumns where id in (select id from sysobjects where type &#x3D; ‘u’ and name &#x3D; ‘表名’)</p>
<p>两种方式的效果相同</p>
<p>11：查看与某一个表相关的视图、存储过程、函数 select a.* from sysobjects a, syscomments b where <a href="http://a.id/">a.id</a> &#x3D; <a href="http://b.id/">b.id</a> and b.text like ‘%表名%’</p>
<p>12：查看当前数据库中所有存储过程 select name as 存储过程名称 from sysobjects where xtype&#x3D;’P’</p>
<p>13：查询用户创建的所有数据库 select * from master..sysdatabases D where sid not in(select sid from master..syslogins where name&#x3D;’sa’) 或者 select dbid, name AS DB_NAME from master..sysdatabases where sid &lt;&gt; 0x01</p>
<p>14：查询某一个表的字段和数据类型 select column_name,data_type from information_schema.columns where table_name &#x3D; ‘表名’</p>
<p>15：不同服务器数据库之间的数据操作</p>
<ul>
<li>-创建链接服务器</li>
</ul>
<p>exec sp_addlinkedserver   ‘ITSV ‘, ‘ ‘, ‘SQLOLEDB ‘, ‘远程服务器名或ip地址 ‘</p>
<p>exec sp_addlinkedsrvlogin ‘ITSV ‘, ‘false ‘,null, ‘用户名 ‘, ‘密码 ‘</p>
<ul>
<li>-查询示例</li>
</ul>
<p>select * from ITSV.数据库名.dbo.表名</p>
<ul>
<li>-导入示例</li>
</ul>
<p>select * into 表 from ITSV.数据库名.dbo.表名</p>
<ul>
<li>-以后不再使用时删除链接服务器</li>
</ul>
<p>exec sp_dropserver ‘ITSV ‘, ‘droplogins ‘</p>
<ul>
<li>-连接远程&#x2F;局域网数据(openrowset&#x2F;openquery&#x2F;opendatasource)</li>
<li>-1、openrowset</li>
<li>-查询示例</li>
</ul>
<p>select * from openrowset( ‘SQLOLEDB ‘, ‘sql服务器名 ‘; ‘用户名 ‘; ‘密码 ‘,数据库名.dbo.表名)</p>
<ul>
<li>-生成本地表</li>
</ul>
<p>select * into 表 from openrowset( ‘SQLOLEDB ‘, ‘sql服务器名 ‘; ‘用户名 ‘; ‘密码 ‘,数据库名.dbo.表名)</p>
<ul>
<li>-把本地表导入远程表</li>
</ul>
<p>insert openrowset( ‘SQLOLEDB ‘, ‘sql服务器名 ‘; ‘用户名 ‘; ‘密码 ‘,数据库名.dbo.表名)</p>
<p>select *from 本地表</p>
<ul>
<li>-更新本地表</li>
</ul>
<p>update b</p>
<p>set b.列A&#x3D;a.列A</p>
<p>from openrowset( ‘SQLOLEDB ‘, ‘sql服务器名 ‘; ‘用户名 ‘; ‘密码 ‘,数据库名.dbo.表名)as a inner join 本地表 b</p>
<p>on a.column1&#x3D;b.column1</p>
<ul>
<li>-openquery用法需要创建一个连接</li>
<li>-首先创建一个连接创建链接服务器</li>
</ul>
<p>exec sp_addlinkedserver   ‘ITSV ‘, ‘ ‘, ‘SQLOLEDB ‘, ‘远程服务器名或ip地址 ‘</p>
<ul>
<li>-查询</li>
</ul>
<p>select *</p>
<p>FROM openquery(ITSV, ‘SELECT * FROM 数据库.dbo.表名 ‘)</p>
<ul>
<li>-把本地表导入远程表</li>
</ul>
<p>insert openquery(ITSV, ‘SELECT * FROM 数据库.dbo.表名 ‘)</p>
<p>select * from 本地表</p>
<ul>
<li>-更新本地表</li>
</ul>
<p>update b</p>
<p>set b.列B&#x3D;a.列B</p>
<p>FROM openquery(ITSV, ‘SELECT * FROM 数据库.dbo.表名 ‘) as a</p>
<p>inner join 本地表 b on a.列A&#x3D;b.列A</p>
<ul>
<li>-3、opendatasource&#x2F;openrowset</li>
</ul>
<p>SELECT   *</p>
<p>FROM   opendatasource( ‘SQLOLEDB ‘, ‘Data Source&#x3D;ip&#x2F;ServerName;User ID&#x3D;登陆名;Password&#x3D;密码 ‘ ).test.dbo.roy_ta</p>
<ul>
<li>-把本地表导入远程表</li>
</ul>
<p>insert opendatasource( ‘SQLOLEDB ‘, ‘Data Source&#x3D;ip&#x2F;ServerName;User ID&#x3D;登陆名;Password&#x3D;密码 ‘).数据库.dbo.表名</p>
<p>select * from 本地表</p>
<hr>
<h3 id="SQL-Server基本函数"><a href="#SQL-Server基本函数" class="headerlink" title="SQL Server基本函数"></a>SQL Server基本函数</h3><p>1.字符串函数 长度与分析用</p>
<p>1,datalength(Char_expr) 返回字符串包含字符数,但不包含后面的空格 2,substring(expression,start,length) 取子串，字符串的下标是从“1”，start为起始位置，length为字符串长度，实际应用中以len(expression)取得其长度 3,right(char_expr,int_expr) 返回字符串右边第int_expr个字符，还用left于之相反 4,isnull( check_expression , replacement_value )如果check_expression為空，則返回replacement_value的值，不為空，就返回check_expression字符操作类</p>
<p>5,Sp_addtype 自定義數據類型 例如：EXEC sp_addtype birthday, datetime, ‘NULL’</p>
<p>6,set nocount {on|off} 使返回的结果中不包含有关受 Transact-SQL 语句影响的行数的信息。如果存储过程中包含的一些语句并不返回许多实际的数据，则该设置由于大量减少了网络流量，因此可显著提高性能。SET NOCOUNT 设置是在执行或运行时设置，而不是在分析时设置。 SET NOCOUNT 为 ON 时，不返回计数（表示受 Transact-SQL 语句影响的行数）。</p>
<p>SET NOCOUNT 为 OFF 时，返回计数</p>
<h3 id="常识"><a href="#常识" class="headerlink" title="常识"></a>常识</h3><p>在SQL查询中：from后最多可以跟多少张表或视图：256 在SQL语句中出现 Order by,查询时，先排序，后取 在SQL中，一个字段的最大容量是8000，而对于nvarchar(4000),由于nvarchar是Unicode码。</p>
<p>SQLServer2000同步复制技术实现步骤 </p>
<h4 id="一、-预备工作"><a href="#一、-预备工作" class="headerlink" title="一、 预备工作"></a>一、 预备工作</h4><p>1.发布服务器,订阅服务器都创建一个同名的windows用户,并设置相同的密码,做为发布快照文件夹的有效访问用户 –管理工具 –计算机管理 –用户和组 –右键用户 –新建用户 –建立一个隶属于administrator组的登陆windows的用户（SynUser） </p>
<p>2.在发布服务器上,新建一个共享目录,做为发布的快照文件的存放目录,操作: 我的电脑–D:\ 新建一个目录,名为: PUB –右键这个新建的目录 –属性–共享 –选择”共享该文件夹” –通过”权限”按纽来设置具体的用户权限,保证第一步中创建的用户(SynUser) 具有对该文件夹的所有权限</p>
<p>确定 </p>
<p>3.设置SQL代理(SQLSERVERAGENT)服务的启动用户(发布&#x2F;订阅服务器均做此设置) 开始–程序–管理工具–服务 –右键SQLSERVERAGENT –属性–登陆–选择”此账户” –输入或者选择第一步中创建的windows登录用户名（SynUser） –”密码”中输入该用户的密码 </p>
<p>4.设置SQL Server身份验证模式,解决连接时的权限问题(发布&#x2F;订阅服务器均做此设置) 企业管理器 –右键SQL实例–属性 –安全性–身份验证 –选择”SQL Server 和 Windows” –确定 </p>
<p>5.在发布服务器和订阅服务器上互相注册 企业管理器 –右键SQL Server组 –新建SQL Server注册… –下一步–可用的服务器中,输入你要注册的远程服务器名 –添加 –下一步–连接使用,选择第二个”SQL Server身份验证” –下一步–输入用户名和密码（SynUser） –下一步–选择SQL Server组,也可以创建一个新组 –下一步–完成 </p>
<p>6.对于只能用IP,不能用计算机名的,为其注册服务器别名（此步在实施中没用到） (在连接端配置,比如,在订阅服务器上配置的话,服务器名称中输入的是发布服务器的IP) 开始–程序–Microsoft SQL Server–客户端网络实用工具 –别名–添加 –网络库选择”tcp&#x2F;ip”–服务器别名输入SQL服务器名 –连接参数–服务器名称中输入SQL服务器ip地址 –如果你修改了SQL的端口,取消选择”动态决定端口”,并输入对应的端口号 </p>
<h4 id="二、-正式配置"><a href="#二、-正式配置" class="headerlink" title="二、 正式配置"></a>二、 正式配置</h4><p>1、配置发布服务器 打开企业管理器，在发布服务器（B、C、D）上执行以下步骤: </p>
<p>(1) 从[工具]下拉菜单的[复制]子菜单中选择[配置发布、订阅服务器和分发]出现配置发布和分发向导</p>
<p>(2) [下一步] 选择分发服务器 可以选择把发布服务器自己作为分发服务器或者其他sql的服务器（选择自己） </p>
<p>(3) [下一步] 设置快照文件夹 采用默认<a href="http://www.cnblogs.com/yshj/admin/file://servername/Pub">http://www.cnblogs.com/yshj/admin/file://servername/Pub</a> </p>
<p>(4) [下一步] 自定义配置 可以选择:是,让我设置分发数据库属性启用发布服务器或设置发布设置 否,使用下列默认设置（推荐） </p>
<p>(5) [下一步] 设置分发数据库名称和位置 采用默认值 </p>
<p>(6) [下一步] 启用发布服务器 选择作为发布的服务器 </p>
<p>(7) [下一步] 选择需要发布的数据库和发布类型 </p>
<p>(8) [下一步] 选择注册订阅服务器 </p>
<p>(9) [下一步] 完成配置 </p>
<p>2、创建出版物 发布服务器B、C、D上 </p>
<p>(1)从[工具]菜单的[复制]子菜单中选择[创建和管理发布]命令</p>
<p> (2)选择要创建出版物的数据库，然后单击[创建发布]</p>
<p> (3)在[创建发布向导]的提示对话框中单击[下一步]系统就会弹出一个对话框。对话框上的内容是复制的三个类型。我们现在选第一个也就是默认的快照发布(其他两个大家可以去看看帮助) </p>
<p>(4)单击[下一步]系统要求指定可以订阅该发布的数据库服务器类型, SQLSERVER允许在不同的数据库如 orACLE或ACCESS之间进行数据复制。 但是在这里我们选择运行”SQL SERVER 2000”的数据库服务器 </p>
<p>(5)单击[下一步]系统就弹出一个定义文章的对话框也就是选择要出版的表 注意: 如果前面选择了事务发布 则再这一步中只能选择带有主键的表 </p>
<p>(6)选择发布名称和描述 </p>
<p>(7)自定义发布属性 向导提供的选择: 是 我将自定义数据筛选,启用匿名订阅和或其他自定义属性 否 根据指定方式创建发布 （建议采用自定义的方式） </p>
<p>(8)[下一步] 选择筛选发布的方式 </p>
<p>(9)[下一步] 可以选择是否允许匿名订阅 </p>
<p>1)如果选择署名订阅,则需要在发布服务器上添加订阅服务器 方法: [工具]-&gt;[复制]-&gt;[配置发布、订阅服务器和分发的属性]-&gt;[订阅服务器] 中添加 否则在订阅服务器上请求订阅时会出现的提示:改发布不允许匿名订阅 如果仍然需要匿名订阅则用以下解决办法 [企业管理器]-&gt;[复制]-&gt;[发布内容]-&gt;[属性]-&gt;[订阅选项] 选择允许匿名请求订阅 </p>
<p>2)如果选择匿名订阅,则配置订阅服务器时不会出现以上提示 </p>
<p>(10)[下一步] 设置快照 代理程序调度 </p>
<p>(11)[下一步] 完成配置 当完成出版物的创建后创建出版物的数据库也就变成了一个共享数据库 有数据 srv1.库名..author有字段:id,name,phone, srv2.库名..author有字段:id,name,telphone,adress</p>
<p>要求： srv1.库名..author增加记录则srv1.库名..author记录增加 srv1.库名..author的phone字段更新，则srv1.库名..author对应字段telphone更新 –*&#x2F;</p>
<ul>
<li>-大致的处理步骤 –1.在 srv1 上创建连接服务器,以便在 srv1 中操作 srv2,实现同步 exec sp_addlinkedserver ‘srv2’,’’,’SQLOLEDB’,’srv2的sql实例名或ip’ exec sp_addlinkedsrvlogin ‘srv2’,’false’,null,’用户名’,’密码’ go –2.在 srv1 和 srv2 这两台电脑中,启动 msdtc(分布式事务处理服务),并且设置为自动启动 。我的电脑–控制面板–管理工具–服务–右键 Distributed Transaction Coordinator–属性–启动–并将启动类型设置为自动启动 go</li>
<li>-然后创建一个作业定时调用上面的同步处理存储过程就行了</li>
</ul>
<p>企业管理器 –管理 –SQL Server代理 –右键作业 –新建作业 –”常规”项中输入作业名称 –”步骤”项 –新建 –”步骤名”中输入步骤名 –”类型”中选择”Transact-SQL 脚本(TSQL)” –”数据库”选择执行命令的数据库 –”命令”中输入要执行的语句: exec p_process –确定 –”调度”项 –新建调度 –”名称”中输入调度名称 –”调度类型”中选择你的作业执行安排 –如果选择”反复出现” –点”更改”来设置你的时间安排</p>
<p>然后将SQL Agent服务启动,并设置为自动启动,否则你的作业不会被执行</p>
<p>设置方法: 我的电脑–控制面板–管理工具–服务–右键 SQLSERVERAGENT–属性–启动类型–选择”自动启动”–确定.</p>
<ul>
<li>-3.实现同步处理的方法2,定时同步</li>
<li>-在srv1中创建如下的同步处理存储过程 create proc p_process as –更新修改过的数据 update b set <a href="http://name%[3Di.name/](http://3Di.name/)"><a href="http://name=i.name/">name&#x3D;i.name</a></a>,telphone&#x3D;i.telphone from srv2.库名.dbo.author b,author i where <a href="http://b.id%[3Di.id/](http://3Di.id/)"><a href="http://b.id=i.id/">b.id&#x3D;i.id</a></a> and (<a href="http://b.name/">b.name</a> &lt;&gt; <a href="http://i.name/">i.name</a> or b.telphone &lt;&gt; i.telphone)</li>
<li>-插入新增的数据 insert srv2.库名.dbo.author(id,name,telphone) select id,name,telphone from author i where not exists( select * from srv2.库名.dbo.author where <a href="http://id%[3Di.id/](http://3Di.id/)"><a href="http://id=i.id/">id&#x3D;i.id</a></a>)</li>
<li>-删除已经删除的数据(如果需要的话) delete b from srv2.库名.dbo.author b where not exists( select * from author where <a href="http://id%[3Db.id/](http://3Db.id/)"><a href="http://id=b.id/">id&#x3D;b.id</a></a>) go</li>
</ul>
]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>vlookup进阶_跨文件查询</title>
    <url>/2023/06/15/vlookup%E8%BF%9B%E9%98%B6_%E8%B7%A8%E6%96%87%E4%BB%B6%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p>
<p>leiyu-code.github.io</p>
<p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p>
<h2 id="vlookup进阶-跨文件查询"><a href="#vlookup进阶-跨文件查询" class="headerlink" title="vlookup进阶_跨文件查询"></a>vlookup进阶_跨文件查询</h2><p><strong>How use vlookup function find data from other excel file</strong></p>
<p>​          <em><strong>将两个excel文件放在同一个文件夹里</strong></em></p>
<p>​         <em><strong>为了以后匹配出来的数据的正确性，最好不要在完成数据匹配后再挪动原始文件</strong></em></p>
<p>​         <em><strong>在这里，vlookup函数的匹配范围是匹配文件的绝对路径</strong></em></p>
<p>​        例：</p>
<p>&#x3D;VLOOKUP(B5,’C:\Users\Administrator\Desktop[vlookup基础实验表详细情况.xlsx]Sheet1’!$A$1:$C$10,3,FALSE)</p>
<span id="more"></span>

<p>将文件放在同一个文件夹，并在以后保持不动</p>
<p><a href="https://imgse.com/i/pCuO3zF"><img src="https://s1.ax1x.com/2023/06/15/pCuO3zF.png" alt="pCuO3zF.png"></a></p>
<p>选择匹配范围的时候，选择要匹配的文件相应的范围</p>
<p><a href="https://imgse.com/i/pCuO1RU"><img src="https://s1.ax1x.com/2023/06/15/pCuO1RU.png" alt="pCuO1RU.png"></a></p>
]]></content>
      <categories>
        <category>excel</category>
      </categories>
      <tags>
        <tag>function</tag>
        <tag>vlookup</tag>
      </tags>
  </entry>
  <entry>
    <title>Excel小技巧_按数值自动填充颜色</title>
    <url>/2023/06/15/Excel%E5%B0%8F%E6%8A%80%E5%B7%A7_%E6%8C%89%E6%95%B0%E5%80%BC%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85%E9%A2%9C%E8%89%B2/</url>
    <content><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p>
<p>leiyu-code.github.io</p>
<p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p>
<h2 id="Excel小技巧-按数值自动填充颜色"><a href="#Excel小技巧-按数值自动填充颜色" class="headerlink" title="Excel小技巧_按数值自动填充颜色"></a>Excel小技巧_按数值自动填充颜色</h2><p><strong>Excel Tips : Fill the color according to the number</strong></p>
<p><em><strong>Tips Code:    [蓝色][&gt;&#x3D;60];[红色][&lt;60]</strong></em></p>
<span id="more"></span>

<p>假定需用红色字体显示60以下分数，蓝色字体显示60以上分数。</p>
<p>点击填充颜色的表格，右键单击设置单元格格式或者</p>
<p>按Ctrl+1，设置单元格格式→自定义，类型输入框中输入：</p>
<p>[蓝色][&gt;&#x3D;60];[红色][&lt;60]</p>
<p><a href="https://imgse.com/i/pCusVRU"><img src="https://s1.ax1x.com/2023/06/15/pCusVRU.png" alt="pCusVRU.png"></a></p>
]]></content>
      <categories>
        <category>excel</category>
      </categories>
      <tags>
        <tag>Tips</tag>
      </tags>
  </entry>
  <entry>
    <title>工作笔记_离线驱动导入工具CeoMSX</title>
    <url>/2023/06/13/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0_%E9%A9%B1%E5%8A%A8%E5%B7%A5%E5%85%B7%E8%AE%A9%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%9FG%E8%B5%B7%E6%9D%A5%E5%90%A7/</url>
    <content><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p>
<p>leiyu-code.github.io</p>
<p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p>
<h2 id="工作笔记-离线驱动导入工具CeoMSX"><a href="#工作笔记-离线驱动导入工具CeoMSX" class="headerlink" title="工作笔记_离线驱动导入工具CeoMSX"></a>工作笔记_离线驱动导入工具CeoMSX</h2><p><strong>How Replace the computer hardware without renstalling the system</strong></p>
<p><strong>Come on Use CeoMsx</strong></p>
<p>当您遇到系统无法安装，数据无法读取，怎么办？答案是肯定的，USM是您的首选。USM内置SRS方案能帮助您在PE下识别读取硬盘重要数据，CEO_MSX能帮助您给正常系统导入磁盘控制器驱动从而顺利安装系统，还可以帮助你在换电脑硬件的时候不用重新安装操作系统，甚至能为您导入服务器raid驱动。</p>
<span id="more"></span>



<p> 。USM内置SRS方案能帮助您在PE下识别读取硬盘重要数据，CEO_MSX能帮助您给正常系统导入磁盘控制器驱动从而顺利安装系统。若遇到不支持的设备，请第一时间联系我，反馈给我，我们将免费为您开启VIP绿色通道，我们将以最快的速度适配您的设备。  </p>
<p> 驱动收集原则，系统自身能支持的尽量用系统自带的，确保成功率。(比如NT6.x原生支持AHCI规范，比如Win8之后系统默认  支持USB3.0，比如Win8.1之后的系统默认支持Nvme)  备注：驱动整理收集内容公开，不限任何组织或个人使用，但需注明来源，否则我们保留拒绝使用的权利</p>
<p> 支持XP&#x2F;Vista&#x2F;Win7&#x2F;Win8&#x2F;Win8.1&#x2F;Win10及对应的服务器版本     </p>
<p>几个静默参数，方便第三方开发使用，具体参数说明如下（参数不区分大小写）:  </p>
<p>&#x2F;g 采用通用匹配方案默认静默导入(所有盘符下存在的系统都导入)  </p>
<p>&#x2F;e 采用精确匹配方案默认静默导入(所有盘符下存在的系统都导入)(默认即为&#x2F;e模式，可省略)  </p>
<p>&#x2F;c: 指定盘符静默导入&#x2F;安装  </p>
<p>&#x2F;AHCI:No 在Nt6系统中不导入AHCI驱动，若需导入请使用</p>
<p>&#x2F;AHCI:Yes参数(没有指定此参数时，默认为No)(2019-06-18版新参数)  CEO  MassStorage and XHCI Drivers(CeoMSX)  支持磁盘控制器驱动及XHCI驱动(SRS+USB3.0&#x2F;3.1)离线导入，其中“通用匹配”就是封装系统时使用的导入SRS方案。  </p>
<p>不支持处理当前系统(比如你启动的是C盘的系统，就不能在C盘系统工作下去处理C盘，但是你可以启动C盘的系统去处理D盘的系统。不要问我支不支持PE，我就不告诉你)  特别注意使用前提：其中USB3.0&#x2F;3.1只对win7做完整支持，并且只有精确匹配方案无通用方案，原因intel usb3.0分版本。已经安装好的系统，导入USB3.0&#x2F;3.1驱动可能无法直接生效，需要触发设备管理器的自动刷新。因此建议在系统开始部署之前就导入，也就是说你如果在PE下装GHO，在GHO恢复完就需要用CeoMSX导入USB3.0&#x2F;3.1驱动(原版系统请用PE下的安装工具安装之后再导入)。  支持多ID列表：  （演示intel usb3.0与asm  usb3.1同机）  <img src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image001.png" alt="img">     <img src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png" alt="img">     <img src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image003.png" alt="img">  <strong>3.png</strong> (64.35  KB, 下载次数: 261)  <a href="https://www.sysceo.com/forum/forum.php?mod=attachment&aid=MjU2Nzd8NmZmZWY0ZWJ8MTY4NjY0NTA1NXwwfDQ3Mzk0&nothumb=yes">下载附件</a> <a href="javascript:;">保存到相册</a>  2020-8-15 16:01 上传     <img src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image004.png" alt="img">     <img src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image005.png" alt="img">     <img src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image006.png" alt="img">     <img src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image007.png" alt="img">     <img src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image008.png" alt="img">     <img src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image009.png" alt="img">     <img src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image010.png" alt="img">  </p>
<p>来自 <a href="https://www.sysceo.com/forum/thread-47394-1-1.html">https://www.sysceo.com/forum/thread-47394-1-1.html</a> </p>
]]></content>
      <categories>
        <category>worknote</category>
      </categories>
      <tags>
        <tag>drive</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>工作笔记_u盘启动工具：usbos&amp;ventoy</title>
    <url>/2023/06/13/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0_u%E7%9B%98%E5%90%AF%E5%8A%A8%E5%B7%A5%E5%85%B7%EF%BC%9Ausbos&amp;ventoy/</url>
    <content><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p>
<p><a href="http://leiyu-code.github.io">leiyu-code.github.io</a></p>
<p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p>
<h2 id="工作笔记-u盘启动工具：usbos-ventoy">工作笔记_u盘启动工具：usbos&amp;ventoy</h2>
<p><strong>U disk tools:old mechine use usbos	new mechine use ventoy</strong></p>
<p><em><strong>How to select U disk tools	easy use lovly use</strong></em></p>
<p>​		 <em><strong>1、usbos	old mechine</strong></em></p>
<p>​		 <em><strong>2、vetoy	newly mechine</strong></em></p>
<p>在日常电脑维护工作中，电脑有十几年前的，也有最近的，那么问题来了：</p>
<p>1、IDE   AHCI	RAID</p>
<p>2、CPU</p>
<p>3、FAT16,FAT32,NTFS,exFAT,Ext2/3/4,HFS+,VMFS</p>
<p>4、MBR	GPT</p>
<p>5、BIOS	UEFI</p>
<p>这么多跟启动有关的项目，那么怎么才能选择u盘启动工具才能更好地维护电脑呢？这里我选择以下两个u盘启动工具：</p>
<p>USBOS	用于旧一点儿的电脑和新电脑，兼容性99%可以启动大部分的电脑</p>
<p>VETOY	安装windows系统、Linux系统、苹果系统都可以，简洁、方便、强大</p>
<span id="more"></span>
<h4 id="1、USBOS">1、USBOS</h4>
<p>USBOS是一款专门用于解决计算机问题的非常专业的PE工具箱，无任何流氓行为，非常纯净，功能超级强大，虽然体积大了一些但是在功能上，兼容性上是很多微型PE无法比拟的，用过的朋友就深有感触。是至今一直免费，未加入捆绑，无流氓，未加入商业用途的一款好PE。USBOS系统维护盘工具是集成最全的winpe集合，自带ISO版与UD版合体，不管你是用来做cdrom量产U盘，还是做U盘启动盘都没问题。对于目前的大容量U盘来说不算什么，但确可以满足几乎所有电脑的维护需求，装机需求。软件不但可以用于PC电脑，还可以用于工控机和服务器乃至Surface和Mac电脑，这些设备都可以用本pe来启动，具有极强的兼容性和适用性，拥有diskgenius硬盘分区工具，ghost备份恢复工具等实用工具，支持ghost、iso格式的光盘映像文件。</p>
<p><strong>1.1、特色功能</strong></p>
<p>1、支持各式部署：纯UD、udm、UD二分区、UD三分区、U+高隐、U+深隐、U+不隐、B+、直接安装到本地硬盘、量产、刻盘等等；</p>
<p>2、内置软件总是最新、最潮、最强、也覆盖广泛！</p>
<p>3、利用自带安装工具安装USBOS到移动设备时，因采用独家编制的G4D菜单，在发生UD MBR损毁事故后，具备一定的自我修复能力！！</p>
<p>4、支持安装到Legacy（Win2K-Win10）或UEFI（Win7-Win10）启动本地硬盘，若本地Windows 是Legacy模式启动，USBOS可选带密码保护功能。</p>
<p>5、原则上建议使用WinntSetup来安装原版各Windows，可不区分PE版本，不区分Windows版本，实现无差别对待。</p>
<p><strong>2、VENTOY</strong></p>
<p>简单来说，Ventoy 是一个制作可启动 U 盘的开源工具。<br>
有了 Ventoy 你就无需反复地格式化 U 盘，你只需要把 ISO/WIM/IMG/VHD(x)/EFI 等类型的文件直接拷贝到 U 盘里面就可以启动了，无需其他操作。<br>
你可以一次性拷贝很多个不同类型的镜像文件，Ventoy 会在启动时显示一个菜单来供你进行选择</p>
]]></content>
      <categories>
        <category>worknote</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>windows</tag>
        <tag>tools</tag>
        <tag>apple</tag>
      </tags>
  </entry>
  <entry>
    <title>vlookup函数使用技巧及注意事项</title>
    <url>/2023/06/04/vlookup%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9(C)/</url>
    <content><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p>
<p><a href="http://leiyu-code.github.io">leiyu-code.github.io</a></p>
<p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p>
<h2 id="vlookup函数的使用技巧及注意事项">vlookup函数的使用技巧及注意事项</h2>
<p><strong>怎样才能更好的掌握vlookup函数以及使用时应当注意的问题</strong></p>
<p><em><strong>vlookup函数必知必会</strong></em></p>
<p><em><strong>1、最好使用CVS文件对数据或数值进行操作，如果你想更好地使用vlookup函数</strong></em></p>
<p><em><strong>2、vlookup函数的格式</strong></em></p>
<p>​	VLOOKUP(lookup_value,table_array,col_index_num,range_lookup)</p>
<p><em><strong>3、vlookup函数的作用</strong></em></p>
<p>​	从一个表的范围数据里第一列的数据或数值匹配当前表某个单元格数据或数值，并调用查找范围内这一行某一列的数据或数值到本表的这个单元格里，默认函数的的查找方式(range_lookup)为精确查找</p>
<p><em><strong>4、vlookup函数参数作用</strong></em></p>
<p>​	lookup_value	|	查找的值</p>
<p>​	table_array		|	查找数据的范围</p>
<p>​	col_inex_num	|	返回查找范围内第几列的数据(查找到的当前列的数据为第一列)1…</p>
<p>​	range_lookup	|	匹配数据的精确度(1,true为真，模糊查找  0,false为假，精确查找)</p>
<p><em><strong>5、vlookup使用过程中遇到的常见问题</strong></em></p>
<p>​	5.1 找不到数据或数值</p>
<p>​	<strong>查找的值不对或者查找数据的范围内没有该值或者查找的值查找范围的前几列</strong></p>
<p>​	5.2 当你下拉公式时，里面的数值是不是发生了变化，导致查询出错</p>
<p>​	<strong>当下拉公式时必须用 “$” 锁定公式里的数值</strong></p>
<p>​	<strong>$A$2:$B$7</strong></p>
<p>​	5.3 单元格里的数值的格式不一致</p>
<p>​	<strong>保证单元格里的数据一致，格式也一致</strong></p>
<p>​	查找的单元格里的数据的左上角有绿色三角时，在数值的前面加上个半角的逗号，数据就会正常</p>
<p>​	<strong>,112223366</strong></p>
<p>​	用分列工具，将有绿色三角的数据分列为正常的格式</p>
<p>​	5.4 看不到的空格</p>
<p>​	<strong>有时查不到数据时，有可能是单元格里的中g据的后面有看不见的空格，导致查找不到数据</strong></p>
<p>​	<strong>1122336688  比如像这样，1122336688后面的空格</strong></p>
<p>​	<em><strong>解决方法：</strong></em></p>
<p>​	ctrl+h	替换掉表里所有单元格数据里的空格</p>
]]></content>
      <categories>
        <category>office</category>
      </categories>
      <tags>
        <tag>tips</tag>
        <tag>function</tag>
      </tags>
  </entry>
  <entry>
    <title>vlookup function TIPS</title>
    <url>/2023/06/02/vlookup%20fuction%20tips(E)/</url>
    <content><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p>
<p><a href="http://leiyu-code.github.io">leiyu-code.github.io</a></p>
<p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p>
<h2 id="vlookup-function-TIPS">vlookup function TIPS</h2>
<p><strong>How to use vlookup function of Office’excel</strong></p>
<p><em><strong>Tisps:use vllokup functon and others must know:</strong></em></p>
<p><em><strong>1、best use CVS file go to date and number 's changs，if you want be good use</strong></em></p>
<p><em><strong>2、vlookup function ’ format:</strong></em></p>
<p>​	VLOOKUP(lookup_value,table_array,col_index_num,range_lookup)</p>
<p><em><strong>3、vlookup function 's effect</strong></em>:</p>
<p>​	Search for the first column of the table region that meets the criteria, determine the row number of the cell to be retrieved in the region, and then further return the value of the selected cell. By default, tables are sorted in ascending order</p>
<p><em><strong>4、vlookup function parrameter specification</strong></em></p>
<p>​	lookup_value	|	find the value of the first column</p>
<p>​	table_array		|	find the range of that table</p>
<p>​	col_inex_num	|	column of find’s table (1,…)</p>
<p>​	range_lookup	|	exact match or fuzzy match(1,true or 0,false)</p>
<p><em><strong>5、common problem</strong></em></p>
<p>​	5.1 Unmatched date</p>
<p>​	<strong>table_array effect 's first column must is lookup_value</strong></p>
<p>​	5.2 When you drop-downing formula, the formula was change</p>
<p>​	<strong>drop-downing formula must use “$” lock value</strong></p>
<p>​	<strong>$A$2:$B$7</strong></p>
<p>​	5.3 the value’s format was diffrent</p>
<p>​	<strong>keep the table value same and format same</strong></p>
<p>​	<strong>when the value 's front have green mark, must use &quot;,&quot;add the value 's front, disspear the green mark</strong></p>
<p>​	<strong>,112223366</strong></p>
<p>​	5.4 didn’t see space</p>
<p>​	<strong>when the value back have a space, we must clear that space</strong></p>
<p>​	<strong>1122336688  this value have a space</strong></p>
]]></content>
      <categories>
        <category>office</category>
      </categories>
      <tags>
        <tag>tips</tag>
        <tag>function</tag>
      </tags>
  </entry>
  <entry>
    <title>CVS使用技巧总结</title>
    <url>/2023/06/01/CSV%E6%96%87%E4%BB%B6%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p>
<p>leiyu-code.github.io</p>
<p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p>
<h2 id="CVS使用技巧总结"><a href="#CVS使用技巧总结" class="headerlink" title="CVS使用技巧总结"></a>CVS使用技巧总结</h2><p><strong>How to use CVS FILE of Office’excel</strong></p>
<p><em><strong>为什么要使用CVS文件</strong></em></p>
<p>CVS文件可以在不兼容的格式上转移表格数据</p>
<p><em><strong>怎样在Excel里使用CSV文件</strong></em></p>
<p>使用Excel里的分列功能或者导入文件功能，然后另存为Excel表格式</p>
<span id="more"></span>



<p>先上大图：</p>
<p><a href="https://imgse.com/i/p9zMbwt"><img src="https://s1.ax1x.com/2023/06/01/p9zMbwt.png" alt="p9zMbwt.png"></a></p>
<h3 id="1-什么是CSV文件"><a href="#1-什么是CSV文件" class="headerlink" title="1. 什么是CSV文件"></a>1. 什么是CSV文件</h3><p><strong>CSV：逗号分隔值（Comma-Separated Values）其文件以纯文本形式存储数据（数字和文本），其中逗号被称为分隔符，但是逗号并不是唯一的分隔符。</strong></p>
<p><strong>其他流行的分隔符包括制表符（<code>\t</code>）、冒号（<code>:</code>)和分号（<code>;</code>），所以一般说CSV文件都是泛指，指用特定分隔符进行字段分隔的结构化格式文件。</strong></p>
<p><strong>【1】CVS文件基本规则&#x2F;特点</strong></p>
<ul>
<li>首行是「<strong>字段</strong>」行，以分隔符分割，字段也就是列名，就是对数据的描述</li>
<li>首行外，其他行是记录行</li>
<li><strong>一条记录在一行内，不跨行</strong></li>
</ul>
<p><strong>【2】CSV文件打开方式</strong></p>
<p>CSV文件本身是相对简单、通用的表格类型文件，也就是说文本编辑器记事本以及Excel都可以直接打开。</p>
<blockquote>
<p>如果对文本处理有极高要求，这里推荐Notepad++</p>
</blockquote>
<p><strong>如果分隔符为”,”，那么CSV文件在Excel打开后无需分列操作；</strong></p>
<blockquote>
<p>但是如果明明分隔符是逗号，打开却没有自动分列，多半是编码问题；此时可以用记事本将<strong>CSV文件另存，修改编码为ANSI或者UTF-8</strong></p>
</blockquote>
<h3 id="简单认识字符集和编码"><a href="#简单认识字符集和编码" class="headerlink" title="简单认识字符集和编码"></a>简单认识字符集和编码</h3><ul>
<li><strong>ASCII码</strong></li>
</ul>
<p>计算机对所有数据&#x2F;信息的读取，最底层都是基于二进制0和1，通过多个0和1的组合就可以有多种状态，比如说8位二进制就可以有256种组合&#x2F;状态，当然也就可以代表256个字符了。</p>
<p>我们都知道计算机是美国人发明的，由英语字母、阿拉伯数字、符号这些字符组成一个字符集，称为美国信息交换标准代码，ASCII码（American Standard Code for Information Interchange）。</p>
<p>关于ASCII码我们需要知道就两条：</p>
<p>&lt;1. 存储使用8位二进制，即一个字节；</p>
<p>&lt;2. 适用于英文环境，不能对中文编码；</p>
<ul>
<li><strong>UNICODE码</strong></li>
</ul>
<p>前面说到，ASCII没法表示中文，事实上除了中文，法文、德文…都没法表示，这时候ISO出现了，制定unicode字符集，unicode 也叫万国码，因为开发者是统一码联盟，所以又称为统一码，unicode 很复杂，不需要深究，知道三点就行：</p>
<p>&lt;1. unicode 制定者是统一码联盟；</p>
<p>&lt;2. 使用<strong>2-4</strong>个字节来表示字符；</p>
<p>&lt;3. unicode只规定了字符集，并没有规定在计算机如何存储；</p>
<p>同时期，ISO也在开发这样一种编码，叫做通用字符集UCS（Universal Character Set），不同之处是UCS分为UCS-2以及UCS-4，分别指用2&#x2F;4个字节对字符进行编码。</p>
<p>后来双方开始进行整合，所以现在unicode的编码和ucs的编码都基本一致。</p>
<p>前面说过unicode&#x2F;ucs只规定了字符集，但是在计算机的存储上却没有指明，于是又出现了UTF-16、UTF-32、UTF-8形式，这里UTF全称Unicode Transformation Format。16，32，8分别指存储位数。</p>
<blockquote>
<p>数据在内存上存储又分为大端序[BE, big endian]和小端序[LE, little endian]；<br>举例，数据0x1234，需要占用两个字节存储，数据0x34存储在内存低字节地址上则代表LE，否则则是BE<br><strong>所以说UTF-16可细分为UTF-16 BE、UTF-16 LE</strong></p>
</blockquote>
<p><strong>再说UTF-8</strong></p>
<p><strong>UTF-8 也是unicode的实现方式之一</strong></p>
<p>UTF-8的特点是可变字长，用一个字节就可以表示英文字符，用三个字节来表示汉字…</p>
<blockquote>
<p>UTF-8的出现完全是顺应了互联网的需求，因为占用存储少，所以现在很流行，目前网页编码多采用这一形式。</p>
</blockquote>
<ul>
<li><strong>ANSI</strong></li>
</ul>
<p>ANSI(American National Standards Institute)，美国国家标准学会。ANSI就比较奇怪了，首先ANSI的编码是取决与各国家语言的，而且各语言之间并不兼容。</p>
<p><strong>ANSI其实是一种伪编码或者说继承类编码！</strong></p>
<p>ANSI并不是某一种特定的字符编码，而是一种体系，说白了每种语言都会有自己独立的编码，像中文<strong>GB2312</strong>，繁体中文的<strong>BIG5</strong>，日本的**JIS…**，而这些编码都在ANSI体系下。</p>
<p><strong>说白了，ANSI是他们特定语言的指向！</strong></p>
<p>Windows默认编码是ANSI，但是针对不同国家的语言，ANSI是如何确定具体编码那？</p>
<p><strong>其实很简单，就是看windows设置的语言或者设定区域。</strong></p>
<p><strong>比如说，当我用记事本&#x2F;Notepad录入汉字，保存时会提出警告，建议我将编码更改为unicode，否则汉字将会丢失</strong></p>
<h3 id="3、怎么将自己的操作系统语言更改为支持中文"><a href="#3、怎么将自己的操作系统语言更改为支持中文" class="headerlink" title="3、怎么将自己的操作系统语言更改为支持中文"></a>3、怎么将自己的操作系统语言更改为支持中文</h3><p><strong>首先我的系统语言是英语，设定区域为United States，ANSI遵从的编码其实是ASCII，当然是不支持汉字字符的。</strong></p>
<p>假如你跟我一样，系统语言为英文，同时因为各种原因没办法切换到中文系统，怎么办？</p>
<ul>
<li><strong>临时解决</strong></li>
</ul>
<p><strong>将文本文件另存，编码选择为unicode，因为unicode是支持中文的</strong></p>
<blockquote>
<p>缺点就是每次新建记事本都需要更改编码</p>
</blockquote>
<ul>
<li><strong>一次性解决</strong></li>
</ul>
<p><strong>系统位置更改为Chinese(Simplified, China)，推荐！</strong></p>
<h2 id="4、CSV文件如何在Excel中分列显示-Tips"><a href="#4、CSV文件如何在Excel中分列显示-Tips" class="headerlink" title="4、CSV文件如何在Excel中分列显示    Tips"></a>4、CSV文件如何在Excel中分列显示    Tips</h2><p>前面说了，对于用逗号分隔的CSV文件，在Excel打开自然就已经分列，所以现在要说的是其他分隔符类型的CSV文件，如何在Excel中分列显示。</p>
<p><strong>三种方法</strong></p>
<p><strong>【1】使用记事本将分隔符直接替换为逗号</strong></p>
<p><strong>【2】使用Excel分列(Text to Column)功能</strong></p>
<p><strong>【3】使用Excel数据导入功能</strong></p>
<p><strong>NOTE:</strong></p>
<p>需要注意的是，如果使用Excel对CSV文件进行编辑，保存后，分隔符自动替换为”,”！如果需要更改其他分隔符，建议在记事本中替换。</p>
]]></content>
      <categories>
        <category>office</category>
      </categories>
      <tags>
        <tag>tips</tag>
        <tag>CVS</tag>
      </tags>
  </entry>
  <entry>
    <title>workDaily_boot mgr is conmpressed</title>
    <url>/2023/05/31/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97_boot%20mgr%20is%20conmpressed/</url>
    <content><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p>
<p>leiyu-code.github.io</p>
<p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p>
<h2 id="workDaily-boot-mgr-is-conmpressed"><a href="#workDaily-boot-mgr-is-conmpressed" class="headerlink" title="workDaily_boot mgr is conmpressed"></a>workDaily_boot mgr is conmpressed</h2><p><strong>电脑故障描述：电脑开机后屏幕显示：boot mgr is conmpressed    press ctrl+alt+del reboot</strong></p>
<p>故障解决步骤：</p>
<p><em><strong>step:1、插入带PE的U盘，进入windows pe维护系统</strong></em></p>
<p>​         <em><strong>2、在PE中打开我的电脑，右键点击系统盘，一般是C盘</strong></em></p>
<p>​         <em><strong>3、进入系统盘属性后，在常规选项卡下勾掉“压缩驱动器以节约磁盘空间</strong></em></p>
<p>​        *<strong>4、点击确定后选择”仅将更改应用于驱动器 c:\*</strong></p>
<span id="more"></span>

<p>具体情况描述：</p>
<p>电脑开机后不能进入系统，提示按热键重启</p>
<p><a href="https://imgse.com/i/p9v5o90"><img src="https://s1.ax1x.com/2023/05/31/p9v5o90.jpg" alt="p9v5o90.jpg"></a></p>
<p>解决方法：</p>
<p>重启电脑，插入带PE的启动设备，在PE里右键打开C盘，勾选掉压缩驱动器以节约磁盘空间</p>
<p><a href="https://imgse.com/i/p9v55hq"><img src="https://s1.ax1x.com/2023/05/31/p9v55hq.jpg" alt="p9v55hq.jpg"></a></p>
<p><strong>NOTE:</strong></p>
<p><strong>此解决方案仅适用于windows开机后显示“boot mgr is conmpressed”，然后进入不了电脑系统的故障</strong></p>
]]></content>
      <categories>
        <category>workdaily</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>Troubleshooting</tag>
      </tags>
  </entry>
  <entry>
    <title>好书推荐_翦商</title>
    <url>/2023/05/30/%E5%A5%BD%E4%B9%A6%E6%8E%A8%E8%8D%90_%E7%BF%A6%E5%95%86/</url>
    <content><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p>
<p>leiyu-code.github.io</p>
<p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p>
<h2 id="好书推荐-《翦商》"><a href="#好书推荐-《翦商》" class="headerlink" title="好书推荐_《翦商》"></a>好书推荐_《翦商》</h2><p><strong>南月晨的书单</strong></p>
<p><strong>MUSTREAD</strong></p>
<p>《翦商》</p>
<p><a href="https://imgse.com/i/p9jKDyt"><img src="https://s1.ax1x.com/2023/05/30/p9jKDyt.jpg" alt="p9jKDyt.jpg"></a></p>
<p><em><strong>语录</strong></em></p>
<pre><code>  ***1、凝视深渊，是如此压抑、深沉而意义重大。***
</code></pre>
<p>​      <em><strong>2、人类如此好奇、如此执着，而激发人类好奇心的内在动力，一定是对真相的渴望。我们探寻真相，想知道自己是谁、来自哪里，又去向何处，是我们内心无法停止的渴望，是人之为人的意义所在。只有越来越清晰地看到来路，我们才能走向更明确的未来，哪怕回望之旅颠覆认知。</strong></em></p>
<p>​      <em><strong>3、“也许，人不应当凝视深渊；虽然深渊就在那里。”</strong></em></p>
<p>​    <em><strong>4、混血、统一、开放的新华夏民族诞生后，华夏历史沿着武王和周公“修改”后的轨迹继续前行，直至今日。《翦商》可以感受到这种文化特性，依然是真实存在于中国人血脉里的。有热情、有温情、有创造、有谦逊、有光明、有黑暗才是完整的人性。</strong></em></p>
<p><a href="https://imgse.com/i/p9jKaJH"><img src="https://s1.ax1x.com/2023/05/30/p9jKaJH.jpg" alt="p9jKaJH.jpg"></a></p>
<p>段落节选在：</p>
<p><a href="https://export.shobserver.com/baijiahao/html/598311.html">https://export.shobserver.com/baijiahao/html/598311.html</a></p>
]]></content>
      <categories>
        <category>books</category>
      </categories>
      <tags>
        <tag>history</tag>
        <tag>mustread</tag>
      </tags>
  </entry>
  <entry>
    <title>NorootinstallkalilinuxNetHunterturmux</title>
    <url>/2023/03/15/Norootinstallkalilinux-NetHunter-turmux/</url>
    <content><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p>
<p>leiyu-code.github.io</p>
<p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p>
<h2 id="No-root-install-kalilinux-NetHunter-turmux"><a href="#No-root-install-kalilinux-NetHunter-turmux" class="headerlink" title="No root install kalilinux-NetHunter-turmux"></a>No root install kalilinux-NetHunter-turmux</h2><p><strong>How install kalilinux-NetHunter-turmux on Andriod system &amp; No root</strong></p>
<p>video link’s here:</p>
<p>【你的下一台Kali，何必是电脑（无Root）（小白教程）】<a href="https://www.bilibili.com/video/BV1fT411m7Vd?vd_source=76002958418cebc601a16afe2e2acd64">https://www.bilibili.com/video/BV1fT411m7Vd?vd_source=76002958418cebc601a16afe2e2acd64</a></p>
<p><em><strong>step:1、Get Termux program</strong></em></p>
<p>​         <em><strong>2、upgrad termux</strong></em></p>
<p>​         <em><strong>3、Get nethunter Store</strong></em></p>
<span id="more"></span>



<h4 id="1、Get-Termux-program"><a href="#1、Get-Termux-program" class="headerlink" title="1、Get Termux program"></a>1、Get Termux program</h4><p>github.com&#x2F;termux&#x2F;termux-app&#x2F;releases</p>
<p>Download file：</p>
<p>termux-app_v0.118.0+github-debug_arm64-v8a.apk</p>
<p>Install this apk</p>
<p>After installed termux apk,Open it</p>
<h4 id="2、upgrad-termux"><a href="#2、upgrad-termux" class="headerlink" title="2、upgrad termux"></a>2、upgrad termux</h4><p>apt update</p>
<p>Apt upgrade</p>
<p><em><strong>Install wget</strong></em></p>
<p>apt install wget</p>
<p>wget -O install -nethunter-termux <a href="https://offs.ec/2MceZwr">https://offs.ec/2MceZwr</a></p>
<p><em><strong>Chmod file permissions</strong></em></p>
<p>chmod +x install-nethunter-termux</p>
<p>.&#x2F;install-nethunter-termux</p>
<p><em><strong>When [?] Delete downloaded rootfs file? [y&#x2F;N] then N</strong></em></p>
<p><em><strong>Set nethunter password</strong></em></p>
<p>Nethunter kex passwd</p>
<h4 id="3、Get-nethunter-Store"><a href="#3、Get-nethunter-Store" class="headerlink" title="3、Get nethunter Store"></a>3、Get nethunter Store</h4><p>Form Browser</p>
<p>Store.nethunter.com&#x2F;en</p>
<p>Click</p>
<p>DOWNLOAD STORE APP</p>
<p>Installing</p>
<p>Open “Allow from this source”</p>
<p>In browsers ,serch NetHunter KeX</p>
<p>Double click ,run it </p>
<p>Input VNC Username</p>
<p>Click Connect</p>
<p><strong>NOTE:</strong></p>
<p><strong>Don’t install it on Android 12</strong></p>
<p><strong>In Android 12 have programs killed term。</strong></p>
]]></content>
      <categories>
        <category>system</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>nethunter</tag>
      </tags>
  </entry>
  <entry>
    <title>网工、运维最常用的四款远程工具：PuTTY、MobaXterm、SecureCRT、XSHELL</title>
    <url>/2023/03/15/%E7%BD%91%E5%B7%A5%E3%80%81%E8%BF%90%E7%BB%B4%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84%E5%9B%9B%E6%AC%BE%E8%BF%9C%E7%A8%8B%E5%B7%A5%E5%85%B7%EF%BC%9APuTTY%E3%80%81MobaXterm%E3%80%81SecureCRT%E3%80%81XSHELL/</url>
    <content><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p>
<p><a href="http://leiyu-code.github.io">leiyu-code.github.io</a></p>
<p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p>
<h2 id="网工、运维最常用的四款远程工具：PuTTY、MobaXterm、SecureCRT、XSHELL">网工、运维最常用的四款远程工具：PuTTY、MobaXterm、SecureCRT、XSHELL</h2>
<p><strong>PuTTY、MobaXterm、SecureCRT、XSHELL</strong></p>
<span id="more"></span>
<p>作为 IT 工程师，我们最常用的工具应该是终端模拟器，常见的终端仿真器包括 PuTTY、MobaXterm、SecureCRT 和 Xshell。</p>
<p>在这篇文章中，我们将分享它们之间的区别，以及我们如何从 PuTTY、MobaXterm、SecureCRT 和 Xshell 中选择一个。</p>
<p><strong>PuTTY</strong></p>
<p>PuTTY 是一个免费的开源终端仿真器、串行控制台和网络文件传输应用程序，支持常用的连接协议，如SSH、Telnet、Rlogin、SCP等。此外，PuTTY 还支持创建与设备的串行连接。</p>
<p>PuTTY 是一个轻量级的软件，通常，PuTTY 的安装包大小只有几个 K 字节左右，另一方面，PuTTY 几乎支持所有操作系统，例如 Windows、macOS 和 Linux，轻巧的特性使 PuTTY 可以安装在旧 PC 或一些便携式但性能较差的笔记本电脑上，此外，轻量级还有助于加快启动过程。</p>
<p>PuTTY 的最大缺点是无法在一个具有多选项卡的窗口中管理会话，这使得您在创建数十个会话时很难找到所需的会话。</p>
<p><a href="https://putty.org/">https://putty.org/</a></p>
<p><strong>MobaXterm</strong></p>
<p>MobaXterm 是远程计算的终极工具箱，它提供了几乎所有重要的远程网络工具，SSH、RDP、FTP、VNC，只要你能想到的，都可以在MobaXterm中找到。</p>
<p>除了海量协议外，MobaXterm 还支持安装额外的插件来扩展其功能。</p>
<p>除了强大的功能之外，MobaXterm 还使 Linux 文件管理更加容易，它为 Linux 操作系统提供了一个可视化界面，以便管理员可以使用鼠标找到文件，而不是输入命令。</p>
<p>但是，与 PuTTY 不同的是，MobaXterm 支持的操作系统是 Windows。这使得它不如 PuTTY 通用。</p>
<p>另一方面，强大的功能使其臃肿且消耗资源，这使其成为旧PC和性能不佳的笔记本电脑的次优选择。</p>
<p>MobaXterm 提供两个版本，家庭版和专业版，家庭版免费使用，但会话和其他功能有限，而您可以购买专业版以解锁限制。</p>
<p><a href="https://mobaxterm.mobatek.net/">https://mobaxterm.mobatek.net/</a></p>
<p><strong>SecureCRT</strong></p>
<p>作为老牌终端模拟器，SecureCRT 可能是该类别中使用最多的软件。</p>
<p>SecureCRT 是 VanDyke Software 的商业 SSH 和 Telnet 客户端和终端仿真器。</p>
<p>在旧版本中，SecureCRT 仅支持 Windows 系统，后来，VanDyke 添加了 MacOS 版本（在 v6.6 中），然后是 Linux 版本（在 v6.7 中）。</p>
<p>与 MobaXterm 一样，SecureCRT 也提供了选项卡式会话管理功能。</p>
<p>简单地说，SecureCRT 可以看作是 MobaXterm 的弱化版本，它支持的协议更少。</p>
<p>SecureCRT作为商业软件，需要用户购买，但在此之前，可以拥有30天的评估许可。</p>
<p><a href="https://www.vandyke.com/products/securecrt/">https://www.vandyke.com/products/securecrt/</a></p>
<p><strong>XSHELL</strong></p>
<p>XSHELL 是一款功能强大的 Windows PC 终端仿真器，支持 SSH、SFTP、TELNET、RLOGIN 和 SERIAL。</p>
<p>与 MobaXterm 一样，XSHELL 仅支持 Windows 系统，2017 年 8 月 4 日，卡巴斯基工程师在 Xshell 软件中发现了一个后门，这对 XSHELL 造成了相当大的打击。</p>
<p>与 SecureCRT 一样，最新的 XSHELL 版本也需要许可证才能使用。</p>
<p><a href="https://www.xshell.com/en/xshell/">https://www.xshell.com/en/xshell/</a></p>
<p><strong>PuTTY、MobaXterm、SecureCRT、XSHELL，该选哪个？</strong></p>
<p><strong>1、支持的协议</strong></p>
<p><strong>PuTTY</strong> ：SCP、SSH、Telnet、Rlogin、Raw      socket、Serial<br>
<strong>MobaXterm</strong> ：SSH、Telent、Rsh、RDP、VNC、FTP、SFTP、Xdmcp、Serial<br>
<strong>SecureCRT</strong> ：SSH、Telnet、Relogin、Serial、RAW、TAPI<br>
<strong>XSHELL</strong> ：SSH、SFTP、Telnet、Rlogin、Serial</p>
<p><strong>2、支持的系统</strong></p>
<p><strong>PuTTY</strong> ：Windows、MacOS、Linux<br>
<strong>MobaXterm</strong> ：Windows<br>
<strong>SecureCRT</strong> ：Windows、MacOS、Linux<br>
<strong>XSHELL</strong> ：Windows</p>
<p><strong>3、免费使用</strong></p>
<p><strong>PuTTY</strong> ：是<br>
<strong>MobaXterm</strong> ：家庭版<br>
<strong>SecureCRT</strong> ：否<br>
<strong>XSHELL</strong> ：否</p>
<p><strong>4、开源</strong></p>
<p><strong>PuTTY</strong> ：是<br>
<strong>MobaXterm</strong> ：否<br>
<strong>SecureCRT</strong> ：否<br>
<strong>XSHELL</strong> ：否</p>
<p><strong>5、功能丰富</strong></p>
<p><strong>PuTTY</strong> ：低<br>
<strong>MobaXterm</strong> ：高<br>
<strong>SecureCRT</strong> ：中等<br>
<strong>XSHELL</strong> ：中等</p>
<p><strong>6、资源消耗</strong></p>
<p><strong>PuTTY</strong> ：低<br>
<strong>MobaXterm</strong> ：高<br>
<strong>SecureCRT</strong> ：中等<br>
<strong>XSHELL</strong> ：中等</p>
<p><strong>结论</strong></p>
<ol>
<li>如果需要消耗最少资源的终端仿真器，PuTTY 是最佳选择。</li>
<li>要获得尽可能多的外观信息，MobaXterm 将是最佳选择。</li>
<li>如果需要免费软件，并且同时创建大量会话时选择 PuTTY。</li>
<li>如果只需要创建几个会话时选择 MobaXterm。</li>
</ol>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>emotetools</tag>
        <tag>computerbash</tag>
      </tags>
  </entry>
  <entry>
    <title>思维导图作用及小初高导图下载</title>
    <url>/2023/03/10/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E4%BD%9C%E7%94%A8%E5%8F%8A%E5%B0%8F%E5%88%9D%E9%AB%98%E5%AF%BC%E5%9B%BE%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p>
<p><a href="http://leiyu-code.github.io">leiyu-code.github.io</a></p>
<p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p>
<h2 id="思维导图作用及小初高导图下载">思维导图作用及小初高导图下载</h2>
<p><em><strong>思维导图，英文是The Mind Map，又名心智导图，是表达发散性思维的有效图形思维工具 ，它简单却又很有效同时又很高效，是一种实用性的思维工具。</strong></em></p>
<p>思维导图运用图文并重的技巧，把各级主题的关系用相互隶属与相关的层级图表现出来，把主题关键词与图像、颜色等建立记忆链接。<br>
思维导图充分运用左右脑的机能，利用记忆、阅读、思维的规律，协助人们在科学与艺术、逻辑与想象之间平衡发展，从而开启人类大脑的无限潜能。思维导图因此具有人类思维的强大功能。<br>
思维导图是一种将思维形象化的方法。我们知道放射性思考是人类大脑的自然思考方式，每一种进入大脑的资料，不论是感觉、记忆或是想法——包括文字、数字、符码、香气、食物、线条、颜色、意象、节奏、音符等，都可以成为一个思考中心，并由此中心向外发散出成千上万的关节点。<br>
每一个关节点代表与中心主题的一个连结，而每一个连结又可以成为另一个中心主题，再向外发散出成千上万的关节点，呈现出放射性立体结构，而这些关节的连结可以视为您的记忆，就如同大脑中的神经元一样互相连接，也就是您的个人数据库。<br>
思维导图又称脑图、心智地图、脑力激荡图、灵感触发图、概念地图、树状图、树枝图或思维地图，是一种图像式思维的工具以及一种利用图像式思考辅助工具。<br>
思维导图是使用一个中央关键词或想法引起形象化的构造和分类的想法；它用一个中央关键词或想法以辐射线形连接所有的代表字词、想法、任务或其它关联项目的图解方式。</p>
<p>小初高思维导图下载</p>
<p>小学、初中、高中全科九门…）-可下载打印） <a href="https://www.aliyundrive.com/s/6CQ1yf3J31f">https://www.aliyundrive.com/s/6CQ1yf3J31f</a> 点击链接保存，或者复制本段内容，打开「阿里云盘」APP ，无需下载极速在线查看，视频原画倍速播放。</p>
]]></content>
      <categories>
        <category>studynote</category>
      </categories>
      <tags>
        <tag>mindmap</tag>
        <tag>means</tag>
      </tags>
  </entry>
  <entry>
    <title>五种超棒笔记方法以及我选择的笔记软件</title>
    <url>/2023/03/08/%E7%AC%94%E8%AE%B0-%E5%BB%BA%E7%AB%8B%20%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p>
<p><a href="http://leiyu-code.github.io">leiyu-code.github.io</a></p>
<p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p>
<h1>五种超棒笔记方法以及我选择的笔记软件</h1>
<p><em><strong>学习的目的是把所有的知识都消化成自己的，包括古往今来的，老师教的，他人教的，在这个过程中，掌握好的学习方法，使用好用的学习工具才能事半功倍</strong></em></p>
<p><strong>所有的方法和工具只是让自己记住所有的知识点</strong></p>
<p><strong>最好的记忆方法是将知识点转化为自己可以描述，自己可以理解的，死记硬背是最不可取的方法</strong></p>
<p><em><strong>拿出一张白纸，看看你能不能把所有的知识点默写下来，并且看能不能将它们梳理在一起</strong></em></p>
<p>变成自己的变成自己的，这点才最重要！！！</p>
<p>记笔记的五大方法</p>
<ul>
<li>康奈尔笔记法</li>
<li>思维导图法</li>
<li>麦肯锡笔记法</li>
<li>东京大学笔记法</li>
<li>RIA笔记法</li>
</ul>
<p>记笔记的工具</p>
<ul>
<li>onenote非简易版</li>
<li>Microsoft edge 及插件super copy</li>
<li>markdown编辑器typora</li>
<li>网站github及hexo</li>
<li>图床工具imgse</li>
<li>思维导图工具markmap</li>
</ul>
<span id="more"></span>
<p>俗话说“好记性不如烂笔头”，想要学得好，笔记少不了。但好的笔记不是抄书，而是帮助我们整理知识、记录思考，最终搭建知识体系的工具。盘点了5种超好用的笔记方法，提升效率必备器，赶快收藏～</p>
<h2 id="记笔记的目的">记笔记的目的</h2>
<p>1.记忆</p>
<p>记笔记最基本的作用，就是再次加深对内容的记忆。古人所说“手抄一遍，胜读十遍”不是没道理的。</p>
<p>2.复习</p>
<p>笔记记下的都是课堂上的重要知识点，课本浓缩后的精华，复习时可以提高效率。</p>
<p>3.加深理解</p>
<p>做笔记时，眼睛在看，大脑在想，会加深时知识的理解。</p>
<p>4.集中注意力</p>
<p>课堂笔记可以帮助我们集中注意力，防止走神。但同时应该处理好听课和记笔记的关系。</p>
<h2 id="笔记要记什么">笔记要记什么</h2>
<p>1.记知识点的框架</p>
<p>上课时时间比较紧，如果没办法及时做记录,建议大家先听老师讲，然后记录老师酌纲要部分和重点部分。这样知识体系一目了然，其他部分等课余时间根据自己酌理解，或者其他同学酌笔记作补充，再巩固一遍.</p>
<p>2.记思维</p>
<p>记笔记，如果仅仅是把老师黑板上酌板书抄一遍，效果合很差。尤其是理科重要的是老师在推导某一个公式时候的思路，以及老师解题酌小技巧。</p>
<p>3.记重难点和易错点</p>
<p>记笔记时，需要对笔记的内容分层，将其中的难点和易错点，用不同颜色酌笔标注出来。</p>
<p>4.记补充点</p>
<p>在老师的讲课过程中，除了课本上的知识点，还会有很多延伸的知识，需要大家注意学习掌握。</p>
<p>5.记自己的总结和思考</p>
<p>记笔记最好的模式是一-每一节知识点都有自己的总结，最好能梳理出有关单元知识和方法的内在联系，形成知识体系。</p>
<p><a href="https://imgse.com/i/ppeWY34"><img src="https://s1.ax1x.com/2023/03/08/ppeWY34.png" alt="ppeWY34.png"></a></p>
<h2 id="记笔记的误区">记笔记的误区</h2>
<p>误区1:笔记就是抄板书</p>
<p>记笔记并不是照着老师酌板书，一字不漏地抄下来，笔记是知识点酌浓缩。</p>
<p>误区2 :笔记从不回顾</p>
<p>做笔记是为了以后复习应顾，笔记定要多翻看。</p>
<p>误区3:笔记不做更新</p>
<p>笔记应该在后续的复习和巩固中，不断补充和更新知识点。</p>
<h2 id="记笔记的小技巧">记笔记的小技巧</h2>
<p>1.不要记得太紧太密，每页右边留下约1/3的空白，以便日后补充、修改。</p>
<p>2.用词用语要简洁浓缩，常用词语可用代号。</p>
<p>3做笔记时写字要快，在记录的知识点较多时，字迹要求不要太高，自己能看清就行。</p>
<p>4.注意听课与看书结合，有些内容可在书上批注。</p>
<p>5.用便利贴随时往备记录灵感，整理成型后及时补充到笔记本上。</p>
<p>6.充分利用活页，活页本适合文综积累型科目,不断补充新知，把笔记变厚，也适合理综思维型科目，让新思路和解题的究破口不必拘泥于纸张限制。</p>
<h2 id="记笔记的五大方法">记笔记的五大方法</h2>
<p>1、康奈尔笔记法</p>
<p>优点：</p>
<p>✔建立笔记内容的内部索引。学习笔记记完不能用来服务于学习就等于没记。康内尔笔记巧妙的避免了笔记内容的不可检索性和复习无效性。</p>
<p>✔可以拿来复习和复用的笔记，而这一点对学习就够了吧在课堂或读书、看视频自学的时候这种笔记法都是成立的。</p>
<p><a href="https://imgse.com/i/ppeWJCF"><img src="https://s1.ax1x.com/2023/03/08/ppeWJCF.png" alt="ppeWJCF.png"></a></p>
<p>2、思维导图法</p>
<p>优点：</p>
<p>思维导图与和传统的学习记忆方法相比有较大的优势。</p>
<p>✔使用思维导图进行学习，可以成倍提高学习效率，增进了理解和记忆能力。</p>
<p>如通过使用关键字强迫我们在做笔记的时候就要思考句子的要点到底是什么,这使我们可以积极地倾听讲课者。而且思维导图还极大地激发我们的右脑，因为我们在创作导图的时候还使用颜色、形状和想象力。根据科学研究发现人的大脑是由两部分组成的。左大脑负责逻辑、词汇、数字,而右脑负责抽象思维、直觉、创造力和想象力。</p>
<p>✔把学习者的主要精力集中在关键的知识点上。</p>
<p>通过使用关键字强迫我们在开展业务或做笔记的时候就要思考句子的要点到底是什么，这使我们可以积极地倾听讲课者。关键知识点之间的连接线会引导您进行积极主动思考。快速系统的整合知识，可以为您的知识融会贯通创造了极其有利的条件。发展创造性思维和创新能力。发散思维是创新思维的核心。画思维导图的方法恰恰是发散思维的具体化、形象化。</p>
<p>✔思维导图具有极大的可伸缩性，它顺应了我们大脑的自然思维模式。</p>
<p>从而，可以使我们的主观意图自然地在图上表达出来。它能够将新旧知识结合起来。学习的过程是一个由浅入深的过程，在这个过程中，将新旧知识结合起来是一件很重要的事情 ，因为人总是在已有知识的基础上学习新的知识，在学习新知识时，要把新知识与原有认知结构相结合,改变原有认知结构,把新知识同化到自己的知识结构中，能否具有建立新|旧知识之间的联系是学习的关键</p>
<p><a href="https://imgse.com/i/ppeW1EV"><img src="https://s1.ax1x.com/2023/03/08/ppeW1EV.jpg" alt="ppeW1EV.jpg"></a></p>
<p>常用思维导图软件：MindMaster</p>
<p>3.麦肯锡笔记法</p>
<p>工作或者学习中遇到困难，没有思路，用这个方法解决问题一级棒</p>
<p><a href="https://imgse.com/i/ppeW84U"><img src="https://s1.ax1x.com/2023/03/08/ppeW84U.png" alt="ppeW84U.png"></a></p>
<p>“空”指的是事实，即现状如何；“雨”指的是意义，即这种现状意味着什么；而“伞”指的则是解决方案与对策，即从该意义推导出要做什么。空雨伞连起来，即是，“天空出现雨云→因此下雨的可能性很大→应当携带雨伞”。</p>
<p>我理解的黄金三分法就是，记录事实或知识内容、基于事实、知识内容来思考，思考过程中发现问题、提炼核心，进而得出思考和行动方案、解决方法、总结。这样的思维方式无论是我们用来学习知识、工作中解决问题都适用，而不是单纯的记笔记的方法。</p>
<p><a href="https://imgse.com/i/ppeW3NT"><img src="https://s1.ax1x.com/2023/03/08/ppeW3NT.png" alt="ppeW3NT.png"></a></p>
<p>4、东京大学笔记法</p>
<p>好适合用来做课堂笔记呀，读书时也适用。</p>
<p>具体操作如下：将左右两页作为一页使用，且留空“右侧页”便于日后思考。该笔记重点是尽量用自己的语言去做笔记，同时创造更深层的理解，增加思考，提高学习效率。</p>
<p><a href="https://imgse.com/i/ppeWtgJ"><img src="https://s1.ax1x.com/2023/03/08/ppeWtgJ.png" alt="ppeWtgJ.png"></a></p>
<p>5、RIA笔记法</p>
<p>主要特点是通过三个环节将知识转化为能力，是一种适用于致用类图书的高效阅读方法</p>
<p>便签读书法将阅读分为:</p>
<p>R (阅读片段)</p>
<p>I (用自己的话重述知识)</p>
<p>A1 (描述自己的相关经验)</p>
<p>A2 (以后我怎么应用)</p>
<p><a href="https://imgse.com/i/ppeWNv9"><img src="https://s1.ax1x.com/2023/03/08/ppeWNv9.png" alt="ppeWNv9.png"></a></p>
<p>✔ RIA便签读书法的操作步骤：</p>
<p>R：在读书时，遇到某一个启发片段，停下来，划出来。</p>
<p>I ：用自己的话复述原文知识，写出自己的理解，这一步达到的是理解知识本身是什么的程度。</p>
<p>A1： 写和这个知识有关的自己的经验，回顾自己有没有经历过或见到过类似的事情，情景。通过反思自己的相关经验，让这个知识真的和自己有关。</p>
<p>A2： 写下针对这个知识自己可以如何进行下一步行动，今后如何应用，让知识真的在自己的生活里发挥作用。</p>
<h2 id="怎样选择好用的记笔记的软件">怎样选择好用的记笔记的软件</h2>
<p>如果手写的笔记可以提高学习效率，那么选择合适的软件对手写的笔记进行整理总结，那么自己的知识体系就可以轻易的完成，快来看看我用的什么软件吧：</p>
<p>1、onenote非简易版</p>
<p>onenote拥有强大的笔记功能，以及与微软office软件有强大的可兼容性，但是其网络同步功能在国内是出了名的慢 。在这里我只推荐使用它的单机功能，将其打造成本地笔记本。</p>
<p><a href="https://imgse.com/i/ppehhh8"><img src="https://s1.ax1x.com/2023/03/08/ppehhh8.png" alt="ppehhh8.png"></a></p>
<p>具体的使用方法为：</p>
<ul>
<li>先打开onenote，将当前分区导出为.one文件，想再另外记笔记的时候，只用复制这个文件，改文件名后，再更改里面的内容就可以了。</li>
</ul>
<p><a href="https://imgse.com/i/ppehWAP"><img src="https://s1.ax1x.com/2023/03/08/ppehWAP.png" alt="ppehWAP.png"></a></p>
<p>2、Microsoft edge 及插件super copy</p>
<p>记笔记的时候想偷个懒？或者看到别人记的笔记太好了，想拷贝过来？这时候edge浏览器的插件super copy就能让别人的笔记乖乖地拷贝到自己的文档里（包括图片）。</p>
<p><a href="https://imgse.com/i/ppe5Zaq"><img src="https://s1.ax1x.com/2023/03/08/ppe5Zaq.png" alt="ppe5Zaq.png"></a></p>
<p>使用方法很简单，打开浏览器里的插件super copy，将黑白的点成彩色的，浏览器当前页面的文件就可以复制了。</p>
<p>3、markdown编辑器typora</p>
<p>想要记笔记，学会使用markdown工具才更方便，这里推荐的软件就是它了：typora</p>
<p><a href="https://imgse.com/i/ppe5gFP"><img src="https://s1.ax1x.com/2023/03/08/ppe5gFP.png" alt="ppe5gFP.png"></a></p>
<p>简洁	方便  高效</p>
<p>谁用谁知道</p>
<p>使用方法自行摸索去吧</p>
<p>4、网站github及hexo</p>
<p>搭建一个博客可以时间，按类型标签总结自己的知识，可谓在线记录查阅之神器。</p>
<p><a href="https://imgse.com/i/ppeItmj"><img src="https://s1.ax1x.com/2023/03/08/ppeItmj.png" alt="ppeItmj.png"></a></p>
<p><a href="https://imgse.com/i/ppeIwt0"><img src="https://s1.ax1x.com/2023/03/08/ppeIwt0.png" alt="ppeIwt0.png"></a></p>
<p>这个需要摸索</p>
<p>5、图床工具imgse</p>
<p>有了博客，必然要用图床喽这里推荐使用路过图床，这是个网站哟！</p>
<p><a href="https://imgse.com/i/ppeIJXQ"><img src="https://s1.ax1x.com/2023/03/08/ppeIJXQ.png" alt="ppeIJXQ.png"></a></p>
<p>6、思维导图工具markmap</p>
<p>思维导图是更适合人进行记忆的工具，既然用到了markdown工具，那么怎样才能将编写的markdown&quot;变“成思维导图呢？这里推荐使用markmap工具，生成思维导图只用分分钟。</p>
<p><a href="https://imgse.com/i/ppeodDH"><img src="https://s1.ax1x.com/2023/03/08/ppeodDH.png" alt="ppeodDH.png"></a></p>
]]></content>
      <categories>
        <category>experience summary</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>experience</tag>
      </tags>
  </entry>
  <entry>
    <title>无法安装打印机代码为0x00000c1（打印机驱动安装失败处理方法）</title>
    <url>/2023/03/05/%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85%E6%89%93%E5%8D%B0%E6%9C%BA%E4%BB%A3%E7%A0%81%E4%B8%BA0x00000c1%EF%BC%88%E6%89%93%E5%8D%B0%E6%9C%BA%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85%E5%A4%B1%E8%B4%A5%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p>
<p><a href="http://leiyu-code.github.io">leiyu-code.github.io</a></p>
<p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p>
<h2 id="无法安装打印机代码为0x00000c1（打印机驱动安装失败处理方法）">无法安装打印机代码为0x00000c1（打印机驱动安装失败处理方法）</h2>
<p><strong>打印机不能安装的解决方法为：删除计算机注册表里的打印驱动项及删除计算机系统里的打印驱动目录，然后再重新安装打印机驱动</strong></p>
<p><em><strong>系统错误代码为：0x00000c1</strong></em></p>
<p><strong>具体步骤为：</strong></p>
<p><strong>1、停止服务中的Print Spool服务</strong></p>
<p><strong>2、删除注册表里设备项里的Version-3注册表项</strong></p>
<p><strong>3、删除drivers\x64或w32x86里名字是3的文件夹</strong></p>
<p><strong>4、重启电脑后重新安装打印机驱动</strong></p>
<p><em><strong>需要注意的是删除目录最好在pe环境下删除，不然会有一些使用的中的文件删除不了</strong></em></p>
<span id="more"></span>
<p>我们新购买的打印机一般都会随机配备打印机驱动光盘，一般来说我们只要按照光盘里面的自动安装程序直接点击“下一步”就能完成打印机驱动的安装及打印机的连接。但是因为各种原因，然而安装打印机并没有那么容易，那么要是打印机驱动安装失败了该怎么办呢？下面我来教你如何解决打印机驱动安装失败的办法！</p>
<p>第一步：首先我们在打开的服务窗口中找到Print Spool服务项，然后右键点击该项，然后在弹出菜单中选择“停止”菜单项，先停止该服务，如下图所示</p>
<p><a href="https://imgse.com/i/ppE2A6P"><img src="https://s1.ax1x.com/2023/03/05/ppE2A6P.jpg" alt="ppE2A6P.jpg"></a></p>
<p>第二步：然后接着在运行窗口中输入命令regedit，再点击确定按钮，如下图所示</p>
<p><a href="https://imgse.com/i/ppE2PfA"><img src="https://s1.ax1x.com/2023/03/05/ppE2PfA.jpg" alt="ppE2PfA.jpg"></a></p>
<p>第三步：然后在打开的注册表编辑器窗口中定位到HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Print\Environments\Windows NT x86\Drivers\Version-3，如果您是64位系统的话，需定位到：HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Print\Environments\Windows x64\Drivers\Version-3，如下图所示</p>
<p><a href="https://imgse.com/i/ppE2klt"><img src="https://s1.ax1x.com/2023/03/05/ppE2klt.jpg" alt="ppE2klt.jpg"></a></p>
<p>第四步：再右键点击Version-3这个注册表项，然后在弹出菜单中选择“删除”菜单项，把该注册表项删除，如下图所示</p>
<p><a href="https://imgse.com/i/ppE2EOf"><img src="https://s1.ax1x.com/2023/03/05/ppE2EOf.jpg" alt="ppE2EOf.jpg"></a></p>
<p>第五步：然后接着我们再打开文件资源管理器，然后定位到C:\Windows\System32\spool\drivers\w32x86\3，把该文件夹下的所有文件全部删除。如果您是64位系统，需定位到C:\Windows\System32\spool\drivers\x64\3 文件夹下，如下图所示</p>
<p><a href="https://imgse.com/i/ppE2CYd"><img src="https://s1.ax1x.com/2023/03/05/ppE2CYd.jpg" alt="ppE2CYd.jpg"></a></p>
<p>第六步：最后再次打开服务窗口，然后重新启动Print Spool服务，这时再次安装打印机驱动程序即可，如下图所示</p>
<p><a href="https://imgse.com/i/ppE2FSI"><img src="https://s1.ax1x.com/2023/03/05/ppE2FSI.jpg" alt="ppE2FSI.jpg"></a></p>
<p>你学会了吗？以后如果遇到打印机驱动安装不了就可以这样试试了！要想了解更多电脑小知识，可以点击关注我哦，里面有更多关于电脑的各种问题解决及系统的安装教程的文章及视频哦。</p>
<p>来自 <a href="https://www.dnzp.com/jy/202301/77538.html">https://www.dnzp.com/jy/202301/77538.html</a></p>
]]></content>
      <categories>
        <category>worknote</category>
      </categories>
      <tags>
        <tag>Print</tag>
        <tag>drive</tag>
      </tags>
  </entry>
  <entry>
    <title>网站工具推荐-博客图床路过</title>
    <url>/2023/03/02/%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90-%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%E8%B7%AF%E8%BF%87/</url>
    <content><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p>
<p><a href="http://leiyu-code.github.io">leiyu-code.github.io</a></p>
<p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p>
<p><em><strong>写博客都需要图片，一般图片都保存在哪儿呢？不可能都保存在目录或博客里，这样就需要用到图床工具，好用的图床工具有很多，这里我推荐使用路过图床，更新后的网站域名是<a href="https://imgse.com/">路过图床 - 免费图片上传, 专业图片外链, 免费公共图床 (imgse.com)</a>，非常方便好用</strong></em></p>
<span id="more"></span>
<h2 id="图床用途">图床用途</h2>
<p>保存图片</p>
<p>生成图片外链</p>
<h2 id="图床特点">图床特点</h2>
<p>路过图床以「无限空间」和「无限流量」作为最大的亮点，同时具有全球 CDN 加速以确保高速、稳定。在上传测试中，GIF 上传耗时约 5 秒。路过图床较为繁琐的一点是，它会先显示预览和编辑，需要进行二次确认。<br>
在路过图床上传照片时，你可以对其进行裁切，或是设定自动删除的时限。除了生成原图链接外，路过图床还会为你生成缩略图的链接，以满足不同需求。这样一来，你既可以分享原图以求图片精度，也可以分享缩略度以求访问速度。路过图床仅对单次上传的大小做出了限制。游客只能上传小于 5M 的图片，注册后可上传 10M 内的图片，适合作为主力图床使用。使用种类而言，路过图床 算得上一款比较优秀的图床工具。</p>
<h2 id="图床使用方法">图床使用方法</h2>
<p>打开浏览器，<a href="http://xn--imgse-ep5h875a3bzhw60pl34f.com">在地址栏输入imgse.com</a></p>
<p><a href="https://imgse.com/i/ppFfOde"><img src="https://s1.ax1x.com/2023/03/02/ppFfOde.md.png" alt="ppFfOde.md.png"></a></p>
<p>打开浏览器后，注册帐号，注册完后，右上角会显示帐户名。</p>
<p><a href="https://imgse.com/i/ppFhGFJ"><img src="https://s1.ax1x.com/2023/03/02/ppFhGFJ.png" alt="ppFhGFJ.png"></a></p>
<p>点击上传按钮，上传图片</p>
<p><a href="https://imgse.com/i/ppFhbpn"><img src="https://s1.ax1x.com/2023/03/02/ppFhbpn.png" alt="ppFhbpn.png">.</a></p>
<p><a href="https://imgse.com/i/ppF49h9"><img src="https://s1.ax1x.com/2023/03/02/ppF49h9.png" alt="ppF49h9.png"></a></p>
<p>上传图片完成后，会显示很多链接选项，我用的是markdown，移动到markdown代码的后面，会显示copy按钮，点击它。然后移动到markdown文档中，粘贴链接，在markdown文件里就可以显示出图床里的图片了。</p>
<p>这样我们就能在网站、博客里省去大量的空间存放图片，也不用在自己的电脑里辛辛苦苦地维护图片了，用的时候直接上链接喽！大家快去试试吧！</p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>图床</tag>
      </tags>
  </entry>
  <entry>
    <title>修改Hosts解决Github访问失败</title>
    <url>/2023/03/02/%E4%BF%AE%E6%94%B9Hosts%E8%A7%A3%E5%86%B3Github%E8%AE%BF%E9%97%AE%E5%A4%B1%E8%B4%A5/</url>
    <content><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p>
<p>leiyu-code.github.io</p>
<p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p>
<h2 id="修改Hosts解决Github访问失败"><a href="#修改Hosts解决Github访问失败" class="headerlink" title="修改Hosts解决Github访问失败"></a>修改Hosts解决Github访问失败</h2><hr>
<p><em><strong>国内的网络登陆github网站时，有时候会出现登录不上的情况，这种情况往往是CND域名受到dns污染，最好的解决办法是利用系统的host文件跳过dns解析直接访问域名对应的ip地址或者用vpn解决github访问失败的问题</strong></em></p>
<span id="more"></span>

<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>具体方法是：修改系统的「Hosts」，跳过 DNS 解析直接访问域名对应 IP 地址</p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>国内网络访问 Github 速度过慢的原因有许多，但其中最直接和原因是其 CND 域名遭到 DNS 污染，导致我们无法连接使用 GitHub 的加速服务，因此访问速度缓慢。</p>
<ul>
<li>CDN「Content Delivery Network」，即内容分发网络，依靠部署在各地的边缘服务器，平衡中心服务器的负荷，就近提供用户所需内容，提高响应速度和命中率。DNS 污染，是指一些刻意或无意制造出来的数据包，把域名指向不正确的 IP 地址，阻碍了网络访问。</li>
</ul>
<ul>
<li><p>我们默认从目标网址的最近 CDN 节点获取内容，但当节点过远或 DNS 指向错误时，就会操成访问速度过慢或无法访问的问题。</p>
</li>
<li><p>访问慢、无法加载还是无法通讯？</p>
<h4 id="含义不一样："><a href="#含义不一样：" class="headerlink" title="含义不一样："></a>含义不一样：</h4></li>
<li><p>访问慢：连接延迟高，内容能够被加载但需要较长的时间。</p>
</li>
<li><p>无法加载：浏览器无法打开网址。</p>
<p>无法通讯：无法进行直接的网络通讯，包括了上一种情况。</p>
<h4 id="三种情况的原因："><a href="#三种情况的原因：" class="headerlink" title="三种情况的原因："></a>三种情况的原因：</h4></li>
<li><p>访问慢：服务器或 CDN节点的地理位置相对较远，难以物理超度。注意这里的表现是延迟高，不一定是每秒传输速度慢。</p>
</li>
<li><p>无法加载：可能由于长时间的未响应，即访问慢的情况，导致浏览器判定无法加载内容；可能由于网址对应内容不能被直接访问，即无可访问内容或无权限访问。</p>
</li>
<li><p>无法通讯：这类情况往往是 IP解析错误，即遭受 DNS 污染；否则就是 IP 服务器出现了内部错误。</p>
<h3 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h3></li>
<li><p>可以利用两个工具来判断不同域名或 IP 地址是上述那种情况。笔者以github.com为例，实际操作一遍检测的过程，看看是什么情况：</p>
</li>
<li><p>首先利用网络上的ping工具，例如这个(<a href="http://ping.chinaz.com/)%E5%9C%B0%E5%9D%80%EF%BC%8C%E6%A3%80%E6%B5%8B%E7%BD%91%E5%9D%80%E3%80%81IP%E5%9C%B0%E5%9D%80%E7%9A%84%E9%80%9A%E8%AE%AF%E6%83%85%E5%86%B5%E3%80%82%E8%BE%93%E5%85%A5%E8%A6%81%E6%A3%80%E6%B5%8B%E7%9A%84%E7%BD%91%E5%9D%80github.com%EF%BC%8C%E7%82%B9%E5%87%BB%E3%80%8CPing%E6%A3%80%E6%B5%8B%E3%80%8D%E3%80%82%E5%B7%A5%E5%85%B7%E6%8F%90%E4%BE%9B%E7%9A%84%E6%9C%8D%E5%8A%A1%E6%98%AF%E5%88%A9%E7%94%A8%E8%87%AA%E5%B7%B1%E5%88%86%E5%B8%83%E5%9C%A8%E5%90%84%E5%9C%B0%E7%9A%84%E7%BD%91%E7%BB%9C%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%AC%E6%9C%BAping%E5%B7%A5%E5%85%B7%EF%BC%8C%E6%89%A7%E8%A1%8C%E5%AF%B9%E7%BD%91%E5%9D%80%E7%9A%84ping%E6%93%8D%E4%BD%9C%EF%BC%8C%E6%B1%87%E6%80%BB%E7%BB%93%E6%9E%9C%EF%BC%8C%E7%BB%9F%E8%AE%A1%E5%93%8D%E5%BA%94%E7%BD%91%E5%9D%80%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8IP%E3%80%82">http://ping.chinaz.com/)地址，检测网址、IP地址的通讯情况。输入要检测的网址github.com，点击「Ping检测」。工具提供的服务是利用自己分布在各地的网络节点的本机ping工具，执行对网址的ping操作，汇总结果，统计响应网址的服务器IP。</a></p>
</li>
<li><p>检测结果如下图示。共计 106 个检测点，其中接受响应速度最快的节点在加拿大，目标服务器对其响应时间为 14ms；最慢在中国香港，响应时间 243ms。在成功访问的所有节点中，目标服务器的平均响应时间是163.5ms。地图与颜色响应了国内不同省市的访问时间，红色说明访问超时，白色说明没有参与节点；约偏向绿色则响应时间越短。右侧还有一个统计表。这里的情况是：国内节点无法ping通github.com，即无法建立网络通讯。</p>
<p>注意地图下方有一个独立 IP的统计框，里面列举了所有节点被响应的 IP 地址。我们知道，网址到 IP 需要经过 DNS 解析，这里呈现的便是各个检测节点，经过默认的 DNS解析得到的对应 IP 地址的汇总。事实上，你连接的网络也有默认或设定的 DNS，也会有一个解析得到的目标 IP，如果无法访问这个 IP 地址，就意味着你当前的网络无法访问github.com。</p>
<p>再往下便是具体的每个节点的响应信息。</p>
</li>
<li><p>网络上的ping工具能为我们提供三个重要的信息：首先，如果存在ping通的节点，那么 IP 服务器没有宕机；其次，响应 IP 汇总表提供了所有可能的服务器与 CDN 的 IP 地址；最后，具体信息部分可以点击响应时间排序，我们可以找到响应最快的服务器 IP。</p>
</li>
<li><p>接着我们使用自己电脑的ping工具来测试网络。打开终端，输入ping [ip  address]，替换其中的IP 地址或域名即可。我们不ping域名，那样会ping向设置的 DNS 解析出来的 IP 地址。我们ping上一步得到的响应最快的服务器。</p>
</li>
<li><p>ping 140.82.114.4 <em># 这个IP是响应最快的，来自加拿大</em><br>ping 192.30.253.112 <em># 这个IP也可以响应，来自中国香港</em></p>
</li>
<li><p>虽然存在丢包的情况，但可以ping通。延迟较高。</p>
</li>
<li><p>我们再ping上一步中连接超时的节点，对应的响应 IP。</p>
</li>
<li><p>ping 13.229.188.59 <em>来自江苏宿迁[电信]，响应超时</em></p>
</li>
<li><p>预料之中，现在就无法ping通了。</p>
</li>
<li><p>这一步说明，如果我们网络设置的 DNS 解析出的github.com的 IP 无法在本机ping通，我们便不能够访问该网址。这也是后面通过修改系统 Hosts 文件来解决访问失败问题的原因。</p>
</li>
<li><p>最后我们可以用浏览器尝试直接打开ping通的 IP 地址。其结果是：140.82.114.4无法被浏览器加载；192.30.253.112可以加载出 Github 首页。</p>
<h3 id="检测结果"><a href="#检测结果" class="headerlink" title="检测结果"></a>检测结果</h3></li>
<li><p>上一步操作的结果就是我们判断三种情况的依据。</p>
</li>
<li><p>通过192.30.253.112响应的github.com，属于「访问慢」，可以连接但延迟较高；IP      可以被浏览器加载。</p>
<p>通过140.82.114.4响应的github.com，同样属于「访问慢」；但被浏览器直接加载时，属于「无法加载」，即可以ping通但无法直接访问。</p>
<p>通过13.229.188.59响应的github.com，属于「无法通讯」，无法建立链接。</p>
<p><em><strong>知识点：域名，网址与 IP 地址</strong></em></p>
<p>「IP地址」：每个连接到互联网的主机都会被分配一个 IP 地址，用来唯一标识该主机，节点之间的访问通过 IP 地址来进行，形如192.30.253.112。</p>
<p>「域名」：IP地址使用数字标识，使用时不好记忆书写，因此在 IP 地址的基础上又发展出一种符号化的地址方案，来代替数字型的 IP地址。每一个符号化的地址都与特定的 IP 地址对应。IP 地址相对应的字符型地址，就被称为域名。形如github.com。</p>
<p>「网址」：URL「统一资源定位符」，俗称为网址。浏览器地址栏输入的字符串，服务器上储存文件的位置。格式为：&lt;协议&gt;:&#x2F;&#x2F;&lt;域名或IP&gt;:&lt;端口&gt;&#x2F;&lt;路径&gt;。&lt;协议&gt;:&#x2F;&#x2F;&lt;域名或IP&gt;是必需的，&lt;端口&gt;&#x2F;&lt;路径&gt;有时可省略。形如<a href="https://www.github.com/wootommy%E3%80%82">https://www.github.com/wootommy。</a></p>
<p>「DNS」：域名虽然便于人们记忆，但节点之间通过      IP 地址通讯。两者之间的转换工作称为域名解析，域名解析需要由专门的域名解析服务器来完成，即 DNS 服务器。域名的最终指向是 IP 地址。</p>
<p>注意，IP 地址和域名是一对多的关系。一个 IP 可以对应多个不同的域名，但是一个域名只能对应一个 IP 地址。就跟人的名字一样，你可以有多个名字。但这些名字都是指的你。</p>
<p>然而我们利用网络工具测试时，发现github.com有多个响应 IP 服务器。这就是开头提到的 CDN 服务。多个平行的服务器响应，均匀了中心服务器的负载，使得网络通讯更加迅速。</p>
<p>现实的情况是，github.com启用的 CDN 节点遭到了 DNS 污染，错误的 IP 指向，包括错误 IP、响应过慢的 IP，都会造成我们访问 Github 失败。</p>
<h4 id="解决方法：修改host文件"><a href="#解决方法：修改host文件" class="headerlink" title="解决方法：修改host文件"></a>解决方法：修改host文件</h4><p>再总结一下 Github 访问失败或者缓慢的原因：本机网络设置的 DNS 服务器解析 Github 相关域名到遭受污染的 IP 地址，这些 IP 地址要么本身无法访问，要么节点过远，从而导致了访问失败或者速度缓慢。</p>
<p><em><strong>修改方案</strong></em></p>
<p>修改本机 Hosts 文件，主动建立域名与 IP 的映射关系，访问到这些域名时直接使用 Hosts 指定的 IP，绕过 DNS 解析。</p>
<p>修改网络的 DNS 服务器，换到能够解析出合适 IP 的 DNS 服务器。</p>
<p>显然第一种方案更加方便。因为 DNS 服务器储存的映射关系是动态更新的，无法直接控制。直接修改本机 Hosts 文件，锁定域名对应的 IP，更加有效方便。当然，Hosts 文件的作用就是绑定域名与 IP 的映射关系。</p>
<p><strong>实际修改host文件的方法</strong></p>
<p><em><strong>macOS 修改 Hosts 文件</strong></em></p>
<p>打开终端，使用 vim 修改 Hosts文件：</p>
<p>sudo vi &#x2F;etc&#x2F;hosts</p>
<p>操作 vim 可以简单百度一下，添加Github 相关域名的绑定。</p>
<p>刷新网络 DNS 缓存：</p>
<p>sudo killall -HUP mDNSResponder</p>
<p>macOS 自带sudo与vim，当然，可以通过 Homebrew 安装最新版本的vim：</p>
<p>brew install vim</p>
<p><strong>Windows 修改 Hosts 文件</strong></p>
<p>定位到C:\Windows\System32\drivers\etc\hosts，直接右键用记事本编辑hosts文件</p>
<p>打开 cmd，使用 vim 修改Hosts 文件：</p>
<p>sudo vim C:\Windows\System32\drivers\etc\hosts</p>
<p>操作 vim 可以简单百度一下。添加Github 相关域名的绑定，修改如上图所示，具体值见最后。</p>
<p>刷新网络 DNS 缓存：</p>
<p>ipconfig &#x2F;flushdns</p>
<p>Windows 不自带sudo与vim，可以通过 Scoop 安装：</p>
<p>scoop install sudo vim</p>
<h3 id="hosts文件里需要添加的ip及域名"><a href="#hosts文件里需要添加的ip及域名" class="headerlink" title="hosts文件里需要添加的ip及域名"></a>hosts文件里需要添加的ip及域名</h3><p>列出当前使用的 Github 相关域名比较合适的 IP 值，笔者会定期维护更新。其中的设置可以解决github.com头像无法显示的问题：</p>
<p>更新日期：20220222</p>
<p>#Github Hosts<br>#domain: github.com<br>140.82.113.4 github.com<br>140.82.114.9 nodeload.github.com<br>140.82.112.5 api.github.com<br>140.82.112.10 codeload.github.com<br>185.199.108.133 raw.github.com<br>185.199.108.153 training.github.com<br>185.199.108.153 assets-cdn.github.com<br>185.199.108.153 documentcloud.github.com<br>140.82.114.17 help.github.com</p>
<p>#domain: githubstatus.com<br>185.199.108.153 githubstatus.com</p>
<p>#domain: fastly.net</p>
<p>199.232.69.194 github.global.ssl.fastly.net</p>
<p>#domain: githubusercontent.com<br>185.199.108.133 raw.githubusercontent.com<br>185.199.108.154 pkg-containers.githubusercontent.com<br>185.199.108.133 cloud.githubusercontent.com<br>185.199.108.133 gist.githubusercontent.com<br>185.199.108.133 marketplace-screenshots.githubusercontent.com<br>185.199.108.133 repository-images.githubusercontent.com<br>185.199.108.133 user-images.githubusercontent.com<br>185.199.108.133 desktop.githubusercontent.com<br>185.199.108.133 avatars.githubusercontent.com<br>185.199.108.133 avatars0.githubusercontent.com<br>185.199.108.133 avatars1.githubusercontent.com<br>185.199.108.133 avatars2.githubusercontent.com<br>185.199.108.133 avatars3.githubusercontent.com<br>185.199.108.133 avatars4.githubusercontent.com<br>185.199.108.133 avatars5.githubusercontent.com<br>185.199.108.133 avatars6.githubusercontent.com<br>185.199.108.133 avatars7.githubusercontent.com<br>185.199.108.133 avatars8.githubusercontent.com<br><em># End of the section</em></p>
<p>不一定保证每一项都是正确、有效的，但目前来说笔者实测能够稳定访问 Github。欢迎大家留言讨论，指正或者建议更好用的 IP 地址。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>studynote</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>windows基础</tag>
      </tags>
  </entry>
  <entry>
    <title>企业中怎样设置共享打印机</title>
    <url>/2023/03/01/%E4%BC%81%E4%B8%9A%E4%B8%AD%E6%80%8E%E6%A0%B7%E8%AE%BE%E7%BD%AE%E5%85%B1%E4%BA%AB%E6%89%93%E5%8D%B0%E6%9C%BA/</url>
    <content><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p>
<p><a href="http://leiyu-code.github.io">leiyu-code.github.io</a></p>
<p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p>
<p><strong>这次带大家了解一下在企业中怎么共享打印机，步䯅分为：</strong></p>
<p><strong>1、打开windos系统共享</strong></p>
<p><strong>2、安装打印服务器驱动程序</strong></p>
<p><strong>3、共享打印机</strong></p>
<p><strong>4、打印机客户端连接打印机</strong></p>
<p><strong>5、32位操作系统和64位操作系统怎样互相连接共享打印机</strong></p>
<p><strong>6、带网络接口的打印机的设置及连接</strong></p>
<p><em><strong>总结：企业中最好选择带网络端口的打印机，设置和维护都很方便</strong></em></p>
<span id="more"></span>
<p><strong>打开windows系统共享</strong></p>
<p>自动开启windows服务中的server服务和print spooler服务</p>
<p>有时候打印有问题，就需要重启print spooler服务</p>
<p><a href="https://imgse.com/i/ppiYFjf"><img src="https://s1.ax1x.com/2023/03/01/ppiYFjf.png" alt="ppiYFjf.png"></a><br>
<a href="https://imgse.com/i/ppiYAu8"><img src="https://s1.ax1x.com/2023/03/01/ppiYAu8.png" alt="ppiYAu8.png"></a></p>
<p>利用网友们编写好的打印机共享工具一键开启打印机共享，服务端电脑<em><strong>没有密码的运行简单共享，有密码的运行有密码的共享</strong></em>重启电脑后系统的设置就好了</p>
<p><a href="https://imgse.com/i/ppitMIH"><img src="https://s1.ax1x.com/2023/03/01/ppitMIH.png" alt="ppitMIH.png"></a></p>
<p><strong>安装打印机驱动及共享打印机</strong></p>
<p>把数据线连接上电脑</p>
<p>下载一个驱动管家或者直接下载对应的打印机驱动安装好就可以连上电脑了。</p>
<p>下面着重讲如何共享打印机。</p>
<p>1.我们先找到要共享的打印机，我们按（win+i）<strong>打开Windows设置，在设备里面</strong>选择打印机**。如果是win7系统直接在控制面板里面选择**设备和打印机即可。</p>
<p><a href="https://imgse.com/i/ppiNJh9"><img src="https://s1.ax1x.com/2023/03/01/ppiNJh9.png" alt="ppiNJh9.png"></a></p>
<p>2.打开打印机之后，安装好的打印机就会在下面列表出现，<strong>win7</strong>系或者<strong>xp</strong>系统截图如下：</p>
<p><a href="https://imgse.com/i/ppiNU6x"><img src="https://s1.ax1x.com/2023/03/01/ppiNU6x.png" alt="ppiNU6x.png"></a></p>
<p><strong>win10</strong>或<strong>win11</strong>系统截图如下，无论哪种界面都大同小异，<strong>win10</strong>系统我没有连接打印机所以看不到，但方法一致：</p>
<p><a href="https://imgse.com/i/ppiUIr6"><img src="https://s1.ax1x.com/2023/03/01/ppiUIr6.png" alt="ppiUIr6.png"></a></p>
<p>3.然后<strong>鼠标右击，选择共享选项卡</strong>，则出现共享界面，<strong>win7</strong>或者<strong>xp</strong>如下图：</p>
<p><a href="https://imgse.com/i/ppiU7VO"><img src="https://s1.ax1x.com/2023/03/01/ppiU7VO.png" alt="ppiU7VO.png"></a></p>
<p><strong>win10</strong>系统在打印机列表里，点击先管理，在打印机属性，选择共享选项卡。</p>
<p><a href="https://imgse.com/i/ppiUjxI"><img src="https://s1.ax1x.com/2023/03/01/ppiUjxI.png" alt="ppiUjxI.png"></a></p>
<p>4.点击共享这台打印机，<strong>共享名自己可以随便起名或者默认即可</strong>，然后点击确定按钮，到此打印机共享完成。</p>
<p><strong>客户端设置打印机</strong></p>
<p>1.注意，到了关键步骤了，打印机我们共享了之后，局域网内其他电脑如何访问呢？其实很简单，只要我们同时按**（<strong>win+r</strong>），<strong>在弹出的运行对话框里输入</strong>\\IP**地址，就会出现共享列表，如下图：</p>
<p><a href="https://imgse.com/i/ppiaARs"><img src="https://s1.ax1x.com/2023/03/01/ppiaARs.png" alt="ppiaARs.png"></a></p>
<p>2.只里面是双斜杠，一定不要错，后面加上ip地址（这个ip地址是你共享打印机的那台电脑的ip地址），点击确定，跳出共享的打印机，如下：</p>
<p><a href="https://imgse.com/i/ppiauZT"><img src="https://s1.ax1x.com/2023/03/01/ppiauZT.png" alt="ppiauZT.png"></a></p>
<p>这时，我们只要双击箭头所指的共享打印机就可以了，如果电脑有密码，输入电脑的密码，即可完成共享打印机的连接。</p>
<p>打印机共享和文件共享方式方法一样,而且打印机共享的时候需要你的电脑在同一个局域网内。</p>
<p><strong>32位与64位共享打印机的安装</strong></p>
<p>共享完打印机后，服务器的打印机驱动必须安装32位驱动或64位驱动</p>
<p><a href="https://imgse.com/i/ppiw8Dx"><img src="https://s1.ax1x.com/2023/03/01/ppiw8Dx.png" alt="ppiw8Dx.png"></a><br>
<a href="https://imgse.com/i/ppiw3K1"><img src="https://s1.ax1x.com/2023/03/01/ppiw3K1.png" alt="ppiw3K1.png"></a></p>
<p><em><strong>特别注意的是：有些打印机驱动在安装的过程中需要ntprint.inf驱动核心引导，要注意区别安装！</strong></em></p>
<p><strong>带网络接口的打印机的设置</strong></p>
<p>1、网线和交换机连接好打印机。</p>
<p>2、在打印机的设置选项里给打印机设置IP地址。</p>
<p>3、在电脑端安装驱动程序，选择网络打印机，过一会儿就会显示局域网里的所有网络打印机，选择本办公室的打印机，一路下一步，就能在客户端上完成网络打印机的安装。</p>
<p><em><strong>结合以上经验，公司里的打印机如果是有网络接口和无线功能的话，安装维护会更加方便。如果只有usb接品和Lpt打印端口的话，必须要在打印机服务器上安装32位和64位驱动，安装维护比较麻烦</strong></em></p>
<p>共享工具和试验驱动在以下链接里，快去下来试试吧！</p>
<p>共享打印机 <a href="https://www.aliyundrive.com/s/EFxovCT1gyE">https://www.aliyundrive.com/s/EFxovCT1gyE</a> 点击链接保存，或者复制本段内容，打开「阿里云盘」APP ，无需下载极速在线查看，视频原画倍速播放。</p>
]]></content>
      <categories>
        <category>worknote</category>
      </categories>
      <tags>
        <tag>windows共享打印机</tag>
        <tag>windows技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>转载-内网arp欺骗与dns欺骗</title>
    <url>/2022/06/03/%E8%BD%AC%E8%BD%BD-%E5%86%85%E7%BD%91arp%E6%AC%BA%E9%AA%97%E4%B8%8Edns%E6%AC%BA%E9%AA%97/</url>
    <content><![CDATA[<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p>
<p>leiyu-code.github.io</p>
<p><a href="https://linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p>
<p><strong>一.实验目的</strong></p>
<p>DNS欺骗即域名信息欺骗是最常见的DNS安全问题。域名系统(Domain Name System,DNS)是一个将Domain Name和IP Address进行互相映射的Distributed Database。DNS是网络应用的基础设施，它的安全性对于互联网的安全有着举足轻重的影响。但是由于DNS Protocol在自身设计方面存在缺陷，安全保护和认证机制不健全，造成DNS自身存在较多安全隐患，导致其很容易遭受攻击。很多专家就DNS Protocol的安全缺陷提出了很多技术解决方案。例如IETF提出的域名系统安全协议(Domain Name System Security,DNSSEC)，其目标就在于解决这些安全隐患。这个Protocol增加了安全认证项目，增强了Protocol自身的安全功能。但是新增加的安全机制需要占用更多的系统和网络资源，同时要升级Database和System Manggament Software,这些基于DNSSEC协议的软件还不成熟，距离普及应用还有较长时间。目前，常见的措施是定期升级DNS软件和加强相关的安全配置，禁用不安全的端口等。以下对以侦听为基础的DNS ID欺骗(DNS ID spoofing)进行了探讨，并提出了相关的防护解决方案。通过练习掌握工具的使用，理解实施过程，掌握防范措施。</p>
<p>上面理论性的东西可以选择性忽略，都是这下面的原理就要详细了解了，不然看着下面的操作步骤可能会很迷…</p>
<span id="more"></span>

<p><strong>二.实验原理</strong></p>
<blockquote>
<p>因为局域网DNS欺骗需要ARP欺骗的配合 所以我这里简单解释一下arp欺骗的原理：有一个欺骗者（主机A）说自己是网关，骗将受害者（主机B）发给真正网关的数据转发给主机A，然后数据经由主机A后再发送给真正的网关，而后主机A又告诉网关它就是主机B（欺骗了网关），骗将本来应该发给B的数据发给主机A（欺骗者），然后由A转发给主机B。&#x2F;&#x2F;就是相当于把主机A当成中间人，把主机B与网关的所有通讯全部要经过主机A，这样子，主机A就可以对主机B的数据信息随意修改然后在转发给网关从而达到了欺骗的效果</p>
</blockquote>
<p><strong>这里简述一下ARP协议当一台主机和另一台主机通信，要知道目标的IP地址，但是在局域网中传输数据的网卡却不能直接识别IP地址，所以用ARP解析协议将IP地址解析成MAC地址。ARP协议的基本功能就是通过目标设备的IP地址，来查询目标设备的mac地址</strong></p>
<p>一条简单的ARP命令：<br>arpspoof -i eth0(网卡)  -t  目标机ip  本地局域网关</p>
<p>1.如arpspoof -i eth0 -t 192.168.159.132  192.168.159.2<br>  这条命令的意思是：发一个arp数据包告诉”192.168.159.132”这台主机，<br>  “192.168.159.2”（网关） 这个IP的MAC就是‘我’攻击者本机的MAC地址，欺骗了目标主机,达成了单向的欺骗，如果没开流量转发可以让目标单纯的断网</p>
<ol start="2">
<li>arpspoof -i eth0(网卡)  -t   本地局域网关   目标机ip<br>arpspoof -i eth0 -t 192.168.159.2 192.168.159.132<br>而这条命令的意思跟上面一样，只不过是在欺骗网关罢了 告诉”192.168.159.2”（网关），<br> 告诉网关”192.168.159.132”这个IP的MAC就是攻击者本机的MAC地址         &#x2F;&#x2F;欺骗到了网关，但是没有欺骗了目标主机，两条组合起来就可以达到双向欺骗<br>1234567891011</li>
</ol>
<p>而DNS欺骗是这样一种中间人攻击形式：局域网内的主机访问一个网站时，会向dns服务器发送dns请求包，这里的dns服务器一般由网关主机担任，dns服务器收到请求后，查找自己的dns缓存表，如果有就返回，没有就返回该域名的根域名服务器，主机再向根域名服务器查询。把自己伪装成本局域网的dns服务器，从而达到域名劫持的效果，它是攻击者冒充域名服务器的一种欺骗行为，它主要用于向主机提供错误DNS信息，当用户想要尝试浏览网页，例如去登录百度的网址：<a href="http://www.baidu.com/">www.baidu.com</a> (百度主机IP为：14.215.177.39)而实际上登录百度网址的IP是被替换掉的<a href="http://www.baidu.com/">www.baidu.com</a>(Kali主机IP: 92.168.42.171)，这时候用户上网就只能看到攻击者的主页，而不是用户想要取得的网站的主页了，这个网址是攻击者用以窃取网上银行登录证书以及帐号信息的假冒网址，DNS欺骗其实并不是真的“黑掉”了对方的网站，而是冒名顶替、招摇撞骗罢了</p>
<p><strong>三、实验环境</strong></p>
<blockquote>
<p>测试机：Windows7虚拟机一台 ip: 192.168.42. 119攻击机：Kali linux 虚拟机一台 ip: 92.168.42.171网关：192.168.42.129工具：kalil inux 渗透测试平台网络环境：手机WiFi网络USB共享，同一局域网，桥接网络模式</p>
</blockquote>
<p><strong>四、实验内容（实验过程）</strong></p>
<ul>
<li><strong>一.信息收集</strong></li>
</ul>
<p>老方法，用nmap开路，先收集靶机的详细信息，用nmap端口扫描工具扫描局域网内存活的主机（这里扫描129这个网段）</p>
<p> 命令:  nmap -Pn -A -o 192.168.42.129&#x2F;24<br>        nmap  -O 是远程检测操作系统和软件<br>        -Pn      无ping扫描，可以绕过一般防火墙检测<br>        -A       全面扫描<br>1234</p>
<p>nmap的参数有很多，这里主要是DNS欺骗演示，所以nmap的详细参数我就不一一列举了，感兴趣的同学可以去度娘找一下详细的资料</p>
<p><img src="https://img-blog.csdnimg.cn/20190825145524252.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZXN0Xw==,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/20190825145524252.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZXN0Xw==,size_16,color_FFFFFF,t_70"></p>
<p>通过nmap详细的列出的信息可以看出该ip主机所开启的端口服务及操作系统类型的详细信息可以推断出该ip主机所用的系统为win7家庭版</p>
<ul>
<li><strong>二. 配置dns规则和主页文件</strong></li>
</ul>
<p>接下来因为使用的欺骗工具是ettercap，首先对dns的文件进行编辑，填写DNS规则，因为ettercap这个工具的dns规则文件存放在etc目录下，所以先用命令 <strong>cd &#x2F;etc&#x2F;ettercap</strong> 切换到etc目录下的ettercap目录，通过终端用vim打开它</p>
<p><img src="https://img-blog.csdnimg.cn/20190825145911929.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZXN0Xw==,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/20190825145911929.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZXN0Xw==,size_16,color_FFFFFF,t_70"></p>
<p>Vim打开后，按一下 i 键进入编辑状态，然后在红色的矩形中输入，前面的*所在的位置代表需要访问的网站的域名，后面是将其欺骗到的ip(本机ip：92.168.42.171)</p>
<p>进行欺骗时，“*”代表不管什么网站，都解析到后面的ip地址，如果输入特定的域名，那就可以进行钓鱼</p>
<p><img src="https://img-blog.csdnimg.cn/20190825151042891.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZXN0Xw==,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/20190825151042891.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZXN0Xw==,size_16,color_FFFFFF,t_70"></p>
<p>接下来，按一下ESC退出编辑状态，然后按shif加冒号，输入wq，表示写入退出，回车，就可以保存退出了</p>
<p>然后再来编辑&#x2F;var&#x2F;www&#x2F;html下的index.html文件，也就是主页文件，在DNS欺骗成功后，当受害者访问域名网站后，打开的页面就是我们这里的这个主页文件里边的内容（这里只做演示，随便写了一个简单的）</p>
<p><img src="https://img-blog.csdnimg.cn/20190825151316119.jpg" alt="https://img-blog.csdnimg.cn/20190825151316119.jpg"></p>
<p><img src="https://img-blog.csdnimg.cn/20190825151326643.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZXN0Xw==,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/20190825151326643.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZXN0Xw==,size_16,color_FFFFFF,t_70"></p>
<p>接着启动apache2 也就是网页服务器，就是相当于拿本机（Kali）当web服务器这样子</p>
<p>到终端输入命令 <strong>&#x2F;etc&#x2F;init.d&#x2F;apache2 start</strong> 来启动apache2 服务器</p>
<p>出现OK证明成功启动了</p>
<p><img src="https://img-blog.csdnimg.cn/20190825151425353.jpg" alt="https://img-blog.csdnimg.cn/20190825151425353.jpg"></p>
<ul>
<li><strong>三. 利用Ettercap进行ARP欺骗和中间人攻击</strong></li>
</ul>
<p>接着在终端输入命令ettercap -G来进入ettercap的图形界面，个人喜欢用图形界面，可能是windows玩多的原因吧，当然ettercap也有命令行，看个人喜欢着去选择使用命令行还是图形化界面，反正效果一样的</p>
<p>启动ettercap后，选择Unifind sniffing进行网卡配置，网卡选择eth0（根据自己的电脑网卡而定）如果是无线网卡就选择wla0</p>
<p><img src="https://img-blog.csdnimg.cn/20190825151512664.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZXN0Xw==,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/20190825151512664.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZXN0Xw==,size_16,color_FFFFFF,t_70"></p>
<p>接着到hosts选项下的 scan for hosts扫描存活的主机,扫描完毕点击下图的Hosts list，将网关地址添加到 target2，将攻击目标ip添加到 target1, 接着设置中间人攻击的形式为ARP欺骗 mitm&gt;arp poisoning，勾上第一个设置arp双向欺骗</p>
<p><img src="https://img-blog.csdnimg.cn/20190825151529188.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZXN0Xw==,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/20190825151529188.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZXN0Xw==,size_16,color_FFFFFF,t_70"></p>
<p>Arp欺骗设置完毕，我们去靶机查看一下arp缓存表</p>
<p><img src="https://img-blog.csdnimg.cn/20190825151716185.gif" alt="https://img-blog.csdnimg.cn/20190825151716185.gif"></p>
<p>可以看到网关mac跟攻击机Kali的mac一样，这时候可以确定arp毒化成功，，这时候我们随便找一个http网站登录，然后在Kali输入<code>ettercap -Tq -i eth0</code> 试试能否获取登录密码</p>
<p><strong>参数说明： -T 文本模式 -q 安静模式 -i 网卡</strong></p>
<p><img src="https://img-blog.csdnimg.cn/2019082515203433.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZXN0Xw==,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/2019082515203433.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZXN0Xw==,size_16,color_FFFFFF,t_70"></p>
<p>成功嗅探http登录密码 &#x2F;&#x2F;如果需要对https网站进行嗅探，但由于https的安全特性，所以我们需要到Kali更改Sslstrip 配置文件，然后使用sslstrip进行转换把https转换为http</p>
<p>关于https的嗅探实验可以参考我的另一篇博客</p>
<blockquote>
<p>传送门</p>
</blockquote>
<p>成功嗅探后继续配置插件plugins&gt;mangge the plugins，我们要进行的是DNS欺骗 双击dns_spoof 后可以看见下边的提示</p>
<p>最后点击strat&gt;start sniffing开始DNS欺骗</p>
<p><img src="https://img-blog.csdnimg.cn/20190825152225964.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZXN0Xw==,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/20190825152225964.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZXN0Xw==,size_16,color_FFFFFF,t_70"></p>
<p>欺骗成功后可以看到下面显示被欺骗的域名</p>
<p><img src="https://img-blog.csdnimg.cn/20190825152246149.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZXN0Xw==,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/20190825152246149.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZXN0Xw==,size_16,color_FFFFFF,t_70"></p>
<p><a href="http://去靶机上访问www.baidu.com/">去靶机上访问www.baidu.com</a>，就可以看到百度的网页被替换为刚刚编辑的简单h5页面了</p>
<p>左边是dns欺骗前的，右边是欺骗后的</p>
<p><img src="https://img-blog.csdnimg.cn/20190825152307755.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZXN0Xw==,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/20190825152307755.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZXN0Xw==,size_16,color_FFFFFF,t_70"></p>
<p>关闭插件，并点击mitm选择最后一项停止arp欺骗，在靶机上重新访问百度</p>
<p><img src="https://img-blog.csdnimg.cn/20190825152354512.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZXN0Xw==,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/20190825152354512.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZXN0Xw==,size_16,color_FFFFFF,t_70"></p>
<p>页面恢复正常</p>
<p><img src="https://img-blog.csdnimg.cn/20190825152536760.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZXN0Xw==,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/20190825152536760.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZXN0Xw==,size_16,color_FFFFFF,t_70"></p>
<p>当我们关闭插件停止DSN欺骗之后，如果还是无法正常访问网站，那就需要清空dns缓存才能正常访问网页了，万一停止攻击后依然dns错误打不开网页就到cmd界面用输入“ipconfig &#x2F;flushdns”执行，刷新本地的DNS缓存数据</p>
<hr>
<p><strong>五.总结</strong></p>
<p>DNS欺骗即域名信息欺骗是最常见的DNS安全问题。当客户主机向本地DNS服务器查询域名的时候，如果服务器的缓存中已经有相应记录，DNS服务器就不会再向其他服务器进行查询，而是直接将这条记录返回给用户，当主机向某一个DNS服务器发送解析请求时，攻击者冒充被请求方，向请求方返回一个被篡改了的应答，从而请求方访问了被篡改后的IP地址，这样子直接访问被篡改后的网页，容易造成账号密码被盗取。</p>
<p>如何防止dns欺骗：</p>
<p><strong>1.直接修改自己的host文件，将你访问的域名和ip地址直接写到里面，这样就不用通过dns服务器了，也就无法被骗</strong></p>
<p><strong>2.DNS欺骗前提也需要ARP欺骗成功。所以首先做好对ARP欺骗攻击的防范（如绑定本机MAC）</strong></p>
<p><strong>3.Windows下查看和刷清空DNS缓存表的命令命令：ipconfig &#x2F;displaydns ipconfig &#x2F;flushdns</strong></p>
]]></content>
      <categories>
        <category>studytest</category>
      </categories>
      <tags>
        <tag>hacker</tag>
        <tag>arp</tag>
        <tag>dns</tag>
      </tags>
  </entry>
  <entry>
    <title>软件-notion笔记软件</title>
    <url>/2022/06/02/%E8%BD%AF%E4%BB%B6-notion%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<h1>Notion，一款强大到改变我人生的软件</h1>
<p><strong>[南月晨的blog](<a href="https://leiyu-code.github.io/">南月晨的博客 (leiyu-code.github.io)</a>)</strong></p>
<p><a href="http://leiyu-code.github.io">leiyu-code.github.io</a></p>
<p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p>
<p><strong>A unified &amp; collaborative workspace for your notes, wikis, and tasks. 将笔记、知识库和任务管理无缝整合的协作平台</strong></p>
<span id="more"></span>
<p>熟悉我的人都知道，我是一名重度处女座整理癖，不论是现实生活还是网络世界，我最受不了杂乱无章，所以我会尽我所能的将所有的东西分门别类，安置的井井有条。</p>
<p>生活中的物品还好说，只要摆放整齐，定期断舍离就可以保证不凌乱。但是电子设备中的文件本就是由一个个无序的字符串组成，规模庞大、纷繁复杂。在今天这个信息大爆炸的时代，我们每天都要接收各种各样的新闻、资讯，在这中间有的时候浏览到好的内容，想保存下来等随后有时间再查看，但是它们多半的命运都是扔到收藏夹里吃灰。然后自己骗自己，马了等于看了。</p>
<p>如果你也像我一样，是个爱好广泛且好奇心比较强烈的学习者，那么一款好的笔记型应用，绝对是提高生产力的路上不可或缺的好帮手。我曾经在茫茫海洋中苦苦寻觅，希望可以找到一个帮助我提升专注力、提高学习效率的软件，因为我意识到如果我没有办法及时的对新内容进行筛选、转化，将信息增长的速度抵消掉，那么我终究有一天要被堆积如山的信息所淹没。</p>
<p>为了不让这种可怕的事情发生，我几乎把市面上所有的应用都尝试了个遍，印象笔记、有道云笔记、OneNote、为知笔记、Bear、语雀…虽然有一些能解决我的基本需求，但是始终感觉不是很得心应手，痛点依然很痛。并且它们的功能太过分散，有一些只能解决我的某一部分特定需求，所以我常常需要在很多软件中来回切换，有的时候光是整理这些文件、把他们分门别类就耗费了我大量的精力和时间，在这种情况下很难真正的吸收知识、提高学习效率。</p>
<p><img src="http://image109.360doc.com/DownloadImg/2020/12/1214/209696085_3_20201212025501697.png" alt="http://image109.360doc.com/DownloadImg/2020/12/1214/209696085_3_20201212025501697.png"></p>
<p>02.png</p>
<p>直到后来我遇见了Notion，它真正的实现了All in One，解决了我一直以来的痛点，好用到我想以身相许（请把公屏打在般配上）。<strong>从此以后，我的天空，星星都亮了。</strong></p>
<p>Notion是一款及其出色的软件，它的中文翻译是「概念」。这不是一款年代悠久的软件，从2016年问世之初到现在也不过才短短的四年时间。跟那些笔记应用届的前辈们相比，它只能算一个初出茅庐的小鲜肉。其实单纯的说它是一款笔记型应用是不准确的。它拥有非常丰富的使用场景，可以说是一个集项目管理、任务管理以及知识库于一身的在线团队协作工具。早些时候有朋友给我推荐过它，但是苦于它的上手成本太高，并且是全英文软件，服务器在国外，所以当时在国内的时候打开速度你懂的，畏难心理让我过早地放弃了，于是就没有花太多的时间去深入的了解它，第一次的相遇就这么遗憾地擦肩而过。</p>
<p>在进入新公司之后，我们所有的工作文档都保存在Notion上，所以我必须要逼自己开始学习如何去使用它，在这个过程中，我渐渐发现了它的魔力，并且在这个过程中被它深深的迷住了。在经过了一个星期的摸索之后，我发现我的生活再也离不开它了，于是我又花了一个星期的时间，把我前小半辈子所有的资料都迁移到了Notion上面，等到这个大工程完成之后，看着它，我竟然发出了此生无憾的感慨，糟糕，这就是心动的感觉。</p>
<h2 id="一切皆对象"><strong>一切皆对象</strong></h2>
<p>在javascript中有一个思想：‘一切皆对象’，Notion将这个理念很好的应用在软件中，使用者拥有极高的自由度，可以根据自己的实际需求去定制、去改造，打造适合自己的专属知识库。同时它强大的在线协作功能完美的实现了团队需求，不仅可以编辑文档，同时还支持项目管理、Todo list、日程表、计划清单、音/视频播放器…它几乎满足了我对于一个笔记型应用的所有想象，甚至我没想到的地方它也做到了。</p>
<h2 id="Markdown富文本"><strong>Markdown富文本</strong></h2>
<p>其中尤其让我欲罢不能的是它对于Markdown语法的支持，因为被Word和Pages杂乱无章的排版搞的心烦意乱，所以Markdown编辑器Typora一直是我的写作首选。印象笔记和有道云笔记虽然都支持Markdown语法，但是他们都不能直接编辑富文本，只能分成两个屏幕，左边是编辑器，右边是显示效果，由于图片展位等问题经常位置不同步，在软件中的编辑体验糟糕至极，所以我通常是将编辑好的文档直接导入。</p>
<p>而在Notion中，所有的内容直接在编辑器内以富文本显示，不仅让我们可以轻松的使用Markdown语法编辑文字，同时还可以与Notion提供的各种排版、布局方式配合使用，帮助我们排除一切干扰，心无旁骛的专注于写作本身，大大提高了输入效率。它还可以识别几十种代码，通过不同颜色的高亮显示，让代码即清晰易读又整洁美观，对程序员的友好度已经到了’令人发指’的地步。再加上几乎相差无几的快捷方式神助攻，真正实现了所见即所得，让习惯于使用Markdown语法的用户几乎不需要花费太多的学习成本，就可以无缝切换到Notion中。</p>
<h2 id="基本概念"><strong>基本概念</strong></h2>
<p>接下来介绍几个Notion中的基本概念，它打破了传统的笔记软件中对于内容的组合方式，以一种革命性的理念颠覆了我们过往对于笔记型应用的认知。</p>
<h3 id="Block（模块）"><strong>Block（模块）</strong></h3>
<p><img src="http://image109.360doc.com/DownloadImg/2020/12/1214/209696085_4_20201212025502103.gif" alt="http://image109.360doc.com/DownloadImg/2020/12/1214/209696085_4_20201212025502103.gif"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/2484592-88054287f90f9cd6.gif?imageMogr2/auto-orient/strip" alt="04.gif"></p>
<p>Notion中的基本对象为Block（模块），它可以是任何形式：表格、文本、网页、代码块、图片、视频、文件或者直接是一个Page（页面），目前Notion中支持的Block类型有23种。</p>
<p>而且Block的操作方式极其简单快捷，直接使用鼠标按住拖拽，就可以随意重新排列它们的位置，免去了繁琐的复制粘贴困扰。</p>
<p><img src="http://image109.360doc.com/DownloadImg/2020/12/1214/209696085_5_2020121202550356.gif" alt="http://image109.360doc.com/DownloadImg/2020/12/1214/209696085_5_2020121202550356.gif"></p>
<p>05.gif</p>
<p>使用拖拽或者Tab键缩进就可以直接定义两段内容的父子级关系，在选中父级的时候它下面对应的所有子级都会被一同选中，页面结构简单清晰，完全可以取代幕布之类的大纲软件。同时使用Toggle List还可以将不需要的内容暂时收起，节省页面空间，让你的思绪更加连贯。</p>
<p>这些内容丰富的Block就像是乐高积木一样，不同的排列组合可以带来不同的可能性。不仅大大降低了排版布局的操作成本，而且给用户带来了强大的操纵感和驾驭感。</p>
<p><img src="http://image109.360doc.com/DownloadImg/2020/12/1214/209696085_6_20201212025504525.gif" alt="http://image109.360doc.com/DownloadImg/2020/12/1214/209696085_6_20201212025504525.gif"></p>
<p>06.gif</p>
<p>有了Notion中的checkbox，基本上就可以抛弃市面上的Todo类App了，我会将每周需要做的事都列在一个Page中，因为Notion拥有非常自由的分栏功能，所以我可以按照自己的个人习惯来布局整个页面，用我最熟悉的方式将我每天的日程进行量化，这样也方便我后期回顾查阅。</p>
<h3 id="Page（页面）"><strong>Page（页面）</strong></h3>
<p>当我们在记笔记的时候，它们往往并不是独立的知识块，常常需要与其他的文件相互联系、旁征博引，一起构建一个完整的知识体系。使用其他笔记型软件的时候，遇到这种情况就会感觉非常糟心。</p>
<p>而Notion彻底改变了这种局面，在它的理念中，一个笔记就是一个Page，它其实类似于收藏夹的功能。不同的Page之间可以相互嵌套，这种俄罗斯套娃般的无限层级就像一根无形的线，将所有有联系的部分紧紧的拴在一起，形成一个完整而又丰富的知识库。习惯用康奈尔笔记法的同学可以直接使用Notion提供的模版，根据自己的实际需求自定义分栏和层级即可。</p>
<p>同时因为Notion支持直接复制网址嵌入视频，搭配分栏功能，就可以在一个软件中，左边播放教学视频，同时在右边记笔记。而且还可以随时调整左右屏幕的占比。</p>
<p><img src="http://image109.360doc.com/DownloadImg/2020/12/1214/209696085_7_20201212025505884.gif" alt="http://image109.360doc.com/DownloadImg/2020/12/1214/209696085_7_20201212025505884.gif"></p>
<p>08.gif</p>
<p>目前支持比较好的是Youtube这类国外视频网站，不过对于国内Bilibili这种主流的视频网站，也有网友编写的教程，教你如何在笔记中插入视频。如果是本地视频，直接拖拽上传即可。这样当回顾复习的时候，只要打开一个Page，里面所有相关的文字资料、笔记、视频、音频等一切相关的内容就全都涵盖了，妈妈真的再也不用担心我的学习。</p>
<h3 id="Database（数据库）"><strong>Database（数据库）</strong></h3>
<p>Notion的数据库是一个非常强大的板块，它提供了五种不同的展示方式：Table、Board、calendar、List、Gallery，分别对应各种不同的使用场景。同时它支持在这五种展示方式中互相切换，搭配它提供的Filter（过滤）功能，可以按照不同属性生成最适合的展示效果。</p>
<p><img src="http://image109.360doc.com/DownloadImg/2020/12/1214/209696085_8_20201212025507134.gif" alt="http://image109.360doc.com/DownloadImg/2020/12/1214/209696085_8_20201212025507134.gif"></p>
<p>09-Reading list.gif</p>
<p>这里用我每日的阅读列表举例，Database的第一栏是标签栏，可以自定义属性，例如我定义的是：Type（文章类型）、Name（文章名称）、Status（阅读状态）、Score/5（文章等级），根据不同的属性我可以快速地检索到不同类型的文章，因为我每天看的东西多且杂，这个功能帮我很好的整理归档阅读资料，方便我日后检索和查找。</p>
<p><img src="http://image109.360doc.com/DownloadImg/2020/12/1214/209696085_9_20201212025508728.gif" alt="http://image109.360doc.com/DownloadImg/2020/12/1214/209696085_9_20201212025508728.gif"></p>
<p>10.gif</p>
<p>因为阅读过的文章已经有一定印象，所以我习惯于把状态为Finished的文章用List的形式展示，Ready to Start的文章用Gallery的形式来展示，这样可以让我在阅读之前更加直观的了解到文章内容。</p>
<p><img src="http://image109.360doc.com/DownloadImg/2020/12/1214/209696085_10_20201212025509792.gif" alt="http://image109.360doc.com/DownloadImg/2020/12/1214/209696085_10_20201212025509792.gif"></p>
<p>11-剪藏.gif</p>
<p>这样做的好处就是可以将散乱在各处的资料做一个统一分类整理，因为我关注的内容比较多，平时主要浏览的平台也比较杂，除了微信、微博这种主流的社交媒体，还会关注一些诸如少数派、Medium、36氪这些优质网站，遇到一些好的内容当下来不及看就想着先收藏下来，等稍后有时间再仔细阅读。但是一个软件一个软件去查又太麻烦，而且常常收藏之后就忘记了，Notion提供的浏览器插件Web Clipper就很好地帮助我解决了这个问题，平时浏览网站时，遇到好文章只需要点击一下，就可以轻松的保存在你指定的文件夹中，因为表格中有阅读状态属性标记，所以也可以监督自己，将这些Database中的文章及时阅读。</p>
<p><img src="http://image109.360doc.com/DownloadImg/2020/12/1214/209696085_11_20201212025510995.png" alt="http://image109.360doc.com/DownloadImg/2020/12/1214/209696085_11_20201212025510995.png"></p>
<p>其中Notion的Grade Calculator模版简直是一款完美的成绩计算器，因为国外学校的成绩是按照百分比计算总分，它可以设置不同学科的不同占比，同时还可以设置因为晚交而产生的扣分，搭配checkbox设置包含与排除当前学科（未被勾选的学科不计算入总成绩），当我们将所有学科信息输入之后自动会得出结果。它的强大之处就在于将所有的信息集合成一个整体，在Database中你可以上传这门学科的论文、笔记、成绩以及导师反馈，整个学期只用一张表格就可以通通搞定，免去我们查找文件的麻烦。</p>
<p><img src="http://image109.360doc.com/DownloadImg/2020/12/1214/209696085_12_20201212025512118.png" alt="http://image109.360doc.com/DownloadImg/2020/12/1214/209696085_12_20201212025512118.png"></p>
<p>13.png</p>
<p>Database中的基本板块还是Page，可以根据Page中内容的不同，构建不同的数据库。下面总结一下不同的展示方式适用的不同场景：</p>
<p><strong>Table：用户研究列表、课堂笔记、求职记录、成绩计算器、记账单、课程表、课程计划、习惯追踪、竞品分析、公司报表</strong></p>
<p><img src="http://image109.360doc.com/DownloadImg/2020/12/1214/209696085_13_20201212025512869.png" alt="http://image109.360doc.com/DownloadImg/2020/12/1214/209696085_13_20201212025512869.png"></p>
<p>14.png</p>
<p>Table因为支持自定义丰富的Properties（属性），并且还有计算功能加持，所以特别适合学习和工作等需要处理大量数据等场景，通过合理设置Filter，可以帮我们极大提升按需检索的速度。</p>
<p><strong>List View：会议记录、阅读清单、日记本、产品问答、读书笔记</strong></p>
<p><img src="http://image109.360doc.com/DownloadImg/2020/12/1214/209696085_14_20201212025513869.png" alt="http://image109.360doc.com/DownloadImg/2020/12/1214/209696085_14_20201212025513869.png"></p>
<p>15.png</p>
<p>List View相比Table页面更加简洁干净，没有那么多复杂的条条框框，但是它可以很清晰直观的将重要信息展示出来，也可以按照需要设置属性和过滤器，所以比较适合清单类型的内容。</p>
<p><strong>Gallery：设计资源、阅读清单、团队成员介绍</strong></p>
<p><img src="http://image109.360doc.com/DownloadImg/2020/12/1214/209696085_15_2020121202551540.png" alt="http://image109.360doc.com/DownloadImg/2020/12/1214/209696085_15_2020121202551540.png"></p>
<p>16.png</p>
<p>Gallery的特点就是可以展示缩略图，比较适合以图片为主的内容，例如设计团队需要根据不同的封面区分内容。</p>
<p><strong>Calendar：旅行计划、论文进度表、值日表</strong></p>
<p><img src="http://image109.360doc.com/DownloadImg/2020/12/1214/209696085_16_2020121202551672.png" alt="http://image109.360doc.com/DownloadImg/2020/12/1214/209696085_16_2020121202551672.png"></p>
<p>17.png</p>
<p>Calendar可以让我们直观的看到时间节点，你可以设置时间为某一天，也可以通过添加起止时间来横跨某一个时间段，比较适合有时间跨度的计划类内容。</p>
<p><strong>Board：项目管理、销售管理、旅行清单</strong></p>
<p><img src="http://image109.360doc.com/DownloadImg/2020/12/1214/209696085_17_20201212025516822.gif" alt="http://image109.360doc.com/DownloadImg/2020/12/1214/209696085_17_20201212025516822.gif"></p>
<p>18-kanban.gif</p>
<p>习惯于Trello这样项目管理工具的同学对于看板功能肯定不陌生，我们可以按照不同功能将页面划分成不同的栏，在对应的每一栏下面添加卡片。因为Board的卡片支持拖拽，所以我平时除了会用它管理工作进度，同时还将它作为一个规划旅行清单的工具，每打卡完一个目的地就把它放到已去过的一栏，这样可以清晰的显示整个旅行进程。</p>
<h2 id="查看历史版本">查看历史版本</h2>
<p><img src="http://image109.360doc.com/DownloadImg/2020/12/1214/209696085_18_20201212025518259.gif" alt="http://image109.360doc.com/DownloadImg/2020/12/1214/209696085_18_20201212025518259.gif"></p>
<p>19-History.gif</p>
<p>Notion和Figma一样支持回看历史版本，所以及时文件修改之后反悔了也不用担心，Notion可以轻轻松松帮你时光倒流，回退到你之前的历史版本。这一点跟开发中的Git管理有异曲同工之妙，Notion让我们知道世界上真的有后悔药存在。但是这个功能在免费版本中不支持，需要升级到Personal Pro才可以。</p>
<h2 id="兼容性"><strong>兼容性</strong></h2>
<p>在小型智能设备高速发展的今天，我们对于手机的依赖甚至某些时候都超过了电脑，随着办公场景的移动性越来越强，更多的便携设备开始取代笨重的台式机，成为当代人的生产力工具。为了紧跟时代的潮流，软件也需要考虑多平台协作兼容，最理想的状态就是可以让用户存储的资料可以在各个设备之间顺畅切换，无缝衔接。</p>
<p><img src="http://image109.360doc.com/DownloadImg/2020/12/1214/209696085_19_20201212025519353.png" alt="http://image109.360doc.com/DownloadImg/2020/12/1214/209696085_19_20201212025519353.png"></p>
<p>20.png</p>
<p>Notion在兼容性方面可以说做到了极致，它不仅支持Web端在线访问，同时提供Window、Mac系统本地安装包，Android和IOS系统的手机用户也可以放心使用。可以说只要有网络覆盖的地方，就可以无缝切换，全平台通吃。而且只要你在任何一个设备上修改了内容，其余的所有平台都会实时同步，在web端你甚至都不用刷新网页，Notion真正实现了多端同步。</p>
<p>但是对应的有一个很大的问题就是，因为Notion的文档存储在云端，所以读取速度很大程度上取决于服务器的速度，我在国外使用的时候没有感觉到有明显的延迟，打开和导出的速度都很快。但是据国内用户的使用反馈，目前看来对于大陆区的用户还是不太友好。</p>
<h2 id="模版广场"><strong>模版广场</strong></h2>
<p><img src="http://image109.360doc.com/DownloadImg/2020/12/1214/209696085_20_20201212025520119.gif" alt="http://image109.360doc.com/DownloadImg/2020/12/1214/209696085_20_20201212025520119.gif"></p>
<p>21-template.gif</p>
<p>为了方便新手入门，Notion为大家提供了上百种现成的模版，并且根据不同职业需求做了分类，帮助大家轻松面对工作学习、求职应聘、休闲娱乐、居家生活的各种场景。如果觉得官方提供的用得还不过瘾，可以去网站上的Template Gallery自行挖掘探索，上面有各种网友自己DIY的模版。</p>
<p>Notion就像是一块无限的画布，大家可以在上面肆意的挥洒自己的想象力，最后可能会产生令人意想不到的效果。</p>
<h2 id="语言"><strong>语言</strong></h2>
<p>Notion目前有英文版和韩语版两个版本，Notion表示韩国是除美国外国外最大的市场，今年韩国用户数量同比增长了 263%。根据 App Annie 的数据，Notion 排在美韩后的几个主要市场，依次是巴西、俄罗斯和英国，而中国在这个排名中处于相对靠后的位置（这可能和一些人想的不同）。但是因为Notion在Web端也可以访问，所以担心语言问题的小伙伴可以使用Google浏览器的翻译助手，我测试了一下基本翻译的比较准确。</p>
<p>同时我们国内有志愿者成立了Notion中文社区，正在翻译Notion的官方文档，社区里面也有非常丰富的资料，感兴趣的同学可以加入社区，大家一起交流讨论Notion的使用心得。</p>
<h2 id="价格"><strong>价格</strong></h2>
<p><img src="http://image109.360doc.com/DownloadImg/2020/12/1214/209696085_21_20201212025521401.png" alt="http://image109.360doc.com/DownloadImg/2020/12/1214/209696085_21_20201212025521401.png"></p>
<p>22.png</p>
<p>最后来说一下大家最关心的定价方面，目前个人使用的话是免费的，但是上传文件的空间只有5M，之前限制可以使用1000个Block，更新升级之后个人免费版本也可以无限嵌套Block，Notion真的是一款非常良心的软件了，如果对于文件存储空间没有需求的用户，其实免费版本就完全够用了。使用教育邮箱注册的同学还可以直接升级到Pro，之后就可以无限上传文件，简直不能再香了。</p>
<hr>
<p>我平时的主要存储工具就是移动硬盘、百度网盘和本地磁盘。</p>
<ul>
<li>移动硬盘用于备份比较重要的资料、照片视频等；</li>
<li>百度网盘用于存放学习资料、视频教程、手机照片视频备份等；</li>
<li>本地磁盘用于存放目前在做的工作文件和需要经常查看的文件；</li>
</ul>
<p>现在有了Notion的无限上传空间，同时加上它强大的全平台兼容性，正好完美的填补了我之前存储工具的一块空白，用它来收藏我每日的灵光乍现、记录一些随笔感想再合适不过了，它帮我打破了时间和空间的限制，随时随地，不论是什么设备，打开软件就能写作，真真切切的感受到了科技为我们的生活带来的改变。</p>
<p>Notion在自由度和有序之间找到了一个很好的平衡点，它即为用户提供了灵活的操控性，同时又保证了内容的可读性和视觉美观，最终让所有的东西以最简单直接的方式呈现出来。帮助用户节省整理排版布局的时间，同时让我们的注意力回归创作本身。</p>
<p>虽然它目前还有一些不足和缺陷，但是我们已经能看到这款年轻的软件所展露出的无限潜力和魅力。因为太过于喜欢这款软件的设计，于是去他们的官网查看创始团队的资料，观看他们团队成员录制的视频，在了解了他们越来越多的故事后，我变成了一个彻头彻尾的脑残粉。</p>
<p>23-notionoffice.jpg</p>
<blockquote>
<p>The romantic goal is: Can we make tools that allow people to use computers like a new medium? Can we give that to non-programmers? This topic is getting popular again. It was really popular in the 90s, but somehow people forgot that idea for a couple of decades.</p>
</blockquote>
<p>Notion 的创始人Ivan赵出生于中国，之后去了加拿大。他是一名开发者同时也是一名设计师，从小学的时候就开始学习编程，后来大学的时候迷上了摄影，培养了良好的审美观。一开始的Notion版本还不是很稳定，他跟co-founder搬去了日本京都，将代码重构了一遍，才诞生了现在这个版本。他的美好愿景就是降低技术成本，让不会编程的人们也能用上专业的生产力工具。</p>
<p>虽然Notion赢得了大批用户的追逐，获得了5千万美金的投资，现在市值20亿美金，是硅谷炙手可热的明星创业公司，但是在他们取得如此瞩目的成绩之后并没有急于扩充团队，马上将自己的野心放诸于全球市场，而是专注于产品的提升和改进上，保证团队的敏捷和高效，让每一名员工的个人能力得到最大化的发挥。同时注意倾听用户的声音，每一次的升级和迭代都能为我们带来很大的惊喜。</p>
<p>自从开始使用Notion以来，就一直抑制不住想为它写点什么的冲动，对它的喜爱之情如果不赶紧倾泻出来的话我怕自己会憋坏。这么好的产品，其实一开始就迫不及待的想要分享给大家，之所以等到现在，是因为它的功能实在是太强大了，每当我觉得自己已经完全掌握它的时候，它总会给我带来新的惊喜。</p>
<p>没有遇到Notion之前，所有的信息、资料就像一团没有思绪的乱麻，将我紧紧的包裹其中，我苦苦挣扎却不得其法。其实我已经是个非常注重整理的人了，但是在面对它们的时候我还是觉得无从下手。毫不夸张地说，自从开始使用Notion，我感觉自己的生活都减负了，一下子感觉轻松了许多。同时它也像一个无形的监视者，清空代办事项时的快感激励着我不停的前进，它让我的生活变得充实且忙碌。</p>
<p>现在，它对于我来说，已经不仅仅只是一个简单的记笔记的地方。在这里我会记录每天的所思所感，规划自己的成长计划，制定每日的任务清单，整理各种学习资料，它记录了我的喜怒哀乐、成长进步。同时它还帮助我把事物的逻辑理顺，让我在思考的时候思维更加清晰缜密，行动时更加高效快捷，并且它还帮助我找到了人生方向。</p>
<p>工具的本质是帮助人们提升做事的效率，如果在这个过程中还可以帮助用户进一步思考、改善思维方式，那么我想这样的产品已经不仅仅是用「优秀」可以来形容的了。我的人生目标，就是希望自己有一天，也能做出一款像Notion一样，真正改变人们生活的产品，而且是一种积极的改变，我希望它可以让人们的生活更加美好。</p>
<p><strong>说出来会被嘲笑的梦想，才有实现的价值。</strong></p>
<p>虽然外面的世界变化很快，人们每天都在为了不同的人生目标奔波劳碌，有的人追名有的人逐利。为了实现自己的目标，人们开发出各种各样的软件，有的希望占用用户更多的时间和注意力，有的希望掏空用户的钱包和银行卡，但是这些都不能打扰我内心的节奏，纵使这个过程可能孤独无比，只要拥有了坚定淡泊的心智，我相信我也可以从容应对接下来的人生旅途。</p>
<p>就像Notion一样，<strong>不模仿别人，不重复自己。</strong></p>
]]></content>
      <categories>
        <category>software</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>Knowledgehub</tag>
        <tag>mission mangerg</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo常用命令</title>
    <url>/2022/03/05/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="简写指令"><a href="#简写指令" class="headerlink" title="简写指令:"></a>简写指令:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo n &quot;我的第一篇文章&quot;`       等价于        `hexo new &quot;我的第一篇文章&quot;`  还等价于       `hexo new post &quot;我的第一篇文章&quot;`    </span><br><span class="line"> `hexo p` 等价于 `hexo publish`</span><br><span class="line"> `hexo g` 等价于 `hexo generate`  </span><br><span class="line"> `hexo s`等价于 `hexo server`     </span><br><span class="line"> `hexo d` 等价于 `hexo deploy`</span><br><span class="line"> `hexo deploy -g`  等价于 `hexo deploy --generate`</span><br><span class="line"> `hexo generate -d`等价于`hexo generate --deploy</span><br></pre></td></tr></table></figure>

<p><strong>注: hexo  clean 没有 简写,  git –version 没有简写</strong></p>
<span id="more"></span>

<h2 id="指令说明"><a href="#指令说明" class="headerlink" title="指令说明:"></a>指令说明:</h2><p><code>hexo server</code>        #Hexo 会监视文件变动并自动更新，除修改<strong>站点配置文件</strong>外,无须重启服务器,直接刷新网页即可生效。<br> <code>hexo server -s</code> #以静态模式启动<br> <code>hexo server -p 5000</code> #更改访问端口   (默认端口为4000，’ctrl + c’关闭server)<br> <code>hexo server -i IP地址</code> #自定义 IP<br> <code>hexo clean</code> #清除缓存  ,网页正常情况下可以忽略此条命令,执行该指令后,会删掉站点根目录下的public文件夹<br> <code>hexo g</code> #生成静态网页  (执行 <code>$ hexo g</code>后会在站点根目录下生成public文件夹, hexo会将”&#x2F;blog&#x2F;source&#x2F;“   下面的.md后缀的文件编译为.html后缀的文件,存放在”&#x2F;blog&#x2F;public&#x2F; “   路径下)<br> <code>hexo d</code> #将本地数据部署到远端服务器(如github)<br> <code>hexo init 文件夹名称</code> #初始化XX文件夹名称<br> <code>npm update hexo -g</code>#升级<br> <code>npm install hexo -g</code>#安装<br> <code>node-v</code>          #查看node.js版本号<br> <code>npm -v</code>        #查看npm版本号<br> <code>git --version</code>  #查看git版本号<br> <code>hexo -v</code>      #查看hexo版本号</p>
<p><code>hexo publish [layout] &lt;title&gt;</code>   #通过 <code>publish</code> 命令将草稿移动到 <code>source/_posts</code> 文件夹,如:<code>$ hexo publish [layout] &lt;title&gt;</code>,草稿默认是不会显示在页面中的，可在执行时加上 <code>--draft</code> 参数，或是把 <code>render_drafts</code> 参数设为 <code>true</code>来预览草稿。</p>
<p><code>hexo new aaa &quot;bbb&quot;</code>  # 新建一篇文章,文章名称和标题分别为bbb.md 和 bbb.   文章采用aaa布局,  此时会在站点根目录下的—-&gt;source—–&gt;_post文件夹下生成bbb.md文件,  bbb.md文件的顶部(—–分割线上方区域,也称作Front matter区),生成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">layout : aaa`</span><br><span class="line"> `title:`</span><br><span class="line"> `date:</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>studynote</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>linux常用命令</title>
    <url>/2022/03/05/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="50个最常用的Unix-x2F-Linux命令"><a href="#50个最常用的Unix-x2F-Linux命令" class="headerlink" title="50个最常用的Unix&#x2F;Linux命令"></a>50个最常用的Unix&#x2F;Linux命令</h2><blockquote>
<p>这篇文章翻译自<a href="http://www.thegeekstuff.com/2010/11/50-linux-commands/%E8%BF%99%E4%BA%9B%E9%83%BD%E6%98%AF%E4%B8%80%E4%BA%9B%E5%BE%88%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%EF%BC%8C%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E4%B8%AD%E6%AF%8F%E4%B8%AA%E5%91%BD%E4%BB%A4%E9%83%BD%E6%9C%89%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E7%A4%BA%E4%BE%8B%E8%AF%B4%E6%98%8E%E5%AE%83%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%8C%E5%AF%B9%E4%BA%8E%E6%83%B3%E5%AD%A6%E4%B9%A0Unix/Linux%E7%9A%84%E4%BA%BA%EF%BC%8C%E8%BF%99%E4%BA%9B%E5%91%BD%E4%BB%A4%E5%9F%BA%E6%9C%AC%E4%B8%8A%E9%83%BD%E6%98%AF%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%EF%BC%9A">http://www.thegeekstuff.com/2010/11/50-linux-commands/这些都是一些很常用的命令，这篇文章中每个命令都有一些简单的示例说明它的用法，对于想学习Unix/Linux的人，这些命令基本上都是需要掌握的：</a></p>
</blockquote>
<table>
<thead>
<tr>
<th><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#tar">tar</a></th>
<th><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#grep">grep</a></th>
<th><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#find">find</a></th>
<th><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#ssh">ssh</a></th>
<th><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#sed">sed</a></th>
<th><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#awk">awk</a></th>
<th><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#vim">vim</a></th>
<th><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#diff">diff</a></th>
<th><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#sort">sort</a></th>
<th><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#export">export</a></th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#args">args</a></td>
<td><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#ls">ls</a></td>
<td><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#pwd">pwd</a></td>
<td><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#cd">cd</a></td>
<td><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#gzip">gzip</a></td>
<td><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#bzip2">bzip2</a></td>
<td><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#unzip">unzip</a></td>
<td><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#shutdown">shutdown</a></td>
<td><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#ftp">ftp</a></td>
<td><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#crontab">crontab</a></td>
</tr>
<tr>
<td><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#service">service</a></td>
<td><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#ps">ps</a></td>
<td><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#free">free</a></td>
<td><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#top">top</a></td>
<td><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#df">df</a></td>
<td><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#kill">kill</a></td>
<td><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#rm">rm</a></td>
<td><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#cp">cp</a></td>
<td><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#mv">mv</a></td>
<td><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#cat">cat</a></td>
</tr>
<tr>
<td><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#mount">mount</a></td>
<td><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#chmod">chmod</a></td>
<td><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#chown">chown</a></td>
<td><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#passwd">passwd</a></td>
<td><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#mkdir">mkdir</a></td>
<td><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#ifconfig">ifconfig</a></td>
<td><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#uname">uname</a></td>
<td><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#whereis">whereis</a></td>
<td><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#whatis">whatis</a></td>
<td><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#locate">locate</a></td>
</tr>
<tr>
<td><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#man">man</a></td>
<td><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#tail">tail</a></td>
<td><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#less">less</a></td>
<td><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#su">su</a></td>
<td><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#mysql">mysql</a></td>
<td><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#yum">yum</a></td>
<td><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#rpm">rpm</a></td>
<td><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#ping">ping</a></td>
<td><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#date">date</a></td>
<td><a href="https://gywbd.github.io/posts/2014/8/50-linux-commands.html#wget">wget</a></td>
</tr>
</tbody></table>
<span id="more"></span>

<h3 id="1-tar"><a href="#1-tar" class="headerlink" title="1. tar"></a>1. tar</h3><p>创建一个新的tar文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ tar cvf archive_name.tar dirname/</span><br></pre></td></tr></table></figure>

<p>解压tar文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ tar xvf archive_name.tar</span><br></pre></td></tr></table></figure>

<p>查看tar文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ tar tvf archive_name.tar</span><br></pre></td></tr></table></figure>

<p>更多示例：<a href="http://www.thegeekstuff.com/2010/04/unix-tar-command-examples/">The Ultimate Tar Command Tutorial with 10 Practical Examples</a></p>
<h3 id="2-grep"><a href="#2-grep" class="headerlink" title="2. grep"></a>2. grep</h3><p>在文件中查找字符串(不区分大小写)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ grep -i &quot;the&quot; demo_file</span><br></pre></td></tr></table></figure>

<p>输出成功匹配的行，以及该行之后的三行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ grep -A 3 -i &quot;example&quot; demo_text</span><br></pre></td></tr></table></figure>

<p>在一个文件夹中递归查询包含指定字符串的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ grep -r &quot;ramesh&quot; *</span><br></pre></td></tr></table></figure>

<p>更多示例：<a href="http://www.thegeekstuff.com/2009/03/15-practical-unix-grep-command-examples/">Get a Grip on the Grep! – 15 Practical Grep Command Examples</a></p>
<h3 id="3-find"><a href="#3-find" class="headerlink" title="3. find"></a>3. find</h3><p>查找指定文件名的文件(不区分大小写)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ find -iname &quot;MyProgram.c&quot;</span><br></pre></td></tr></table></figure>

<p>对找到的文件执行某个命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ find -iname &quot;MyProgram.c&quot; -exec md5sum &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p>查找home目录下的所有空文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ find ~ -empty</span><br></pre></td></tr></table></figure>

<p>更多示例：<a href="http://www.thegeekstuff.com/2009/03/15-practical-linux-find-command-examples/">Mommy, I found it! — 15 Practical Linux Find Command Examples</a></p>
<h3 id="4-ssh"><a href="#4-ssh" class="headerlink" title="4. ssh"></a>4. ssh</h3><p>登录到远程主机</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh -l jsmith remotehost.example.com</span><br></pre></td></tr></table></figure>

<p>调试ssh客户端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh -v -l jsmith remotehost.example.com</span><br></pre></td></tr></table></figure>

<p>显示ssh客户端版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh -V</span><br></pre></td></tr></table></figure>

<p>更多示例：<a href="http://www.thegeekstuff.com/2008/05/5-basic-linux-ssh-client-commands/">5 Basic Linux SSH Client Commands</a></p>
<h3 id="5-sed"><a href="#5-sed" class="headerlink" title="5. sed"></a>5. sed</h3><p>当你将Dos系统中的文件复制到Unix&#x2F;Linux后，这个文件每行都会以\r\n结尾，sed可以轻易将其转换为Unix格式的文件，使用\n结尾的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sed &#x27;s/.$//&#x27; filename</span><br></pre></td></tr></table></figure>

<p>反转文件内容并输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sed -n &#x27;1!G; h; p&#x27; filename</span><br></pre></td></tr></table></figure>

<p>为非空行添加行号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sed &#x27;/./=&#x27; thegeekstuff.txt | sed &#x27;N; s/\n/ /&#x27;</span><br></pre></td></tr></table></figure>

<p>更多示例：<a href="http://www.thegeekstuff.com/2009/10/unix-sed-tutorial-advanced-sed-substitution-examples/">Advanced Sed Substitution Examples</a></p>
<h3 id="6-awk"><a href="#6-awk" class="headerlink" title="6. awk"></a>6. awk</h3><p>删除重复行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ awk &#x27;!($0 in array) &#123; array[$0]; print&#125;&#x27; temp</span><br></pre></td></tr></table></figure>

<p>打印&#x2F;etc&#x2F;passwd中所有包含同样的uid和gid的行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ awk -F &#x27;:&#x27; &#x27;$3=$4&#x27; /etc/passwd</span><br></pre></td></tr></table></figure>

<p>打印文件中的指定部分的字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ awk &#x27;&#123;print $2,$5;&#125;&#x27; employee.txt</span><br></pre></td></tr></table></figure>

<p>更多示例：<a href="http://www.thegeekstuff.com/2010/01/8-powerful-awk-built-in-variables-fs-ofs-rs-ors-nr-nf-filename-fnr/">8 Powerful Awk Built-in Variables – FS, OFS, RS, ORS, NR, NF, FILENAME, FNR</a></p>
<h3 id="7-vim"><a href="#7-vim" class="headerlink" title="7. vim"></a>7. vim</h3><p>打开文件并跳到第10行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ vim +10 filename.txt</span><br></pre></td></tr></table></figure>

<p>打开文件跳到第一个匹配的行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ vim +/search-term filename.txt</span><br></pre></td></tr></table></figure>

<p>以只读模式打开文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ vim -R /etc/passwd</span><br></pre></td></tr></table></figure>

<p>更多示例：<a href="http://www.thegeekstuff.com/2009/01/vi-and-vim-macro-tutorial-how-to-record-and-play/">How To Record and Play in Vim Editor</a></p>
<h3 id="8-diff"><a href="#8-diff" class="headerlink" title="8. diff"></a>8. diff</h3><p>比较的时候忽略空白符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ diff -w name_list.txt name_list_new.txt</span><br></pre></td></tr></table></figure>

<h3 id="9-sort"><a href="#9-sort" class="headerlink" title="9. sort"></a>9. sort</h3><p>以升序对文件内容排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sort names.txt</span><br></pre></td></tr></table></figure>

<p>以降序对文件内容排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sort -r names.txt</span><br></pre></td></tr></table></figure>

<p>以第三个字段对&#x2F;etc&#x2F;passwd的内容排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sort -t: -k 3n /etc/passwd | more</span><br></pre></td></tr></table></figure>

<h3 id="10-export"><a href="#10-export" class="headerlink" title="10. export"></a>10. export</h3><p>输出跟字符串oracle匹配的环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ export | grep ORCALE</span><br><span class="line">declare -x ORACLE_BASE=&quot;/u01/app/oracle&quot;</span><br><span class="line">declare -x ORACLE_HOME=&quot;/u01/app/oracle/product/10.2.0&quot;</span><br><span class="line">declare -x ORACLE_SID=&quot;med&quot;</span><br><span class="line">declare -x ORACLE_TERM=&quot;xterm&quot;</span><br></pre></td></tr></table></figure>

<p>设置全局环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ export ORACLE_HOME=/u01/app/oracle/product/10.2.0</span><br></pre></td></tr></table></figure>

<h3 id="11-xargs"><a href="#11-xargs" class="headerlink" title="11. xargs"></a>11. xargs</h3><p>将所有图片文件拷贝到外部驱动器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ls *.jpg | xargs -n1 -i cp &#123;&#125; /external-hard-drive/directory</span><br></pre></td></tr></table></figure>

<p>将系统中所有jpd文件压缩打包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ find / -name *.jpg -type f -print | xargs tar -cvzf images.tar.gz</span><br></pre></td></tr></table></figure>

<p>下载文件中列出的所有url对应的页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat url-list.txt | xargs wget –c</span><br></pre></td></tr></table></figure>

<h3 id="12-ls"><a href="#12-ls" class="headerlink" title="12. ls"></a>12. ls</h3><p>以易读的方式显示文件大小(显示为MB,GB…)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ls -lh</span><br><span class="line">-rw-r----- 1 ramesh team-dev 8.9M Jun 12 15:27 arch-linux.txt.gz</span><br></pre></td></tr></table></figure>

<p>以最后修改时间升序列出文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ls -ltr</span><br></pre></td></tr></table></figure>

<p>在文件名后面显示文件类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ls -F</span><br></pre></td></tr></table></figure>

<p>更多示例：<a href="http://www.thegeekstuff.com/2009/07/linux-ls-command-examples/">Unix LS Command: 15 Practical Examples</a></p>
<h3 id="13-pwd"><a href="#13-pwd" class="headerlink" title="13. pwd"></a>13. pwd</h3><p>输出当前工作目录</p>
<h3 id="14-cd"><a href="#14-cd" class="headerlink" title="14. cd"></a>14. cd</h3><p><code>cd -</code>可以在最近工作的两个目录间切换</p>
<p>使用<code>shopt -s cdspell</code>可以设置自动对cd命令进行拼写检查</p>
<p>更多示例：<a href="http://www.thegeekstuff.com/2008/10/6-awesome-linux-cd-command-hacks-productivity-tip3-for-geeks/">6 Awesome Linux cd command Hacks</a></p>
<h3 id="15-gzip"><a href="#15-gzip" class="headerlink" title="15. gzip"></a>15. gzip</h3><p>创建一个*.gz的压缩文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gzip test.txt</span><br></pre></td></tr></table></figure>

<p>解压*.gz文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gzip -d test.txt.gz</span><br></pre></td></tr></table></figure>

<p>显示压缩的比率</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gzip -l *.gz</span><br><span class="line">     compressed        uncompressed  ratio uncompressed_name</span><br><span class="line">          23709               97975  75.8% asp-patch-rpms.txt</span><br></pre></td></tr></table></figure>

<h3 id="16-bzip2"><a href="#16-bzip2" class="headerlink" title="16. bzip2"></a>16. bzip2</h3><p>创建*.bz2压缩文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ bzip2 test.txt</span><br></pre></td></tr></table></figure>

<p>解压*.bz2文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bzip2 -d test.txt.bz2</span><br></pre></td></tr></table></figure>

<p>更多示例：<a href="http://www.thegeekstuff.com/2010/10/bzcommand-examples/">BZ is Eazy! bzip2, bzgrep, bzcmp, bzdiff, bzcat, bzless, bzmore examples</a></p>
<h3 id="17-uzip"><a href="#17-uzip" class="headerlink" title="17. uzip"></a>17. uzip</h3><p>解压*.zip文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ unzip test.zip</span><br></pre></td></tr></table></figure>

<p>查看*.zip文件的内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ unzip -l jasper.zip</span><br><span class="line">Archive:  jasper.zip</span><br><span class="line">Length     Date   Time    Name</span><br><span class="line">--------    ----   ----    ----</span><br><span class="line">40995  11-30-98 23:50   META-INF/MANIFEST.MF</span><br><span class="line">32169  08-25-98 21:07   classes_</span><br><span class="line">15964  08-25-98 21:07   classes_names</span><br><span class="line">10542  08-25-98 21:07   classes_ncomp</span><br></pre></td></tr></table></figure>

<h3 id="18-shutdown"><a href="#18-shutdown" class="headerlink" title="18. shutdown"></a>18. shutdown</h3><p>关闭系统并立即关机</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ shutdown -h now</span><br></pre></td></tr></table></figure>

<p>10分钟后关机</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ shutdown -h +10</span><br></pre></td></tr></table></figure>

<p>重启</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ shutdown -r now</span><br></pre></td></tr></table></figure>

<p>重启期间强制进行系统检查</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ shutdown -Fr now</span><br></pre></td></tr></table></figure>

<h3 id="19-ftp"><a href="#19-ftp" class="headerlink" title="19. ftp"></a>19. ftp</h3><p>ftp命令和sftp命令的用法基本相似连接ftp服务器并下载多个文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ftp IP/hostname</span><br><span class="line">ftp&gt; mget *.html</span><br></pre></td></tr></table></figure>

<p>显示远程主机上文件列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ftp&gt; mls *.html -</span><br><span class="line">/ftptest/features.html</span><br><span class="line">/ftptest/index.html</span><br><span class="line">/ftptest/othertools.html</span><br><span class="line">/ftptest/samplereport.html</span><br><span class="line">/ftptest/usage.html</span><br></pre></td></tr></table></figure>

<p>更多示例：<a href="http://www.thegeekstuff.com/2010/06/ftp-sftp-tutorial/">FTP and SFTP Beginners Guide with 10 Examples</a></p>
<h3 id="20-crontab"><a href="#20-crontab" class="headerlink" title="20. crontab"></a>20. crontab</h3><p>查看某个用户的crontab入口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ crontab -u john -l</span><br></pre></td></tr></table></figure>

<p>设置一个每十分钟执行一次的计划任务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*/10 * * * * /home/ramesh/check-disk-space</span><br></pre></td></tr></table></figure>

<p>更多示例：<a href="http://www.thegeekstuff.com/2009/06/15-practical-crontab-examples/">Linux Crontab: 15 Awesome Cron Job Examples</a></p>
<h3 id="21-service"><a href="#21-service" class="headerlink" title="21. service"></a>21. service</h3><p>service命令用于运行System V init脚本，这些脚本一般位于&#x2F;etc&#x2F;init.d文件下，这个命令可以直接运行这个文件夹里面的脚本，而不用加上路径</p>
<p>查看服务状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ service ssh status</span><br></pre></td></tr></table></figure>

<p>查看所有服务状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ service --status-all</span><br></pre></td></tr></table></figure>

<p>重启服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ service ssh restart</span><br></pre></td></tr></table></figure>

<h3 id="22-ps"><a href="#22-ps" class="headerlink" title="22. ps"></a>22. ps</h3><p>ps命令用于显示正在运行中的进程的信息，ps命令有很多选项，这里只列出了几个</p>
<p>查看当前正在运行的所有进程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ps -ef | more</span><br></pre></td></tr></table></figure>

<p>以树状结构显示当前正在运行的进程，H选项表示显示进程的层次结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ps -efH | more</span><br></pre></td></tr></table></figure>

<h3 id="23-free"><a href="#23-free" class="headerlink" title="23. free"></a>23. free</h3><p>这个命令用于显示系统当前内存的使用情况，包括已用内存、可用内存和交换内存的情况</p>
<p>默认情况下free会以字节为单位输出内存的使用量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ free</span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:       3566408    1580220    1986188          0     203988     902960</span><br><span class="line">-/+ buffers/cache:     473272    3093136</span><br><span class="line">Swap:      4000176          0    4000176</span><br></pre></td></tr></table></figure>

<p>如果你想以其他单位输出内存的使用量，需要加一个选项，-g为GB，-m为MB，-k为KB，-b为字节</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ free -g</span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:             3          1          1          0          0          0</span><br><span class="line">-/+ buffers/cache:          0          2</span><br><span class="line">Swap:            3          0          3</span><br></pre></td></tr></table></figure>

<p>如果你想查看所有内存的汇总，请使用-t选项，使用这个选项会在输出中加一个汇总行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ramesh@ramesh-laptop:~$ free -t</span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:       3566408    1592148    1974260          0     204260     912556</span><br><span class="line">-/+ buffers/cache:     475332    3091076</span><br><span class="line">Swap:      4000176          0    4000176</span><br><span class="line">Total:     7566584    1592148    5974436</span><br></pre></td></tr></table></figure>

<h3 id="24-top"><a href="#24-top" class="headerlink" title="24. top"></a>24. top</h3><p>top命令会显示当前系统中占用资源最多的一些进程（默认以CPU占用率排序）如果你想改变排序方式，可以在结果列表中点击O（大写字母O）会显示所有可用于排序的列，这个时候你就可以选择你想排序的列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Current Sort Field:  P  for window 1:Def</span><br><span class="line">Select sort field via field letter, type any other key to return</span><br><span class="line"></span><br><span class="line">  a: PID        = Process Id              v: nDRT       = Dirty Pages count</span><br><span class="line">  d: UID        = User Id                 y: WCHAN      = Sleeping in Function</span><br><span class="line">  e: USER       = User Name               z: Flags      = Task Flags</span><br><span class="line">  ........</span><br></pre></td></tr></table></figure>

<p>如果只想显示某个特定用户的进程，可以使用-u选项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ top -u oracle</span><br></pre></td></tr></table></figure>

<p>更多示例：<a href="http://www.thegeekstuff.com/2010/01/15-practical-unix-linux-top-command-examples/">Can You Top This? 15 Practical Linux Top Command Examples</a></p>
<h3 id="25-df"><a href="#25-df" class="headerlink" title="25. df"></a>25. df</h3><p>显示文件系统的磁盘使用情况，默认情况下<code>df -k </code>将以字节为单位输出磁盘的使用量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ df -k</span><br><span class="line">Filesystem           1K-blocks      Used Available Use% Mounted on</span><br><span class="line">/dev/sda1             29530400   3233104  24797232  12% /</span><br><span class="line">/dev/sda2            120367992  50171596  64082060  44% /home</span><br></pre></td></tr></table></figure>

<p>使用-h选项可以以更符合阅读习惯的方式显示磁盘使用量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ df -h</span><br><span class="line">Filesystem                  Size   Used  Avail Capacity  iused      ifree %iused  Mounted on</span><br><span class="line">/dev/disk0s2               232Gi   84Gi  148Gi    37% 21998562   38864868   36%   /</span><br><span class="line">devfs                      187Ki  187Ki    0Bi   100%      648          0  100%   /dev</span><br><span class="line">map -hosts                   0Bi    0Bi    0Bi   100%        0          0  100%   /net</span><br><span class="line">map auto_home                0Bi    0Bi    0Bi   100%        0          0  100%   /home</span><br><span class="line">/dev/disk0s4               466Gi   45Gi  421Gi    10%   112774  440997174    0%   /Volumes/BOOTCAMP</span><br><span class="line">//app@izenesoft.cn/public  2.7Ti  1.3Ti  1.4Ti    48%        0 18446744073709551615    0%   /Volumes/public</span><br></pre></td></tr></table></figure>

<p>使用-T选项显示文件系统类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ df -T</span><br><span class="line">Filesystem    Type   1K-blocks      Used Available Use% Mounted on</span><br><span class="line">/dev/sda1     ext4    29530400   3233120  24797216  12% /</span><br><span class="line">/dev/sda2     ext4   120367992  50171596  64082060  44% /home</span><br></pre></td></tr></table></figure>

<h3 id="26-kill"><a href="#26-kill" class="headerlink" title="26. kill"></a>26. kill</h3><p>kill用于终止一个进程。一般我们会先用<code>ps -ef</code>查找某个进程得到它的进程号，然后再使用<code>kill -9 进程号</code>终止该进程。你还可以使用killall、pkill、xkill来终止进程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ps -ef | grep vim</span><br><span class="line">ramesh    7243  7222  9 22:43 pts/2    00:00:00 vim</span><br><span class="line"></span><br><span class="line">$ kill -9 7243</span><br></pre></td></tr></table></figure>

<p>更多示例：<a href="http://www.thegeekstuff.com/2009/12/4-ways-to-kill-a-process-kill-killall-pkill-xkill/">4 Ways to Kill a Process – kill, killall, pkill, xkill</a></p>
<h3 id="27-rm"><a href="#27-rm" class="headerlink" title="27. rm"></a>27. rm</h3><p>删除文件前先确认</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ rm -i filename.txt</span><br></pre></td></tr></table></figure>

<p>在文件名中使用shell的元字符会非常有用。删除文件前先打印文件名并进行确认</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ rm -i file*</span><br></pre></td></tr></table></figure>

<p>递归删除文件夹下所有文件，并删除该文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ rm -r example</span><br></pre></td></tr></table></figure>

<h3 id="28-cp"><a href="#28-cp" class="headerlink" title="28. cp"></a>28. cp</h3><p>拷贝文件1到文件2，并保持文件的权限、属主和时间戳</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cp -p file1 file2</span><br></pre></td></tr></table></figure>

<p>拷贝file1到file2，如果file2存在会提示是否覆盖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cp -i file1 file2</span><br></pre></td></tr></table></figure>

<h3 id="29-mv"><a href="#29-mv" class="headerlink" title="29. mv"></a>29. mv</h3><p>将文件名file1重命名为file2，如果file2存在则提示是否覆盖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mv -i file1 file2</span><br></pre></td></tr></table></figure>

<p>注意如果使用-f选项则不会进行提示</p>
<p>-v会输出重命名的过程，当文件名中包含通配符时，这个选项会非常方便</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mv -v file1 file2</span><br></pre></td></tr></table></figure>

<h3 id="30-cat"><a href="#30-cat" class="headerlink" title="30. cat"></a>30. cat</h3><p>你可以一次查看多个文件的内容，下面的命令会先打印file1的内容，然后打印file2的内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat file1 file2</span><br></pre></td></tr></table></figure>

<p>-n命令可以在每行的前面加上行号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat -n /etc/logrotate.conf</span><br><span class="line">    1	/var/log/btmp &#123;</span><br><span class="line">    2	    missingok</span><br><span class="line">    3	    monthly</span><br><span class="line">    4	    create 0660 root utmp</span><br><span class="line">    5	    rotate 1</span><br><span class="line">    6	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="31-mount"><a href="#31-mount" class="headerlink" title="31. mount"></a>31. mount</h3><p>如果要挂载一个文件系统，需要先创建一个目录，然后将这个文件系统挂载到这个目录上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># mkdir /u01</span><br><span class="line"></span><br><span class="line"># mount /dev/sdb1 /u01</span><br></pre></td></tr></table></figure>

<p>也可以把它添加到fstab中进行自动挂载，这样任何时候系统重启的时候，文件系统都会被加载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/dev/sdb1 /u01 ext2 defaults 0 2</span><br></pre></td></tr></table></figure>

<h3 id="32-chmod"><a href="#32-chmod" class="headerlink" title="32. chmod"></a>32. chmod</h3><p>chmod用于改变文件和目录的权限</p>
<p>给指定文件的属主和属组所有权限(包括读、写、执行)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ chmod ug+rwx file.txt</span><br></pre></td></tr></table></figure>

<p>删除指定文件的属组的所有权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ chmod g-rwx file.txt</span><br></pre></td></tr></table></figure>

<p>修改目录的权限，以及递归修改目录下面所有文件和子目录的权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ chmod -R ug+rwx file.txt</span><br></pre></td></tr></table></figure>

<p>更多示例：<a href="http://www.thegeekstuff.com/2010/06/chmod-command-examples/">7 Chmod Command Examples for Beginners</a></p>
<h3 id="33-chown"><a href="#33-chown" class="headerlink" title="33. chown"></a>33. chown</h3><p>chown用于改变文件属主和属组</p>
<p>同时将某个文件的属主改为oracle，属组改为db</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ chown oracle:dba dbora.sh</span><br></pre></td></tr></table></figure>

<p>使用-R选项对目录和目录下的文件进行递归修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ chown -R oracle:dba /home/oracle</span><br></pre></td></tr></table></figure>

<h3 id="34-passwd"><a href="#34-passwd" class="headerlink" title="34. passwd"></a>34. passwd</h3><p>passwd用于在命令行修改密码，使用这个命令会要求你先输入旧密码，然后输入新密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ passwd</span><br></pre></td></tr></table></figure>

<p>超级用户可以用这个命令修改其他用户的密码，这个时候不需要输入用户的密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># passwd USERNAME</span><br></pre></td></tr></table></figure>

<p>passwd还可以删除某个用户的密码，这个命令只有root用户才能操作，删除密码后，这个用户不需要输入密码就可以登录到系统</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># passwd -d USERNAME</span><br></pre></td></tr></table></figure>

<h3 id="35-mkdir"><a href="#35-mkdir" class="headerlink" title="35. mkdir"></a>35. mkdir</h3><p>在home目录下创建一个名为temp的目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mkdir ~/temp</span><br></pre></td></tr></table></figure>

<p>使用-p选项可以创建一个路径上所有不存在的目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mkdir -p dir1/dir2/dir3/dir4/</span><br></pre></td></tr></table></figure>

<h3 id="36-ifconfig"><a href="#36-ifconfig" class="headerlink" title="36. ifconfig"></a>36. ifconfig</h3><p>ifconfig用于查看和配置Linux系统的网络接口</p>
<p>查看所有网络接口及其状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ifconfig -a</span><br></pre></td></tr></table></figure>

<p>使用up和down命令启动或停止某个接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ifconfig eth0 up</span><br><span class="line"></span><br><span class="line">$ ifconfig eth0 down</span><br></pre></td></tr></table></figure>

<p>更多示例：<a href="http://www.thegeekstuff.com/2009/03/ifconfig-7-examples-to-configure-network-interface/">Ifconfig: 7 Examples To Configure Network Interface</a></p>
<h3 id="37-uname"><a href="#37-uname" class="headerlink" title="37. uname"></a>37. uname</h3><p>uname可以显示一些重要的系统信息，例如内核名称、主机名、内核版本号、处理器类型之类的信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ uname -a</span><br><span class="line">Linux john-laptop 2.6.32-24-generic #41-Ubuntu SMP Thu Aug 19 01:12:52 UTC 2010 i686 GNU/Linux</span><br></pre></td></tr></table></figure>

<h3 id="38-whereis"><a href="#38-whereis" class="headerlink" title="38. whereis"></a>38. whereis</h3><p>当你不知道某个命令的位置时可以使用whereis命令，下面使用whereis查找ls的位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ whereis ls</span><br><span class="line">ls: /bin/ls /usr/share/man/man1/ls.1.gz /usr/share/man/man1p/ls.1p.gz</span><br></pre></td></tr></table></figure>

<p>当你想查找某个可执行程序的位置，但这个程序又不在whereis的默认目录下，你可以使用-B选项，并指定目录作为这个选项的参数。下面的命令在&#x2F;tmp目录下查找lsmk命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ whereis -u -B /tmp -f lsmk</span><br><span class="line">lsmk: /tmp/lsmk</span><br></pre></td></tr></table></figure>

<h3 id="39-whatis"><a href="#39-whatis" class="headerlink" title="39. whatis"></a>39. whatis</h3><p>wathis显示某个命令的描述信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ whatis ls</span><br><span class="line">ls		(1)  - list directory contents</span><br><span class="line"></span><br><span class="line">$ whatis ifconfig</span><br><span class="line">ifconfig (8)         - configure a network interface</span><br></pre></td></tr></table></figure>

<h3 id="40-locate"><a href="#40-locate" class="headerlink" title="40. locate"></a>40. locate</h3><p>locate命名可以显示某个指定文件（或一组文件）的路径，它会使用由updatedb创建的数据库</p>
<p>下面的命令会显示系统中所有包含crontab字符串的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ locate crontab</span><br><span class="line">/etc/anacrontab</span><br><span class="line">/etc/crontab</span><br><span class="line">/usr/bin/crontab</span><br><span class="line">/usr/share/doc/cron/examples/crontab2english.pl.gz</span><br><span class="line">/usr/share/man/man1/crontab.1.gz</span><br><span class="line">/usr/share/man/man5/anacrontab.5.gz</span><br><span class="line">/usr/share/man/man5/crontab.5.gz</span><br><span class="line">/usr/share/vim/vim72/syntax/crontab.vim</span><br></pre></td></tr></table></figure>

<h3 id="41-man"><a href="#41-man" class="headerlink" title="41. man"></a>41. man</h3><p>显示某个命令的man页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ man crontab</span><br></pre></td></tr></table></figure>

<p>有些命令可能会有多个man页面，每个man页面对应一种命令类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ man SECTION-NUMBER commandname</span><br></pre></td></tr></table></figure>

<p>man页面一般可以分为8种命令类型</p>
<ol>
<li>用户命令</li>
<li>系统调用</li>
<li>c库函数</li>
<li>设备与网络接口</li>
<li>文件格式</li>
<li>游戏与屏保</li>
<li>环境、表、宏</li>
<li>系统管理员命令和后台运行命令</li>
</ol>
<p>例如，我们执行<code>whatis crontab</code>，你可以看到crontab有两个命令类型1和5，所以我们可以通过下面的命令查看命令类型5的man页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ whatis crontab</span><br><span class="line">crontab (1)          - maintain crontab files for individual users (V3)</span><br><span class="line">crontab (5)          - tables for driving cron</span><br><span class="line"></span><br><span class="line">$ man 5 crontab</span><br></pre></td></tr></table></figure>

<h3 id="42-tail"><a href="#42-tail" class="headerlink" title="42. tail"></a>42. tail</h3><p>tail命令默认显示文件最后的10行文本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ tail filename.txt</span><br></pre></td></tr></table></figure>

<p>你可以使用-n选项指定要显示的行数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ tail -n N filename.txt</span><br></pre></td></tr></table></figure>

<p>你也可以使用-f选项进行实时查看，这个命令执行后会等待，如果有新行添加到文件尾部，它会继续输出新的行，在查看日志时这个选项会非常有用。你可以通过CTRL-C终止命令的执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ tail -f log-file</span><br></pre></td></tr></table></figure>

<p>更多示例：<a href="http://www.thegeekstuff.com/2009/09/multitail-to-view-tail-f-output-of-multiple-log-files-in-one-terminal/">3 Methods To View tail -f output of Multiple Log Files in One Terminal</a></p>
<h3 id="43-less"><a href="#43-less" class="headerlink" title="43. less"></a>43. less</h3><p>这个命名可以在不加载整个文件的前提下显示文件内容，在查看大型日志文件的时候这个命令会非常有用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ less huge-log-file.log</span><br></pre></td></tr></table></figure>

<p>当你用less命令打开某个文件时，下面两个按键会给你带来很多帮助，他们用于向前和向后滚屏</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CTRL+F – forward one window</span><br><span class="line">CTRL+B – backward one window</span><br></pre></td></tr></table></figure>

<p>更多示例：<a href="http://www.thegeekstuff.com/2010/02/unix-less-command-10-tips-for-effective-navigation/">Unix Less Command: 10 Tips for Effective Navigation</a></p>
<h3 id="44-su"><a href="#44-su" class="headerlink" title="44. su"></a>44. su</h3><p>su命令用于切换用户账号，超级用户使用这个命令可以切换到任何其他用户而不用输入密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ su - USERNAME</span><br></pre></td></tr></table></figure>

<p>用另外一个用户名执行一个命令下面的示例中用户john使用raj用户名执行ls命令，执行完后返回john的账号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[john@dev-server]$ su - raj -c &#x27;ls&#x27;</span><br><span class="line"></span><br><span class="line">[john@dev-server]$</span><br></pre></td></tr></table></figure>

<p>用指定用户登录，并且使用指定的shell程序，而不用默认的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ su -s &#x27;SHELLNAME&#x27; USERNAME</span><br></pre></td></tr></table></figure>

<h3 id="45-mysql"><a href="#45-mysql" class="headerlink" title="45. mysql"></a>45. mysql</h3><p>mysql可能是Linux上使用最广泛的数据库，即使你没有在你的服务器上安装mysql，你也可以使用mysql客户端连接到远程的mysql服务器</p>
<p>连接一个远程数据库，需要输入密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mysql -u root -p -h 192.168.1.2</span><br></pre></td></tr></table></figure>

<p>连接本地数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mysql -u root -p</span><br></pre></td></tr></table></figure>

<p>你也可以在命令行中输入数据库密码，只需要在-p后面加上密码作为参数，可以直接写在p后面而不用加空格</p>
<h3 id="46-yum"><a href="#46-yum" class="headerlink" title="46. yum"></a>46. yum</h3><p>使用yum安装apache</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ yum install httpd</span><br></pre></td></tr></table></figure>

<p>更新apache</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ yum update httpd</span><br></pre></td></tr></table></figure>

<p>卸载&#x2F;删除apache</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ yum remove httpd</span><br></pre></td></tr></table></figure>

<h3 id="47-rpm"><a href="#47-rpm" class="headerlink" title="47. rpm"></a>47. rpm</h3><p>使用rpm安装apache</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># rpm -ivh httpd-2.2.3-22.0.1.el5.i386.rpm</span><br></pre></td></tr></table></figure>

<p>更新apache</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># rpm -uvh httpd-2.2.3-22.0.1.el5.i386.rpm</span><br></pre></td></tr></table></figure>

<p>卸载&#x2F;删除apache</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># rpm -ev httpd</span><br></pre></td></tr></table></figure>

<p>更多示例：<a href="http://www.thegeekstuff.com/2010/07/rpm-command-examples/">RPM Command: 15 Examples to Install, Uninstall, Upgrade, Query RPM Packages</a></p>
<h3 id="48-ping"><a href="#48-ping" class="headerlink" title="48. ping"></a>48. ping</h3><p>ping一个远程主机，只发5个数据包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ping -c 5 gmail.com</span><br></pre></td></tr></table></figure>

<p>更多示例：<a href="http://www.thegeekstuff.com/2009/11/ping-tutorial-13-effective-ping-command-examples/">Ping Tutorial: 15 Effective Ping Command Examples</a></p>
<h3 id="49-date"><a href="#49-date" class="headerlink" title="49. date"></a>49. date</h3><p>设置系统日期</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># date -s &quot;01/31/2010 23:59:53&quot;</span><br></pre></td></tr></table></figure>

<p>当你修改了系统时间，你需要同步硬件时间和系统时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># hwclock –systohc</span><br><span class="line"></span><br><span class="line"># hwclock --systohc –utc</span><br></pre></td></tr></table></figure>

<h3 id="50-wget"><a href="#50-wget" class="headerlink" title="50. wget"></a>50. wget</h3><p>使用wget从网上下载软件、音乐、视频</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ wget http://prdownloads.sourceforge.net/sourceforge/nagios/nagios-3.2.1.tar.gz</span><br></pre></td></tr></table></figure>

<p>下载文件并以指定的文件名保存文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ wget -O taglist.zip http://www.vim.org/scripts/download_script.php?src_id=7701</span><br></pre></td></tr></table></figure>

<p>更多示例：<a href="http://www.thegeekstuff.com/2009/09/the-ultimate-wget-download-guide-with-15-awesome-examples/">The Ultimate Wget Download Guide With 15 Awesome Examples</a></p>
]]></content>
      <categories>
        <category>studynote</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>vi/vim常用快捷键及命令</title>
    <url>/2022/03/05/vi-vim%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%8F%8A%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>[雷宇]<a href="http://leiyu-code.github.io/">http://leiyu-code.github.io</a></p>
<h1 id="Linux-vi-x2F-vim"><a href="#Linux-vi-x2F-vim" class="headerlink" title="Linux vi&#x2F;vim"></a>Linux vi&#x2F;vim</h1><p>所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。</p>
<p>但是目前我们使用比较多的是 vim 编辑器。</p>
<p>vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。</p>
<p>相关文章：<a href="https://www.runoob.com/w3cnote/all-vim-cheatsheat.html">史上最全Vim快捷键键位图 — 入门到进阶</a></p>
<hr>
<h2 id="什么是-vim？"><a href="#什么是-vim？" class="headerlink" title="什么是 vim？"></a>什么是 vim？</h2><p>Vim 是从 vi 发展出来的一个文本编辑器。代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p>
<p>简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。</p>
<p>连 vim 的官方网站 (<a href="https://www.vim.org/">https://www.vim.org/</a>) 自己也说 vim 是一个程序开发工具而不是文字处理软件。</p>
<p>vim 键盘图：</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2015/10/vi-vim-cheat-sheet-sch.gif" alt="img"></p>
<hr>
<span id="more"></span>

<h2 id="vi-x2F-vim-的使用"><a href="#vi-x2F-vim-的使用" class="headerlink" title="vi&#x2F;vim 的使用"></a>vi&#x2F;vim 的使用</h2><p>基本上 vi&#x2F;vim 共分为三种模式，分别是<strong>命令模式（Command mode）</strong>，<strong>输入模式（Insert mode）</strong>和<strong>底线命令模式（Last line mode）</strong>。 这三种模式的作用分别是：</p>
<h3 id="命令模式："><a href="#命令模式：" class="headerlink" title="命令模式："></a>命令模式：</h3><p>用户刚刚启动 vi&#x2F;vim，便进入了命令模式。</p>
<p>此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。</p>
<p>以下是常用的几个命令：</p>
<ul>
<li><strong>i</strong> 切换到输入模式，以输入字符。</li>
<li><strong>x</strong> 删除当前光标所在处的字符。</li>
<li><strong>:</strong> 切换到底线命令模式，以在最底一行输入命令。</li>
</ul>
<p>若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。</p>
<p>命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。</p>
<h3 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h3><p>在命令模式下按下i就进入了输入模式。</p>
<p>在输入模式中，可以使用以下按键：</p>
<ul>
<li><strong>字符按键以及Shift组合</strong>，输入字符</li>
<li><strong>ENTER</strong>，回车键，换行</li>
<li><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</li>
<li><strong>DEL</strong>，删除键，删除光标后一个字符</li>
<li><strong>方向键</strong>，在文本中移动光标</li>
<li><strong>HOME</strong>&#x2F;<strong>END</strong>，移动光标到行首&#x2F;行尾</li>
<li><strong>Page Up</strong>&#x2F;<strong>Page Down</strong>，上&#x2F;下翻页</li>
<li><strong>Insert</strong>，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线</li>
<li><strong>ESC</strong>，退出输入模式，切换到命令模式</li>
</ul>
<h3 id="底线命令模式"><a href="#底线命令模式" class="headerlink" title="底线命令模式"></a>底线命令模式</h3><p>在命令模式下按下:（英文冒号）就进入了底线命令模式。</p>
<p>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。</p>
<p>在底线命令模式中，基本的命令有（已经省略了冒号）：</p>
<ul>
<li>q 退出程序</li>
<li>w 保存文件</li>
</ul>
<p>按ESC键可随时退出底线命令模式。</p>
<p>简单的说，我们可以将这三个模式想成底下的图标来表示：</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/07/vim-vi-workmodel.png" alt="img"></p>
<hr>
<h2 id="vi-x2F-vim-使用实例"><a href="#vi-x2F-vim-使用实例" class="headerlink" title="vi&#x2F;vim 使用实例"></a>vi&#x2F;vim 使用实例</h2><h3 id="使用-vi-x2F-vim-进入一般模式"><a href="#使用-vi-x2F-vim-进入一般模式" class="headerlink" title="使用 vi&#x2F;vim 进入一般模式"></a>使用 vi&#x2F;vim 进入一般模式</h3><p>如果你想要使用 vi 来建立一个名为 runoob.txt 的文件时，你可以这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ vim runoob.txt</span><br></pre></td></tr></table></figure>

<p>直接输入 <strong>vi 文件名</strong> 就能够进入 vi 的一般模式了。请注意，记得 vi 后面一定要加文件名，不管该文件存在与否！</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/07/078207F0-B204-4464-AAEF-982F45EDDAE9.jpg" alt="img"></p>
<h3 id="按下-i-进入输入模式-也称为编辑模式-，开始编辑文字"><a href="#按下-i-进入输入模式-也称为编辑模式-，开始编辑文字" class="headerlink" title="按下 i 进入输入模式(也称为编辑模式)，开始编辑文字"></a>按下 i 进入输入模式(也称为编辑模式)，开始编辑文字</h3><p>在一般模式之中，只要按下 i, o, a 等字符就可以进入输入模式了！</p>
<p>在编辑模式当中，你可以发现在左下角状态栏中会出现 –INSERT- 的字样，那就是可以输入任意字符的提示。</p>
<p>这个时候，键盘上除了 <strong>Esc</strong> 这个按键之外，其他的按键都可以视作为一般的输入按钮了，所以你可以进行任何的编辑。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/07/1C928383-471E-4AF1-A61E-9E2CCBD5A913.jpg" alt="img"></p>
<h3 id="按下-ESC-按钮回到一般模式"><a href="#按下-ESC-按钮回到一般模式" class="headerlink" title="按下 ESC 按钮回到一般模式"></a>按下 ESC 按钮回到一般模式</h3><p>好了，假设我已经按照上面的样式给他编辑完毕了，那么应该要如何退出呢？是的！没错！就是给他按下 <strong>Esc</strong> 这个按钮即可！马上你就会发现画面左下角的 – INSERT – 不见了！</p>
<h3 id="在一般模式中按下-wq-储存后离开-vi"><a href="#在一般模式中按下-wq-储存后离开-vi" class="headerlink" title="在一般模式中按下 :wq 储存后离开 vi"></a>在一般模式中按下 <strong>:wq</strong> 储存后离开 vi</h3><p>OK，我们要存档了，存盘并离开的指令很简单，输入 <strong>:wq</strong> 即可保存离开！</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/07/B2FB5146-327C-4019-AC96-DD7A8EE7460C.jpg" alt="img"></p>
<p>OK! 这样我们就成功创建了一个 runoob.txt 的文件。</p>
<hr>
<h2 id="vi-x2F-vim-按键说明"><a href="#vi-x2F-vim-按键说明" class="headerlink" title="vi&#x2F;vim 按键说明"></a>vi&#x2F;vim 按键说明</h2><p>除了上面简易范例的 i, Esc, :wq 之外，其实 vim 还有非常多的按键可以使用。</p>
<h3 id="第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等"><a href="#第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等" class="headerlink" title="第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等"></a>第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等</h3><table>
<thead>
<tr>
<th align="left">移动光标的方法</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">h 或 向左箭头键(←)</td>
<td>光标向左移动一个字符</td>
</tr>
<tr>
<td align="left">j 或 向下箭头键(↓)</td>
<td>光标向下移动一个字符</td>
</tr>
<tr>
<td align="left">k 或 向上箭头键(↑)</td>
<td>光标向上移动一个字符</td>
</tr>
<tr>
<td align="left">l 或 向右箭头键(→)</td>
<td>光标向右移动一个字符</td>
</tr>
<tr>
<td align="left">如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。 如果想要进行多次移动的话，例如向下移动 30 行，可以使用 “30j” 或 “30↓” 的组合按键， 亦即加上想要进行的次数(数字)后，按下动作即可！</td>
<td></td>
</tr>
<tr>
<td align="left">[Ctrl] + [f]</td>
<td>屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td>
</tr>
<tr>
<td align="left">[Ctrl] + [b]</td>
<td>屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td>
</tr>
<tr>
<td align="left">[Ctrl] + [d]</td>
<td>屏幕『向下』移动半页</td>
</tr>
<tr>
<td align="left">[Ctrl] + [u]</td>
<td>屏幕『向上』移动半页</td>
</tr>
<tr>
<td align="left">+</td>
<td>光标移动到非空格符的下一行</td>
</tr>
<tr>
<td align="left">-</td>
<td>光标移动到非空格符的上一行</td>
</tr>
<tr>
<td align="left">n<space></td>
<td>那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</td>
</tr>
<tr>
<td align="left">0 或功能键[Home]</td>
<td>这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td>
</tr>
<tr>
<td align="left">$ 或功能键[End]</td>
<td>移动到这一行的最后面字符处(常用)</td>
</tr>
<tr>
<td align="left">H</td>
<td>光标移动到这个屏幕的最上方那一行的第一个字符</td>
</tr>
<tr>
<td align="left">M</td>
<td>光标移动到这个屏幕的中央那一行的第一个字符</td>
</tr>
<tr>
<td align="left">L</td>
<td>光标移动到这个屏幕的最下方那一行的第一个字符</td>
</tr>
<tr>
<td align="left">G</td>
<td>移动到这个档案的最后一行(常用)</td>
</tr>
<tr>
<td align="left">nG</td>
<td>n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td>
</tr>
<tr>
<td align="left">gg</td>
<td>移动到这个档案的第一行，相当于 1G 啊！ (常用)</td>
</tr>
<tr>
<td align="left">n<Enter></td>
<td>n 为数字。光标向下移动 n 行(常用)</td>
</tr>
<tr>
<td align="left">搜索替换</td>
<td></td>
</tr>
<tr>
<td align="left">&#x2F;word</td>
<td>向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 &#x2F;vbird 即可！ (常用)</td>
</tr>
<tr>
<td align="left">?word</td>
<td>向光标之上寻找一个字符串名称为 word 的字符串。</td>
</tr>
<tr>
<td align="left">n</td>
<td>这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 &#x2F;vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td>
</tr>
<tr>
<td align="left">N</td>
<td>这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 &#x2F;vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td>
</tr>
<tr>
<td align="left">使用 &#x2F;word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键词！</td>
<td></td>
</tr>
<tr>
<td align="left">:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g</td>
<td>n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s&#x2F;vbird&#x2F;VBIRD&#x2F;g』。(常用)</td>
</tr>
<tr>
<td align="left"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;g</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;g</strong></td>
<td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</td>
</tr>
<tr>
<td align="left"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;gc</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;gc</strong></td>
<td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</td>
</tr>
<tr>
<td align="left">删除、复制与贴上</td>
<td></td>
</tr>
<tr>
<td align="left">x, X</td>
<td>在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td>
</tr>
<tr>
<td align="left">nx</td>
<td>n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td>
</tr>
<tr>
<td align="left">dd</td>
<td>剪切游标所在的那一整行(常用)，用 p&#x2F;P 可以粘贴。</td>
</tr>
<tr>
<td align="left">ndd</td>
<td>n 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20 行(常用)，用 p&#x2F;P 可以粘贴。</td>
</tr>
<tr>
<td align="left">d1G</td>
<td>删除光标所在到第一行的所有数据</td>
</tr>
<tr>
<td align="left">dG</td>
<td>删除光标所在到最后一行的所有数据</td>
</tr>
<tr>
<td align="left">d$</td>
<td>删除游标所在处，到该行的最后一个字符</td>
</tr>
<tr>
<td align="left">d0</td>
<td>那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td>
</tr>
<tr>
<td align="left">yy</td>
<td>复制游标所在的那一行(常用)</td>
</tr>
<tr>
<td align="left">nyy</td>
<td>n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td>
</tr>
<tr>
<td align="left">y1G</td>
<td>复制游标所在行到第一行的所有数据</td>
</tr>
<tr>
<td align="left">yG</td>
<td>复制游标所在行到最后一行的所有数据</td>
</tr>
<tr>
<td align="left">y0</td>
<td>复制光标所在的那个字符到该行行首的所有数据</td>
</tr>
<tr>
<td align="left">y$</td>
<td>复制光标所在的那个字符到该行行尾的所有数据</td>
</tr>
<tr>
<td align="left">p, P</td>
<td>p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)</td>
</tr>
<tr>
<td align="left">J</td>
<td>将光标所在行与下一行的数据结合成同一行</td>
</tr>
<tr>
<td align="left">c</td>
<td>重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td>
</tr>
<tr>
<td align="left">u</td>
<td>复原前一个动作。(常用)</td>
</tr>
<tr>
<td align="left">[Ctrl]+r</td>
<td>重做上一个动作。(常用)</td>
</tr>
<tr>
<td align="left">这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！</td>
<td></td>
</tr>
<tr>
<td align="left">.</td>
<td>不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)</td>
</tr>
</tbody></table>
<h3 id="第二部分：一般模式切换到编辑模式的可用的按钮说明"><a href="#第二部分：一般模式切换到编辑模式的可用的按钮说明" class="headerlink" title="第二部分：一般模式切换到编辑模式的可用的按钮说明"></a>第二部分：一般模式切换到编辑模式的可用的按钮说明</h3><table>
<thead>
<tr>
<th align="left">进入输入或取代的编辑模式</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">i, I</td>
<td>进入输入模式(Insert mode)： i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)</td>
</tr>
<tr>
<td align="left">a, A</td>
<td>进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td>
</tr>
<tr>
<td align="left">o, O</td>
<td>进入输入模式(Insert mode)： 这是英文字母 o 的大小写。o 为在目前光标所在的下一行处输入新的一行； O 为在目前光标所在的上一行处输入新的一行！(常用)</td>
</tr>
<tr>
<td align="left">r, R</td>
<td>进入取代模式(Replace mode)： r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td>
</tr>
<tr>
<td align="left">上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 由名称就知道该动作了吧！！特别注意的是，我们上面也提过了，你想要在档案里面输入字符时， 一定要在左下角处看到 INSERT 或 REPLACE 才能输入喔！</td>
<td></td>
</tr>
<tr>
<td align="left">[Esc]</td>
<td>退出编辑模式，回到一般模式中(常用)</td>
</tr>
</tbody></table>
<h3 id="第三部分：一般模式切换到指令行模式的可用的按钮说明"><a href="#第三部分：一般模式切换到指令行模式的可用的按钮说明" class="headerlink" title="第三部分：一般模式切换到指令行模式的可用的按钮说明"></a>第三部分：一般模式切换到指令行模式的可用的按钮说明</h3><table>
<thead>
<tr>
<th align="left">指令行的储存、离开等指令</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">:w</td>
<td>将编辑的数据写入硬盘档案中(常用)</td>
</tr>
<tr>
<td align="left">:w!</td>
<td>若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！</td>
</tr>
<tr>
<td align="left">:q</td>
<td>离开 vi (常用)</td>
</tr>
<tr>
<td align="left">:q!</td>
<td>若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。</td>
</tr>
<tr>
<td align="left">注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～</td>
<td></td>
</tr>
<tr>
<td align="left">:wq</td>
<td>储存后离开，若为 :wq! 则为强制储存后离开 (常用)</td>
</tr>
<tr>
<td align="left">ZZ</td>
<td>这是大写的 Z 喔！如果修改过，保存当前文件，然后退出！效果等同于(保存并退出)</td>
</tr>
<tr>
<td align="left">ZQ</td>
<td>不保存，强制退出。效果等同于 **:q!**。</td>
</tr>
<tr>
<td align="left">:w [filename]</td>
<td>将编辑的数据储存成另一个档案（类似另存新档）</td>
</tr>
<tr>
<td align="left">:r [filename]</td>
<td>在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面</td>
</tr>
<tr>
<td align="left">:n1,n2 w [filename]</td>
<td>将 n1 到 n2 的内容储存成 filename 这个档案。</td>
</tr>
<tr>
<td align="left">:! command</td>
<td>暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls &#x2F;home』即可在 vi 当中察看 &#x2F;home 底下以 ls 输出的档案信息！</td>
</tr>
<tr>
<td align="left">vim 环境的变更</td>
<td></td>
</tr>
<tr>
<td align="left">:set nu</td>
<td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td>
</tr>
<tr>
<td align="left">:set nonu</td>
<td>与 set nu 相反，为取消行号！</td>
</tr>
</tbody></table>
<p>特别注意，在 vi&#x2F;vim 中，数字是很有意义的！数字通常代表重复做几次的意思！ 也有可能是代表去到第几个什么什么的意思。</p>
<p>举例来说，要删除 50 行，则是用 『50dd』 对吧！ 数字加在动作之前，如我要向下移动 20 行呢？那就是『20j』或者是『20↓』即可。</p>
<p> <a href="https://www.runoob.com/linux/linux-filesystem.html">Linux 磁盘管理</a></p>
<p><a href="https://www.runoob.com/linux/linux-yum.html">linux yum 命令</a> </p>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><strong>vim 中批量添加注释</strong></p>
<p>方法一 ：块选择模式</p>
<p>批量注释：</p>
<p><strong>Ctrl + v</strong> 进入块选择模式，然后移动光标选中你要注释的行，再按大写的 <strong>I</strong> 进入行首插入模式输入注释符号如 <strong>&#x2F;&#x2F;</strong> 或 <strong>#<strong>，输入完毕之后，按两下 <strong>ESC</strong>，</strong>Vim</strong> 会自动将你选中的所有行首都加上注释，保存退出完成注释。</p>
<p>取消注释：</p>
<p><strong>Ctrl + v</strong> 进入块选择模式，选中你要删除的行首的注释符号，注意 <strong>&#x2F;&#x2F;</strong> 要选中两个，选好之后按 <strong>d</strong> 即可删除注释，<strong>ESC</strong> 保存退出。</p>
<p>方法二: 替换命令</p>
<p>批量注释。</p>
<p>使用下面命令在指定的行首添加注释。</p>
<p>使用名命令格式： <strong>:起始行号,结束行号s&#x2F;^&#x2F;注释符&#x2F;g</strong>（注意冒号）。</p>
<p>取消注释：</p>
<p>使用名命令格式： <strong>:起始行号,结束行号s&#x2F;^注释符&#x2F;&#x2F;g</strong>（注意冒号）。</p>
<p>例子：</p>
<p>1、在 10 - 20 行添加 <strong>&#x2F;&#x2F;</strong> 注释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:10,20s#^#//#g</span><br></pre></td></tr></table></figure>

<p>2、在 10 - 20 行删除 <strong>&#x2F;&#x2F;</strong> 注释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:10,20s#^//##g</span><br></pre></td></tr></table></figure>

<p>3、在 10 - 20 行添加 <strong>#</strong> 注释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:10,20s/^/#/g</span><br></pre></td></tr></table></figure>

<p>4、在 <strong>10 - 20</strong> 行删除 # 注释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:10,20s/#//g</span><br></pre></td></tr></table></figure>





<p>vim快捷键补充（插入模式）</p>
<ol>
<li>自动补全：<strong>ctrl</strong> + <strong>n</strong></li>
<li>**\p&lt;** 插入一个include，并把光标置于&lt;&gt;中间</li>
<li><strong>\im</strong> 插入主函数</li>
<li><strong>\ip</strong> 插入printf，并自动添加<strong>\n</strong>，且把光标置于双引号中间</li>
</ol>
<p>vim快捷键补充（编辑模式）</p>
<ol>
<li>dw 删除一个单词（配合b：将光标置于所在单词的首部）</li>
<li>yw 复制一个单词（配合p：粘贴）</li>
</ol>
<p>vim快捷键补充（插入与编辑模式通用）</p>
<ol>
<li>\rr 运行程序</li>
<li>\rc 保存并编译程序（会生成二进制文件）</li>
</ol>
]]></content>
      <categories>
        <category>studynote</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>vi</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常用命令</title>
    <url>/2022/03/04/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>git 常用命令</p>
<p>[雷宇]<a href="http://leiyu-code.github.io/">http://leiyu-code.github.io</a></p>
<p><a href="https://www.runoob.com/wp-content/uploads/2015/02/011500266295799.jpg"><img src="https://www.runoob.com/wp-content/uploads/2015/02/011500266295799.jpg" alt="img"></a></p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init                                                  # 初始化本地git仓库（创建新仓库）</span><br><span class="line">git config --global user.name &quot;xxx&quot;                       # 配置用户名</span><br><span class="line">git config --global user.email &quot;xxx@xxx.com&quot;              # 配置邮件</span><br><span class="line">git config --global color.ui true                         # git status等命令自动着色</span><br><span class="line">git config --global color.status auto</span><br><span class="line">git config --global color.diff auto</span><br><span class="line">git config --global color.branch auto</span><br><span class="line">git config --global color.interactive auto</span><br><span class="line">git config --global --unset http.proxy                    # remove  proxy configuration on git</span><br><span class="line">git clone git+ssh://git@192.168.53.168/VT.git             # clone远程仓库</span><br><span class="line">git status                                                # 查看当前版本状态（是否修改）</span><br><span class="line">git add xyz                                               # 添加xyz文件至index</span><br><span class="line">git add .                                                 # 增加当前子目录下所有更改过的文件至index</span><br><span class="line">git commit -m &#x27;xxx&#x27;                                       # 提交</span><br><span class="line">git commit --amend -m &#x27;xxx&#x27;                               # 合并上一次提交（用于反复修改）</span><br><span class="line">git commit -am &#x27;xxx&#x27;                                      # 将add和commit合为一步</span><br><span class="line">git rm xxx                                                # 删除index中的文件</span><br><span class="line">git rm -r *                                               # 递归删除</span><br><span class="line">git log                                                   # 显示提交日志</span><br><span class="line">git log -1                                                # 显示1行日志 -n为n行</span><br><span class="line">git log -5</span><br><span class="line">git log --stat                                            # 显示提交日志及相关变动文件</span><br><span class="line">git log -p -m</span><br><span class="line">git show dfb02e6e4f2f7b573337763e5c0013802e392818         # 显示某个提交的详细内容</span><br><span class="line">git show dfb02                                            # 可只用commitid的前几位</span><br><span class="line">git show HEAD                                             # 显示HEAD提交日志</span><br><span class="line">git show HEAD^                                            # 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本</span><br><span class="line">git tag                                                   # 显示已存在的tag</span><br><span class="line">git tag -a v2.0 -m &#x27;xxx&#x27;                                  # 增加v2.0的tag</span><br><span class="line">git show v2.0                                             # 显示v2.0的日志及详细内容</span><br><span class="line">git log v2.0                                              # 显示v2.0的日志</span><br><span class="line">git diff                                                  # 显示所有未添加至index的变更</span><br><span class="line">git diff --cached                                         # 显示所有已添加index但还未commit的变更</span><br><span class="line">git diff HEAD^                                            # 比较与上一个版本的差异</span><br><span class="line">git diff HEAD -- ./lib                                    # 比较与HEAD版本lib目录的差异</span><br><span class="line">git diff origin/master..master                            # 比较远程分支master上有本地分支master上没有的</span><br><span class="line">git diff origin/master..master --stat                     # 只显示差异的文件，不显示具体内容</span><br><span class="line">git remote add origin git+ssh://git@192.168.53.168/VT.git # 增加远程定义（用于push/pull/fetch）</span><br><span class="line">git branch                                                # 显示本地分支</span><br><span class="line">git branch --contains 50089                               # 显示包含提交50089的分支</span><br><span class="line">git branch -a                                             # 显示所有分支</span><br><span class="line">git branch -r                                             # 显示所有原创分支</span><br><span class="line">git branch --merged                                       # 显示所有已合并到当前分支的分支</span><br><span class="line">git branch --no-merged                                    # 显示所有未合并到当前分支的分支</span><br><span class="line">git branch -m master master_copy                          # 本地分支改名</span><br><span class="line">git checkout -b master_copy                               # 从当前分支创建新分支master_copy并检出</span><br><span class="line">git checkout -b master master_copy                        # 上面的完整版</span><br><span class="line">git checkout features/performance                         # 检出已存在的features/performance分支</span><br><span class="line">git checkout --track hotfixes/BJVEP933                    # 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支</span><br><span class="line">git checkout v2.0                                         # 检出版本v2.0</span><br><span class="line">git checkout -b devel origin/develop                      # 从远程分支develop创建新本地分支devel并检出</span><br><span class="line">git checkout -- README                                    # 检出head版本的README文件（可用于修改错误回退）</span><br><span class="line">git merge origin/master                                   # 合并远程master分支至当前分支</span><br><span class="line">git cherry-pick ff44785404a8e                             # 合并提交ff44785404a8e的修改</span><br><span class="line">git push origin master                                    # 将当前分支push到远程master分支</span><br><span class="line">git push origin :hotfixes/BJVEP933                        # 删除远程仓库的hotfixes/BJVEP933分支</span><br><span class="line">git push --tags                                           # 把所有tag推送到远程仓库</span><br><span class="line">git fetch                                                 # 获取所有远程分支（不更新本地分支，另需merge）</span><br><span class="line">git fetch --prune                                         # 获取所有原创分支并清除服务器上已删掉的分支</span><br><span class="line">git pull origin master                                    # 获取远程分支master并merge到当前分支</span><br><span class="line">git mv README README2                                     # 重命名文件README为README2</span><br><span class="line">git reset --hard HEAD                                     # 将当前版本重置为HEAD（通常用于merge失败回退）</span><br><span class="line">git rebase</span><br><span class="line">git branch -d hotfixes/BJVEP933                           # 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）</span><br><span class="line">git branch -D hotfixes/BJVEP933                           # 强制删除分支hotfixes/BJVEP933</span><br><span class="line">git ls-files                                              # 列出git index包含的文件</span><br><span class="line">git show-branch                                           # 图示当前分支历史</span><br><span class="line">git show-branch --all                                     # 图示所有分支历史</span><br><span class="line">git whatchanged                                           # 显示提交历史对应的文件修改</span><br><span class="line">git revert dfb02e6e4f2f7b573337763e5c0013802e392818       # 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818</span><br><span class="line">git ls-tree HEAD                                          # 内部命令：显示某个git对象</span><br><span class="line">git rev-parse v2.0                                        # 内部命令：显示某个ref对于的SHA1 HASH</span><br><span class="line">git reflog                                                # 显示所有提交，包括孤立节点</span><br><span class="line">git show HEAD@&#123;5&#125;</span><br><span class="line">git show master@&#123;yesterday&#125;                               # 显示master分支昨天的状态</span><br><span class="line">git log --pretty=format:&#x27;%h %s&#x27; --graph                   # 图示提交日志</span><br><span class="line">git show HEAD~3</span><br><span class="line">git show -s --pretty=raw 2be7fcb476</span><br><span class="line">git stash                                                 # 暂存当前修改，将所有至为HEAD状态</span><br><span class="line">git stash list                                            # 查看所有暂存</span><br><span class="line">git stash show -p stash@&#123;0&#125;                               # 参考第一次暂存</span><br><span class="line">git stash apply stash@&#123;0&#125;                                 # 应用第一次暂存</span><br><span class="line">git grep &quot;delete from&quot;                                    # 文件中搜索文本“delete from”</span><br><span class="line">git grep -e &#x27;#define&#x27; --and -e SORT_DIRENT</span><br><span class="line">git gc</span><br><span class="line">git fsck</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>studynote</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub+Hexo搭建个人网站详细教程</title>
    <url>/2022/02/25/GitHub-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="GitHub-Hexo-搭建个人网站详细教程"><a href="#GitHub-Hexo-搭建个人网站详细教程" class="headerlink" title="GitHub+Hexo 搭建个人网站详细教程"></a>GitHub+Hexo 搭建个人网站详细教程</h1><p><img src="https://pica.zhimg.com/v2-d4c1239e75c02e8482c22017a6c8d407_1440w.jpg?source=172ae18b" alt="https://pica.zhimg.com/v2-d4c1239e75c02e8482c22017a6c8d407_1440w.jpg?source=172ae18b"></p>
<h4 id="雷宇-http-leiyu-code-github-io"><a href="#雷宇-http-leiyu-code-github-io" class="headerlink" title="[雷宇]http://leiyu-code.github.io"></a>[雷宇]<a href="http://leiyu-code.github.io/">http://leiyu-code.github.io</a></h4><p><strong>前言：</strong></p>
<p>随着互联网浪潮的翻腾，国内外涌现出越来越多优秀的社交网站让用户分享信息更加便捷。然后，如果你是一个不甘寂寞的程序猿（媛），是否也想要搭建一个属于自己的个人网站，如果你曾经或者现在正有这样的想法，请跟随这篇文章发挥你的Geek精神，让你快速拥有自己的博客网站，写文章记录生活，享受这种从0到1的过程。   </p>
 <span id="more"></span>

<p><a href="https://www.zhihu.com/question/29755481">你见过的最棒的个人博客界面是什么样的？</a></p>
<h2 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo ?"></a><strong>什么是Hexo ?</strong></h2><p><img src="https://pic2.zhimg.com/80/v2-6890485c84748900d9dae824b7f7cbb1_720w.jpg" alt="https://pic2.zhimg.com/80/v2-6890485c84748900d9dae824b7f7cbb1_720w.jpg"></p>
<p>Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Heroku上，是搭建博客的首选框架。这里我们选用的是GitHub，你没看错，全球最大的同性恋交友网站（逃……）。Hexo同时也是GitHub上的开源项目，参见：<a href="https://link.zhihu.com/?target=https://github.com/hexojs/hexo">hexojs&#x2F;hexo</a> 如果想要更加全面的了解Hexo，可以到其官网 <a href="https://link.zhihu.com/?target=https://hexo.io/">Hexo</a> 了解更多的细节，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。这里，默认各位猿&#x2F;媛儿都知道GitHub就不再赘述。</p>
<p><strong>这是我的个人博客效果:</strong> <a href="http://leiyu-code.github.io/">http://leiyu-code.github.io</a></p>
<p>下面正式从零开始搭建年轻人的第一个网站。</p>
<h2 id="搭建步骤："><a href="#搭建步骤：" class="headerlink" title="搭建步骤："></a><strong>搭建步骤：</strong></h2><ul>
<li>获得个人网站域名</li>
<li>GitHub创建个人仓库</li>
<li>安装Git</li>
<li>安装Node.js</li>
<li>安装Hexo</li>
<li>推送网站</li>
<li>绑定域名</li>
<li>更换主题</li>
<li>初识MarkDown语法</li>
<li>发布文章</li>
<li>寻找图床</li>
<li>个性化设置</li>
<li>其他</li>
<li>附录</li>
</ul>
<p><strong>获得个人网站域名</strong></p>
<p>域名是网站的入口，也是网站的第一印象，比如饿了么的官网的域名是：<a href="https://link.zhihu.com/?target=https://www.ele.me/">https://www.ele.me/</a> ，很是巧妙。常见的有com,cn,net,org等后缀，也有小众的xyz,me,io等后缀，根据你自己的喜好，选择不同的后缀，比如我选择就是常见的com后缀。很多小众奇特的后缀在大陆是没办法备案的，网站也就无法上线。然而使用GitHub托管我们的网站，完全不需要备案，因为托管我们的网站内容的服务器在美国，而且在国内备案流程也比较繁杂，时间需要一周左右。</p>
<p>申请域名的地方有很多，这里推荐阿里云：<a href="https://link.zhihu.com/?target=https://www.aliyun.com/">阿里云-为了无法计算的价值</a> 申请入口：<a href="https://link.zhihu.com/?target=https://wanwang.aliyun.com/domain/">域名注册</a> 购买域名这也是我们整个搭建过程中惟一一个需要花钱的地方。如果你已经有了空闲域名就无需购买，直接使用即可。</p>
<p><strong>GitHub创建个人仓库</strong></p>
<p>登录到GitHub,如果没有GitHub帐号，使用你的邮箱注册GitHub帐号：<a href="https://link.zhihu.com/?target=https://github.com/">Build software better, together</a> 点击GitHub中的New repository创建新仓库，仓库名应该为：<strong>用户名</strong>.github.io这个<strong>用户名</strong>使用你的GitHub帐号名称代替，这是固定写法，比如我的仓库名为：</p>
<p><img src="https://pic4.zhimg.com/80/v2-832168e58b4ac4ce7c3cca797711d2d3_720w.jpg" alt="https://pic4.zhimg.com/80/v2-832168e58b4ac4ce7c3cca797711d2d3_720w.jpg"></p>
<p><strong>安装Git</strong></p>
<p>什么是Git ?简单来说Git是开源的分布式版本控制系统，用于敏捷高效地处理项目。我们网站在本地搭建好了，需要使用Git同步到GitHub上。如果想要了解Git的细节，参看<a href="https://link.zhihu.com/?target=http://weibo.com/liaoxuefeng">廖雪峰</a>老师的Git教程：<a href="https://link.zhihu.com/?target=http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">Git教程</a> 从Git官网下载：<a href="https://link.zhihu.com/?target=https://git-scm.com/download/win">Git - Downloading Package</a> 现在的机子基本都是64位的，选择64位的安装包，下载后安装，在命令行里输入git测试是否安装成功，若安装失败，参看其他详细的Git安装教程。安装成功后，将你的Git与GitHub帐号绑定，鼠标右击打开Git Bash</p>
<p><img src="https://pic3.zhimg.com/80/v2-8b1cbe253d6e0301bd9a68c6f98a9f52_720w.jpg" alt="https://pic3.zhimg.com/80/v2-8b1cbe253d6e0301bd9a68c6f98a9f52_720w.jpg"></p>
<p>或者在菜单里搜索Git Bash，设置user.name和user.email配置信息：</p>
<p><code>git config --global user.name &quot;你的GitHub用户名&quot; git config --global user.email &quot;你的GitHub注册邮箱&quot;</code></p>
<p>生成ssh密钥文件：</p>
<p><code>ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;</code></p>
<p>然后直接三个回车即可，默认不需要设置密码然后找到生成的.ssh的文件夹中的id_rsa.pub密钥，将内容全部复制</p>
<p>The key fingerprint is:</p>
<p>The key’s randomart image is:</p>
<p>默认生成目录是：</p>
<p>Your identification has been saved in c:&#x2F;Users&#x2F;Administrator&#x2F;.ssh&#x2F;id_rsa<br>Your public key has been saved in c:&#x2F;Users&#x2F;Administrator&#x2F;.ssh&#x2F;id_rsa.pub</p>
<p><img src="https://pic4.zhimg.com/80/v2-d1e47103ec1aa8675f68688c5d63bd27_720w.jpg" alt="https://pic4.zhimg.com/80/v2-d1e47103ec1aa8675f68688c5d63bd27_720w.jpg"></p>
<p>打开<a href="https://link.zhihu.com/?target=https://github.com/settings/keys">GitHub_Settings_keys</a> 页面，新建new SSH Key</p>
<p><img src="https://pic1.zhimg.com/80/v2-72a3f22c080e99343c3cc4aabce10e3c_720w.jpg" alt="https://pic1.zhimg.com/80/v2-72a3f22c080e99343c3cc4aabce10e3c_720w.jpg"></p>
<p>Title为标题，任意填即可，将刚刚复制的id_rsa.pub内容粘贴进去，最后点击Add SSH key。在Git Bash中检测GitHub公钥设置是否成功，输入 ssh  <a href="mailto:&#103;&#x69;&#116;&#64;&#x67;&#x69;&#x74;&#104;&#x75;&#98;&#46;&#99;&#x6f;&#x6d;">&#103;&#x69;&#116;&#64;&#x67;&#x69;&#x74;&#104;&#x75;&#98;&#46;&#99;&#x6f;&#x6d;</a> ：</p>
<p><img src="https://pic3.zhimg.com/80/v2-da481ffa686410becd4186c656b4ebd6_720w.jpg" alt="https://pic3.zhimg.com/80/v2-da481ffa686410becd4186c656b4ebd6_720w.jpg"></p>
<p>如上则说明成功。这里之所以设置GitHub密钥原因是，通过非对称加密的公钥与私钥来完成加密，公钥放置在GitHub上，私钥放置在自己的电脑里。GitHub要求每次推送代码都是合法用户，所以每次推送都需要输入账号密码验证推送用户是否是合法用户，为了省去每次输入密码的步骤，采用了ssh，当你推送的时候，git就会匹配你的私钥跟GitHub上面的公钥是否是配对的，若是匹配就认为你是合法用户，则允许推送。这样可以保证每次的推送都是正确合法的。</p>
<p>第一次连接ssh必须要用 ssh -T <a href="mailto:&#x67;&#x69;&#x74;&#64;&#103;&#105;&#x74;&#x68;&#117;&#98;&#46;&#99;&#111;&#x6d;">&#x67;&#x69;&#x74;&#64;&#103;&#105;&#x74;&#x68;&#117;&#98;&#46;&#99;&#111;&#x6d;</a></p>
<p><strong>安装Node.js</strong></p>
<p>Hexo基于Node.js，Node.js下载地址：<a href="https://link.zhihu.com/?target=https://nodejs.org/en/download/">Download | Node.js</a> 下载安装包，注意安装Node.js会包含环境变量及npm的安装，安装后，检测Node.js是否安装成功，在命令行中输入 node -v :</p>
<p><img src="https://pic1.zhimg.com/80/v2-76ea38e9545e606f975781e47933b010_720w.jpg" alt="https://pic1.zhimg.com/80/v2-76ea38e9545e606f975781e47933b010_720w.jpg"></p>
<p>检测npm是否安装成功，在命令行中输入npm -v :</p>
<p><img src="https://pic2.zhimg.com/80/v2-bede250b8456df92475b455fda8c1dd9_720w.jpg" alt="https://pic2.zhimg.com/80/v2-bede250b8456df92475b455fda8c1dd9_720w.jpg"></p>
<p>到这了，安装Hexo的环境已经全部搭建完成。</p>
<p><strong>安装Hexo</strong></p>
<p>Hexo就是我们的个人博客网站的框架。在git bash命令里进行Hexo的安装，</p>
<p><img src="https://pic1.zhimg.com/80/v2-a5450a466c0927c25dff8ad6f1d2046c_720w.jpg" alt="https://pic1.zhimg.com/80/v2-a5450a466c0927c25dff8ad6f1d2046c_720w.jpg"></p>
<p>使用npm命令安装Hexo，输入：</p>
<p><code>npm install -g hexo-cli</code></p>
<p>这个安装时间较长耐心等待，安装完成后，</p>
<p>当前目录下会建立名称为blog的文件夹，进入blog文件夹输入</p>
<p><code>hexo init</code></p>
<p>或不进入文件夹输入</p>
<p><code>hexo init blog</code></p>
<p>会自动建立一个名称为blog的文件夹</p>
<p>初始化我们的博客。</p>
<p>注意，这里的命令都是作用在刚刚创建的Blog文件夹中。</p>
<p>为了检测我们的网站雏形，分别按顺序输入以下三条命令：</p>
<p><code>hexo new test_my_site hexo g hexo s</code></p>
<p>这些命令在后面作介绍，完成后，打开浏览器输入地址：</p>
<p><a href="http://localhost:4000/">localhost:4000</a></p>
<p>可以看出我们写出第一篇博客，只不过我下图是我修改过的配置，和你的显示不一样。</p>
<p><img src="https://pic4.zhimg.com/80/v2-123e73c0630d299b1c856d99b04b55bb_720w.jpg" alt="https://pic4.zhimg.com/80/v2-123e73c0630d299b1c856d99b04b55bb_720w.jpg"></p>
<p>现在来介绍常用的Hexo 命令</p>
<p>npm install hexo -g #安装Hexo</p>
<p>npm update hexo -g #升级</p>
<p>hexo init #初始化博客命令简写</p>
<p>hexo n “我的博客” &#x3D;&#x3D; </p>
<p>hexo new “我的博客” #新建文章</p>
<p>hexo g &#x3D;&#x3D; hexo generate #生成</p>
<p>hexo s &#x3D;&#x3D; hexo server #启动服务预览</p>
<p>hexo d &#x3D;&#x3D; hexo deploy #部署</p>
<p>hexo server #Hexo会监视文件变动并自动更新，无须重启服务器</p>
<p>hexo server -s #静态模式</p>
<p>hexo server -p 5000 #更改端口</p>
<p>hexo server -i 192.168.1.1 #自定义 </p>
<p>IPhexo clean #清除缓存，若是网页正常情况下可以忽略这条命令</p>
<p>刚刚的三个命令依次是新建一篇博客文章、生成网页、在本地预览的操作。</p>
<p><strong>推送网站</strong></p>
<p>上面只是在本地预览，接下来要做的就是就是推送网站，也就是发布网站，让我们的网站可以被更多的人访问。在设置之前，需要解释一个概念，在blog根目录里的_config.yml文件称为<strong>站点</strong>配置文件，如下图</p>
<p><img src="https://pic2.zhimg.com/80/v2-cb1fd5e5a2e73f513234e434724c7c55_720w.jpg" alt="https://pic2.zhimg.com/80/v2-cb1fd5e5a2e73f513234e434724c7c55_720w.jpg"></p>
<p>进入根目录里的themes文件夹，里面也有个_config.yml文件，这个称为<strong>主题</strong>配置文件，如下图</p>
<p><img src="https://pic4.zhimg.com/80/v2-4252029e5634bf91c7d58916ae2b8ac3_720w.jpg" alt="https://pic4.zhimg.com/80/v2-4252029e5634bf91c7d58916ae2b8ac3_720w.jpg"></p>
<p>下一步将我们的Hexo与GitHub关联起来，打开站点的配置文件_config.yml，翻到最后修改为：</p>
<p>deploy:type: gitrepo: 这里填入你之前在GitHub上创建仓库的完整路径，记得加上 .gitbranch: master参考如下：</p>
<p>deploy:<br>type: git<br>repo: <a href="mailto:git@github.com">git@github.com</a>:LeiYu-code&#x2F;LeiYu-code.github.io.git<br>branch: master</p>
<p>保存站点配置文件。</p>
<p>注意：</p>
<p>因为已经配置好了token密码，这里的仓库链接最好用ssh链接</p>
<p>密码输错两次后会导致连不上仓库，最好重启电脑</p>
<p>其实就是给hexo d 这个命令做相应的配置，让hexo知道你要把blog部署在哪个位置，很显然，我们部署在我们GitHub的仓库里。最后安装Git部署插件，输入命令：</p>
<p><code>npm install hexo-deployer-git --save</code></p>
<p>这时，我们分别输入三条命令:</p>
<p><code>hexo clean   hexo g   hexo d</code></p>
<p>其实第三条的 hexo d 就是部署网站命令，d是deploy的缩写。完成后，打开浏览器，在地址栏输入你的放置个人网站的仓库路径，即 <a href="https://link.zhihu.com/?target=http://xxxx.github.io">http://xxxx.github.io</a> (知乎排版可能会出现”http:&#x2F;&#x2F;“字样，参考下图) 比如我的xxxx就是我的GitHub用户名：</p>
<p><img src="https://pic1.zhimg.com/80/v2-d750452f4258bf0967d5629ef23d1b10_720w.jpg" alt="https://pic1.zhimg.com/80/v2-d750452f4258bf0967d5629ef23d1b10_720w.jpg"></p>
<p>你就会发现你的博客已经上线了，可以在网络上被访问了。</p>
<p><strong>绑定域名</strong></p>
<p>虽然在Internet上可以访问我们的网站，但是网址是GitHub提供的:<a href="https://link.zhihu.com/?target=http://xxxx.github.io">http://xxxx.github.io</a> (知乎排版可能会出现”http:&#x2F;&#x2F;“字样) 而我们想使用我们自己的个性化域名，这就需要绑定我们自己的域名。这里演示的是在阿里云万网的域名绑定，在国内主流的域名代理厂商也就阿里云和腾讯云。登录到阿里云，进入管理控制台的域名列表，找到你的个性化域名，进入解析</p>
<p><img src="https://pic3.zhimg.com/80/v2-47323ad4490e206aef93a3d68f0670b6_720w.jpg" alt="https://pic3.zhimg.com/80/v2-47323ad4490e206aef93a3d68f0670b6_720w.jpg"></p>
<p>然后添加解析</p>
<img src="https://pic3.zhimg.com/80/v2-40222b3a295bb692aac22829a8ec3be2_720w.jpg" alt="https://pic3.zhimg.com/80/v2-40222b3a295bb692aac22829a8ec3be2_720w.jpg" style="zoom:50%;" />

<p>包括添加三条解析记录，192.30.252.153是GitHub的地址，你也可以ping你的 <a href="https://link.zhihu.com/?target=http://xxxx.github.io">http://xxxx.github.io</a> 的ip地址，填入进去。第三个记录类型是CNAME，CNAME的记录值是：你的用户名.<a href="https://link.zhihu.com/?target=http://github.io">http://github.io</a> 这里千万别弄错了。第二步，登录GitHub，进入之前创建的仓库，点击settings，设置Custom domain，输入你的域名</p>
<p><img src="https://pic4.zhimg.com/80/v2-85ba6dda906f22dea4c03df2b47d994b_720w.jpg" alt="https://pic4.zhimg.com/80/v2-85ba6dda906f22dea4c03df2b47d994b_720w.jpg"></p>
<p>点击save保存。第三步，进入本地博客文件夹 ，进入blog&#x2F;source目录下，创建一个记事本文件，输入你的域名，对，只要写进你自己的域名即可。如果带有www，那么以后访问的时候必须带有www完整的域名才可以访问，但如果不带有www，以后访问的时候带不带www都可以访问。所以建议，不要带有www。这里我还是写了www(不建议带有www):</p>
<p><img src="https://pic1.zhimg.com/80/v2-79abfff91af3f520e24cb91acf6aa994_720w.jpg" alt="https://pic1.zhimg.com/80/v2-79abfff91af3f520e24cb91acf6aa994_720w.jpg"></p>
<p>保存，命名为CNAME ，·保存成<strong>所有文件</strong>而不是<strong>txt文件</strong>。</p>
<p>完成这三步，进入blog目录中，按住shift键右击打开命令行，依次输入：</p>
<p><code>hexo clean hexo g hexo d</code></p>
<p>这时候打开浏览器在地址栏输入你的个性化域名将会直接进入你自己搭建的网站。</p>
<p><strong>更改语言为中文：</strong></p>
<p>找到_config.yml文件，将language修改</p>
<p><code>language: zh-Hans</code></p>
<p>![Untitled](C:&#x2F;Users&#x2F;Administrator&#x2F;Desktop&#x2F;Export-c06c179a-cfc9-4393-87d2-32a5dd488402&#x2F;GitHub+Hex ab864&#x2F;Untitled.png)</p>
<p><strong>更换主题</strong></p>
<p>在第一次更换主题文件时，要将配置文件的false改成ture，改成可以控制的</p>
<p>如果你不喜欢Hexo默认的主题，可以更换不同的主题，主题传送门：<a href="https://link.zhihu.com/?target=https://hexo.io/themes/">Themes</a> 我自己使用的是Next主题，可以在blog目录中的themes文件夹中查看你自己主题是什么。现在把默认主题更改成Next主题，在blog目录中（就是命令行的位置处于blog目录）打开命令行输入：</p>
<p><code>git clone git://github.com/iissnan/hexo-theme-next themes/next</code></p>
<p>这是将Next主题下载到blog目录的themes主题下的next文件夹中。打开<strong>站点</strong>的_config.yml配置文件，修改主题为next</p>
<p><img src="https://pic1.zhimg.com/80/v2-b1997377e82408cb15b485c65ae00f70_720w.jpg" alt="https://pic1.zhimg.com/80/v2-b1997377e82408cb15b485c65ae00f70_720w.jpg"></p>
<p>- </p>
<p>打开<strong>主题</strong>的_config.yml配置文件，不是站点主题文件，找到Scheme Settings</p>
<p><img src="https://pic2.zhimg.com/80/v2-1ac152c4aabe4c10b762ee27552f1105_720w.jpg" alt="https://pic2.zhimg.com/80/v2-1ac152c4aabe4c10b762ee27552f1105_720w.jpg"></p>
<p>next主题有三个样式，我用的是Pisces，你们可以自己试试看，选择你自己喜欢的样式（只需要把行首的#去除，#是注释），选择好后，再次部署网站，hexo g、hexo d，查看效果。选择其他主题，按照上述过程即可实现。</p>
<p><strong>初识Markdown语法</strong></p>
<p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown语法简洁明了、容易掌握，而且功能比纯文本更强，因此写博客使用它，可以让用户更加专注的写文章，而不需要费尽心力的考虑样式，相对于html已经算是轻量级语言，像有道云笔记也支持Markdown写作。并且Markdown完全兼容html，也就是可以在文章里直接插入html代码。比如给博文添加音乐，就可以直接把音乐的外链html代码插入文章中。具体语法参看：<a href="https://link.zhihu.com/?target=http://www.appinn.com/markdown/">Markdown 语法说明(简体中文版)</a> 可以说十分钟就可以入门。当然，工欲善其事必先利其器，选择一个好的Markdown编辑器也是非常重要的，这里推荐<a href="https://link.zhihu.com/?target=http://code52.org/DownmarkerWPF/">MarkPad</a> 和<a href="https://link.zhihu.com/?target=http://www.markdownpad.com/">The Markdown Editor for Windows</a> ，这是带有预览效果的编辑器，也可以使用本地的文本编辑器，更多的Markdown的语法与编辑器自己可以搜索了解。</p>
<p><strong>发布文章</strong></p>
<p>我们开始正式发布上线博客文章，在命令行中输入：</p>
<p><code>hexo n &quot;博客名字&quot;</code></p>
<p>我们会发现在blog根目录下的source文件夹中的_post文件夹中多了一个 <strong>博客名字.md</strong> 文件，使用Markdown编辑器打开，就可以开始你的个人博客之旅了，Markdown常用的样式也就十来种，完全能够满足一般博文的样式要求，这是我的一篇博文内容示例：</p>
<p><img src="https://pic1.zhimg.com/80/v2-4f96cd03a88e68b8ae86c38bfb0808ac_720w.jpg" alt="https://pic1.zhimg.com/80/v2-4f96cd03a88e68b8ae86c38bfb0808ac_720w.jpg"></p>
<p>通过带有预览样式的Markdown编辑器实时预览书写的博文样式，也可以通过命令 hexo s –debug 在本地浏览器的localhost:4000 预览博文效果。写好博文并且样式无误后，通过hexo g、hexo d 生成、部署网页。随后可以在浏览器中输入域名浏览。</p>
<p><strong>寻找图床</strong></p>
<p>图床，当博文中有图片时，若是少量图片，可以直接把图片存放在source文件夹中，但这显然不合理的，因为图片会占据大量的存储的空间，加载的时候相对缓慢 ，这时考虑把博文里的图片上传到某一网站，然后获得外部链接，使用Markdown语法，**<img src="C:/Users/Administrator/Desktop/Export-c06c179a-cfc9-4393-87d2-32a5dd488402/外部链接" alt="图片信息">** 完成图片的插入，这种网站就被成为图床。常见的简易的图床网站有：<a href="https://link.zhihu.com/?target=http://www.tietuku.com/">贴图库图片外链</a> 国内算比较好的图床我认为有两个：新浪微博和 <a href="https://link.zhihu.com/?target=https://www.qiniu.com/">七牛云</a> ，七牛云的使用方法可以参看其他文章。图床最重要的就是稳定速度快，所以在挑选图床的时候一定要仔细，下图是博文插入图片，使用图床外链的示例：</p>
<p><img src="https://pic4.zhimg.com/80/v2-92372e522595af139ace5f371aae3ff3_720w.jpg" alt="https://pic4.zhimg.com/80/v2-92372e522595af139ace5f371aae3ff3_720w.jpg"></p>
<p><strong>个性化设置</strong></p>
<p>所谓的个性化设置就是根据个人需要添加不同的插件及功能。</p>
<p>基本的有：</p>
<p>在站点配置文件_config.yml修改基本的站点信息</p>
<p><img src="https://pic4.zhimg.com/80/v2-78bc0e4e6498c9c3cb269b3254d8379f_720w.jpg" alt="https://pic4.zhimg.com/80/v2-78bc0e4e6498c9c3cb269b3254d8379f_720w.jpg"></p>
<p>依次是网站标题、副标题、网站描述、作者、网站头像外部链接、网站语言、时区等。</p>
<p>在主题配置文件_config.yml修改基本的主题信息，如：</p>
<p><img src="https://pic2.zhimg.com/80/v2-451c5cb2fd6516650ad8ca608031bf0d_720w.jpg" alt="https://pic2.zhimg.com/80/v2-451c5cb2fd6516650ad8ca608031bf0d_720w.jpg"></p>
<p>博文打赏的微信、支付宝二维码图片，这里我是直接把这两张放在根目录的source文件夹中，并没有使用图床外链。</p>
<p><img src="https://pic2.zhimg.com/80/v2-69bbc45e973eb6916e08187ed8b33a55_720w.jpg" alt="https://pic2.zhimg.com/80/v2-69bbc45e973eb6916e08187ed8b33a55_720w.jpg"></p>
<p>社交外链的设置，即在侧栏展示你的个人社交网站信息。</p>
<p><img src="https://pic4.zhimg.com/80/v2-5b3f6e02e0d3a0cdb685a4d2fd2718cb_720w.jpg" alt="https://pic4.zhimg.com/80/v2-5b3f6e02e0d3a0cdb685a4d2fd2718cb_720w.jpg"></p>
<p>博文分享的插件jiathis，值设置为true。在配置文件中有很多的个性化设置，可以自尝试更多的修改。</p>
<p>进阶个性化：</p>
<ul>
<li>添加网易云音乐</li>
</ul>
<p>打开网页版的网易云音乐，选择喜欢的音乐，点击生成外链播放器</p>
<p><img src="https://pic2.zhimg.com/80/v2-fcb7d44ccdca3760c98db0d13817f2b5_720w.jpg" alt="https://pic2.zhimg.com/80/v2-fcb7d44ccdca3760c98db0d13817f2b5_720w.jpg"></p>
<p>复制外链的代码</p>
<p><img src="https://pic4.zhimg.com/80/v2-16eec195312cde7b1d257fac6f3c8d0b_720w.jpg" alt="https://pic4.zhimg.com/80/v2-16eec195312cde7b1d257fac6f3c8d0b_720w.jpg"></p>
<p>比如在侧栏插入这首歌的音乐播放器，修改 blog\themes\next\layout_macro的sidebar.swig文件，添加刚刚复制的外链代码</p>
<p><img src="https://pic4.zhimg.com/80/v2-03db51002497b27e4d5888e0efd577c7_720w.jpg" alt="https://pic4.zhimg.com/80/v2-03db51002497b27e4d5888e0efd577c7_720w.jpg"></p>
<p>重新生成、部署网页，效果如下</p>
<p><img src="https://pic2.zhimg.com/80/v2-3d587bf919df92db38e2608f034e50f1_720w.jpg" alt="https://pic2.zhimg.com/80/v2-3d587bf919df92db38e2608f034e50f1_720w.jpg"></p>
<ul>
<li>设置背景</li>
</ul>
<p>把你挑选的背景图片命名为：background.jpg，放在blog\themes\next\source\images里，在blog\themes\next\source\css_custom文件的custom.styl首部添加：</p>
<p><code>body &#123;   **background**:url(/images/background.jpg);   **background-attachment**: **fixed**; &#125;</code></p>
<p>background-attachment: fixed;是固定背景图片。</p>
<p>这是设置一张静态图片作为背景，其实Next主题自带有动态的背景效果，修改主题配置文件中的canvas_nest: false为canvas_nest: true即可。</p>
<ul>
<li>增加侧栏菜单条目</li>
</ul>
<p>默认的侧栏菜单条目有：首页、归档、标签、关于、搜索等。如果你想要增加其他的菜单条目，修改主题配置文件_config.yml里的Menu Settings中的menu和menu_icons两个地方</p>
<p><img src="https://pic3.zhimg.com/80/v2-666a22fedbba95d979eeb26e52fc29e2_720w.jpg" alt="https://pic3.zhimg.com/80/v2-666a22fedbba95d979eeb26e52fc29e2_720w.jpg"></p>
<p>其中menu里是配置菜单项对应的页面位置（如：&#x2F;love），menu_icons对应菜单项的图标，这里的图标是来自于<a href="https://link.zhihu.com/?target=http://fontawesome.io/">Font Awesome</a> ，所以你需要在Font Awesome网站上找到你需要的icon，然后把该icon的名字写在menu_icons对应菜单名后面，注意冒号有一个英文输入状态的空格。设置好后，在命令行里输入：</p>
<p><code>hexo new page &quot;你所要增加的菜单项名称（要和你在menu中的填写要匹配）&quot;</code></p>
<p>新建的页面在博客根目录下的source文件里，这时你就可以对新建的页面自定义设计。</p>
<p>还有更多的进阶个性化设置，如SEO、评论系统、个人头像、博客分享、订阅功能、High功能、404网页设置等，可以参看：</p>
<p><a href="https://link.zhihu.com/?target=http://theme-next.iissnan.com/theme-settings.html">主题配置 - NexT 使用文档</a></p>
<p><a href="https://link.zhihu.com/?target=http://theme-next.iissnan.com/third-party-services.html">第三方服务集成 - NexT 使用文档</a></p>
<p><a href="https://link.zhihu.com/?target=http://theme-next.iissnan.com/tag-plugins.html">内置标签 - NexT 使用文</a></p>
<p><a href="https://link.zhihu.com/?target=http://theme-next.iissnan.com/tag-plugins.html">档</a><a href="https://link.zhihu.com/?target=http://theme-next.iissnan.com/advanced-settings.html">进阶设定 - NexT 使用文档</a></p>
<p>有很多人私信问我High功能特效如何设置，这里推荐一篇同是Next主题网站博主的文章：<a href="https://link.zhihu.com/?target=http://www.iamlj.com/2016/08/add-special-effect-harlem-shake-for-hexo/">为Hexo Next主题添加哈林摇特效（五）</a></p>
<p><strong>其他</strong></p>
<p>终于写到这里了，也算是基本圆满完成了我的写作初衷，总结自己的一些经验，分享一些有趣的东西，不过脖子也是僵硬的受不了。我知道很多人想要建立自己的个人网站却一直没有付诸行动，希望这篇文章能给你一点点灵感与想法，just do it。本文是windows平台的搭建过程，其他平台可以参看相关资料，也有很多其他优秀的博客框架值得学习。如果有任何建议或想法、或疑问欢迎在评论区交流， 做好的网站不妨在评论区贴出网址，让大家一起学习。</p>
<p><strong>附录</strong></p>
<p><strong>以下是评论区贴出网址的博客展示：</strong></p>
<p><a href="https://link.zhihu.com/?target=http://jmyblog.top/">…Miss.j BlogDiary…</a></p>
<p><a href="https://link.zhihu.com/?target=http://ibb.chaodamiao.com/">RILWEIC</a></p>
<p><a href="https://link.zhihu.com/?target=http://blog.sunxinfei.com/">Xin’s Notes</a></p>
<p><a href="https://link.zhihu.com/?target=https://guguant.github.io/">飞鸟与鱼</a></p>
<p><a href="https://link.zhihu.com/?target=http://www.fuck-goods.tk/">无名博客</a></p>
<p><a href="https://link.zhihu.com/?target=http://helloqa.com/">iTesting软件测试知识分享</a></p>
<p><a href="https://link.zhihu.com/?target=http://bolg.upsky.top/">赵小源的个人博客</a></p>
<p><a href="https://link.zhihu.com/?target=http://www.huajiayi.top/">华嘉熠’s Blog</a></p>
<p><a href="https://link.zhihu.com/?target=http://asmire.site/">Cocoon</a></p>
<p><a href="https://link.zhihu.com/?target=https://luoshaoxiong.github.io/">罗少雄’s Blog</a></p>
<p><a href="https://link.zhihu.com/?target=https://lruihao.github.io/">李四啊_</a></p>
<p><strong>其他优秀个人博客展示：</strong></p>
<p><a href="https://link.zhihu.com/?target=https://www.dandyweng.com/">翁天信 · Dandy Weng</a> <a href="https://link.zhihu.com/?target=http://chaoxuprime.com/">chaoxuprim</a> <a href="https://link.zhihu.com/?target=http://kenjiendo.com/">KENJI ENDO</a> <a href="https://link.zhihu.com/?target=http://shenzekun.cn/">Moorez</a> <a href="https://link.zhihu.com/?target=https://codesky.me/">CodeSky 代码之空</a> <a href="https://link.zhihu.com/?target=http://www.helloshawn.cn/">大江东去</a> <a href="https://link.zhihu.com/?target=http://iconmoon.com/">UI Design Portfolio of JJ Ying</a> <a href="https://link.zhihu.com/?target=http://www.jeyzhang.com/">JeyZhang</a> <a href="https://link.zhihu.com/?target=http://blog.lightina.cn/">jacklightChen | 得到的都是侥幸</a> <a href="https://link.zhihu.com/?target=https://qingpei.me/">edwardtoday</a> <a href="https://link.zhihu.com/?target=http://rafaltomal.com/">Rafal Tomal - Web Designer and Genesis Developer</a> <a href="https://link.zhihu.com/?target=http://strml.net/">Projects and Work</a> <a href="https://link.zhihu.com/?target=http://miaoxiaoer.com/">绘画爱好者</a> <a href="https://link.zhihu.com/?target=http://ursocute.github.io/">万世奇的博客</a> <a href="https://link.zhihu.com/?target=https://rauchg.com/">Guillermo Rauch</a></p>
<ul>
<li>转载自吴润的博客</li>
</ul>
]]></content>
      <categories>
        <category>studynote</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
